<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Less is more</title>
    <link>https://xuejie.space/</link>
    <description>Recent content on Less is more</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
        <atom:link href="https://xuejie.space/index.xml" rel="self" type="application/rss+xml" />
    
    
      
      <item>
        <title>Diviner: A New Attempt on Deterministic Testing</title>
        <link>https://xuejie.space/2020_04_11_diviner_a_new_attempt_on_deterministic_testing/</link>
        <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_04_11_diviner_a_new_attempt_on_deterministic_testing/</guid>
        <description>&lt;p&gt;I&amp;rsquo;ve long been fascinated by the problem of deterministic execution. We&amp;rsquo;ve stuck so long on the multi-threaded model. Most of us have encountered bugs that only appear with some probabilities. Even though you have prepared a fix, you won&amp;rsquo;t know for sure if it will occur again, all you can do is testing, testing and testing, hoping the problem won&amp;rsquo;t appear again. It is in every engineer&amp;rsquo;s dream, that we can deterministically debug and ensure that we can say with 100% certainty, that a problem has been eliminated.&lt;/p&gt;
&lt;p&gt;For the past few months, I&amp;rsquo;ve been learning about &lt;a href=&#34;https://lamport.azurewebsites.net/tla/tla.html&#34;&gt;TLA+&lt;/a&gt;, I do firmly believe now TLA+ is an invaluable tool in building sophisticated, multi-threaded, performant (and maybe also distributed) systems. I do prefer to build design first in TLA+ before writing a single line of code for all my projects. But TLA+ can only help you think about the design, and fix any design flaws. There is still the other side of story: actually implement the system. We could have a design validated by TLA+, but what if the code you write is vulnerable to some concurrency bugs that happens with certain probability?&lt;/p&gt;
&lt;p&gt;There are, of course, some attempts at the solution, such as &lt;a href=&#34;https://rr-project.org/&#34;&gt;rr&lt;/a&gt;. But one true gem in this area, is &lt;a href=&#34;https://www.foundationdb.org/&#34;&gt;FoundationDB&lt;/a&gt;. If you don&amp;rsquo;t know much about FoundationDB, specifically how they perform testing on it, I highly recommended the following 2 videos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=4fFDFbi3toc&#34;&gt;https://www.youtube.com/watch?v=4fFDFbi3toc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=fFSPwJFXVlw&#34;&gt;https://www.youtube.com/watch?v=fFSPwJFXVlw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What they did, is they build an actor model on top of C++, use the actor model to write the full database logic. As a result, they can inject the actor-based code into a deterministic testing framework to test all kinds of concurrency problems. Honestly I&amp;rsquo;ve watched the videos before, and in earlier time, I wasn&amp;rsquo;t too impressed by their solution for one reason: their simulation framework runs &lt;strong&gt;sequentially&lt;/strong&gt; in a single thread, this is far from a real setup, where you have multiple threads running together. The performance numbers you get from the simulation, don&amp;rsquo;t make sense, either.&lt;/p&gt;
&lt;p&gt;Luckily, I have a hobby of being a computer archaeologist: from time to time, I will dig out relatively older videos, and re-watch them for new insights. This is from a past experience, that many of the &lt;em&gt;new&lt;/em&gt; inventions in this industry, are just re-discoveries of old topics, but bottled in modern programming tastes. When I recently dig out the FoundationDB videos and re-watched them, I found I&amp;rsquo;ve made a horrible, horrible mistake earlier. This is indeed something big.&lt;/p&gt;
&lt;h1 id=&#34;testing-is-naturally-different-from-benchmarks&#34;&gt;Testing Is Naturally Different From Benchmarks&lt;/h1&gt;
&lt;p&gt;The key wisdom here, is that testing is naturally different from doing benchmarks. The point of testing is never to get an actual number of running time, but to &lt;strong&gt;explore&lt;/strong&gt; all the paths a program can take. Much like TLA+ would explore all the states in your design, a simulation will be more than enough if it can explore all the execution paths a piece of code can take. With code organized in actor model, your logic is naturally split into multiple small atomic pieces, as long as you can enumerate all the different execution orders a program can validly take, a single threaded testing framework can still explore all the paths a multi-threaded solution might result in!&lt;/p&gt;
&lt;p&gt;And there is actually more benefits in a simulation environment: when your project is released, people might start to use it, meaning they will try to run your code in many different machines. All those machines will then explore different execution states your program can result in, in a way, we can think of all those machines are busy testing your program for bugs. In order to maintain the quality of your project, you would ideally want to find any new bugs before all those many different machines. Now the problem becomes a race at enumerating possible states and look for bugs. For popular projects, the number of machines run by the users will easily outgrow the machines owned by the project maintainers. The question is: how can you win this game of finding more bugs, but with much fewer machines?&lt;/p&gt;
&lt;p&gt;The answer to this, lies in a simulation design like the FoundationDB solution: first, we organize the logic in an actor model framework, so we can use a single threaded simulation test executor to run the tests; second, we mock out all environment related code, such as timers, network IOs, file IOs, etc. This way we can distill the core of our project, which is also where most bugs would occur, into a single threaded, sequential code, with the following benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When a single test runs in a single threaded environment, a typical multi-core machine can be used to run multiple tests simultaneously;&lt;/li&gt;
&lt;li&gt;With all the IOs mocked out, we can run much fewer code in a test(e.g., we can skip the entire TCP/IP stack), resulting in much faster tests;&lt;/li&gt;
&lt;li&gt;Also with mocked IOs, it&amp;rsquo;s much easier for us to simulate abnormalies, such as congested networks;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of those benefits meaning the simulation solution can allow us to run much more tests on our code in much less time, giving us a chance to win the bug-finding game. In FoundationDB&amp;rsquo;s example, their estimation is that in several years they have accumulated the &lt;a href=&#34;https://apple.github.io/foundationdb/engineering.html&#34;&gt;equivalent of a trillion CPU-hours of simulated stress testing&lt;/a&gt; via this design. Till this day, I have yet to see a more advanced testing framework design.&lt;/p&gt;
&lt;p&gt;Now there is only one question: while this solution is great and proved to work well, can we leverage it elsewhere? Are we limited to the C++ actor framework? The question here, is of course no!&lt;/p&gt;
&lt;h1 id=&#34;rust-a-natual-choice-for-actor-based-simulation-testing&#34;&gt;Rust: A Natual Choice For Actor Based Simulation Testing&lt;/h1&gt;
&lt;p&gt;If we think about it, all it requires to do FoundationDB style deterministic simulation testing, is an actor based code, so we can re-organize them for testing needs. The exciting story here, is that Rust, our beloved solution for building high performance distributed software, is already &lt;a href=&#34;https://blog.rust-lang.org/2019/11/07/Async-await-stable.html&#34;&gt;embracing&lt;/a&gt; an async/await design, which is much like the actor model(well, I&amp;rsquo;m hardly a computer science professor, and I will leave it to the more qualified ones to tell if async/await is exactly actor model). To make it even more interesting, Rust&amp;rsquo;s &lt;a href=&#34;https://rust-lang.github.io/async-book/02_execution/04_executor.html&#34;&gt;swappable runtime&lt;/a&gt; design makes it an even greater choice for such a deterministic simulation testing idea: all we need to do, is to use a different runtime in testing, and the problem will be solved.&lt;/p&gt;
&lt;p&gt;That brings the leading role of this post: &lt;a href=&#34;https://github.com/xxuejie/diviner&#34;&gt;diviner&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;diviner&#34;&gt;Diviner&lt;/h1&gt;
&lt;p&gt;Once I had this idea, I felt it was so great, that I literally spent all my night time and weekends hacking on this idea, and built &lt;a href=&#34;https://github.com/xxuejie/diviner&#34;&gt;diviner&lt;/a&gt;. It composes of 2 parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A runtime that is designed to be single threaded and deterministic, so we can leverage it to build deterministic simulation tests;&lt;/li&gt;
&lt;li&gt;Wrappers on existing Rust async libraries. The wrappers would compile directly to existing implementations in normal mode(via inline functions and newtypes), but with a special &lt;code&gt;simulation&lt;/code&gt; feature enabled, they will be compiled to the mock versions which integrate with the above runtime for deterministic testing. Right now I&amp;rsquo;m starting on &lt;a href=&#34;https://async.rs/&#34;&gt;async-std&lt;/a&gt;, but more wrappers might be added later.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Combined together, diviner provides a FoundationDB style deterministic testing solution for async/await based Rust code. Several examples are provided &lt;a href=&#34;https://github.com/xxuejie/diviner#examples&#34;&gt;here&lt;/a&gt;, showcasing the ability to manipulate time, which allows testing timeouts in a much faster way, as well the ability to test concurrent bugs. With a deterministic seed, diviner will run deterministically, giving you the chance to debug the code as many times as you want. And the beauty part of this, is that it is just natural async/await Rust code, we are not introducing anythning new with diviner.&lt;/p&gt;
&lt;p&gt;I do have a different example that I like to make it work in the next couple of days:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use byteorder::{ByteOrder, LittleEndian};
use diviner::{
    net::{TcpListener, TcpStream},
    spawn, Environment,
};
use std::io;

async fn handle(stream: Tcpstream) {
    let mut buf = vec![];
    loop {
        let mut t = vec![0; 1024];
        let n = stream.read(&amp;amp;mut t).await.expect(&amp;quot;read error!&amp;quot;);
        if n == 0 {
            break;
        }
        buf.extend_from_slice(&amp;amp;t[..n]);
        let l = LittleEndian::read_u32(&amp;amp;buf) as usize;
        if buf.len() &amp;gt;= l + 4 {
            let content = &amp;amp;buf[4..l + 4];
            stream.write(content).await.expect(&amp;quot;write error!&amp;quot;);
            buf = buf.drain(0..l + 4).collect();
        }
    }
}

async fn server(addr: String) -&amp;gt; Result&amp;lt;(), io::Error&amp;gt; {
    let mut listener = TcpListener::bind(addr).await?;

    while let Ok((stream, _)) = listener.accept().await {
        spawn(handle(stream));
    }
    Ok(())
}

fn main() {
    let e = Environment::new();
    let result = e.block_on(async {
        let addr = &amp;quot;127.0.0.1:18000&amp;quot;;
        spawn(async {
            server(addr.to_string()).await.expect(&amp;quot;server boot error!&amp;quot;);
        });
        let data: Vec&amp;lt;u8&amp;gt; = vec![4, 0, 0, 0, 0x64, 0x61, 0x64, 0x61];
        for i in 1..data.len() {
            let mut client = TcpStream::connect(addr).await.expect(&amp;quot;connect error!&amp;quot;);
            client
                .write(&amp;amp;data[..i])
                .await
                .expect(&amp;quot;client write 1 error!&amp;quot;);
            client
                .write(&amp;amp;data[i..])
                .await
                .expect(&amp;quot;client write 1 error!&amp;quot;);
            let mut output: Vec&amp;lt;u8&amp;gt; = vec![0; 4];
            client.read(&amp;amp;mut output).await.expect(&amp;quot;client read error!&amp;quot;);
            if &amp;amp;output[..] != &amp;amp;data[4..] {
                panic!(&amp;quot;Invalid response!&amp;quot;);
            }
        }
    });
    match result {
        Ok(val) =&amp;gt; println!(&amp;quot;The task completed with {:?}&amp;quot;, val),
        Err(err) =&amp;gt; println!(&amp;quot;The task has panicked: {:?}&amp;quot;, err),
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example showcases a typical newcomer mistakes: TCP/IP protocol is stream based, not packet based. While you might provide a buffer of 1KB, the protocol can respond you with any number of bytes, including only 1 byte of data in extreme scenarios. In a real testing, this is really hard to simulate, since you need to create an environment where TCP/IP is so congested, that it only has a very small congestion window. But with diviner, tweaking this in testing would be real simple. And the code you write, just uses TcpListener/TCPStream exactly like the same name structs from async-std. Yes you will have to use diviner to import them, but with inline functions and newtype patterns, performance will not be affected at all. Once you are willing to take this sacrifice, I believe you will discover a whole new world.&lt;/p&gt;
&lt;p&gt;So that&amp;rsquo;s what excites me lately. Right now diviner is still in its early days, I will continue to work on diviner in my free time to add the missing parts(such as all the missing wrappers from async-std). If you are interested, feel free to give it a try, and let me know how you feel about it :P&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 10: Language Choices</title>
        <link>https://xuejie.space/2020_04_09_language_choices/</link>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_04_09_language_choices/</guid>
        <description>&lt;p&gt;When crafting CKB, we made the choice to use a generic VM, so it is not bound to any particular programming language. This model certainly has its pros, but it also comes with problems. A question we frequently receive is: what language should I use to program on Nervos CKB? Let&amp;rsquo;s try to answer this question here.&lt;/p&gt;
&lt;p&gt;First of all, I have had the belief that each dapp developer should have the freedom to pick their own choice of languages. No blockchain creators know the nuts and bolts better than the dapp developer themselves. No single programming language provides solutions for all kinds of dapps that might sprout. We offer different programming language choices, you can pick based on your needs.&lt;/p&gt;
&lt;p&gt;But at the same time, this is also an irresponsible answer! Telling a newcomer that you have many choices to choose from, is like telling them nothing. They will just be overwhelmed by the numerous choices. After all, all they want to do, is pick a language and start experimenting/building. This means while we do offer choices, we will also need to provide recommendations: what will we pick, if we just get started on building a new dapp on CKB?&lt;/p&gt;
&lt;p&gt;To make a recommendation, we will first need answers to 2 simple questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What is your purpose here? Are you just experimenting things on CKB, or are you already tasked to build a production grade dapp?&lt;/li&gt;
&lt;li&gt;What do you plan to build? Are you building a normal dapp, or are you creating a new crypto primitives on CKB?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The answers to the questions, will affect the choices we suggest here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: the recommendation made here, are only relavant when I write this post(Apr 9, 2020), we are building working on this field, and things might change. I will try to make sure this post is updated, but it is always better to check with us first to see our latest recommendation is, either on &lt;a href=&#34;https://discord.gg/AqGTUE9&#34;&gt;Discord&lt;/a&gt;, or &lt;a href=&#34;https://talk.nervos.org/&#34;&gt;Nervos Talk&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;production-level-languages&#34;&gt;Production Level Languages&lt;/h1&gt;
&lt;p&gt;For people tasked building a production grade dapp, a warning shall be provided above all: no matter what language you pick to build the smart contract part of your dapp, you should do security audit on your smart contracts. Vulnerabilities can only be eliminated via due diligence, no programming languages can help you on this part. With that said, we can now jump to the recommendation part.&lt;/p&gt;
&lt;p&gt;Unfortunately, all production level smart contracts on CKB now, are written in pure C. The reason for this, is not C is that suitable language for writing smart contract, but really that when we started out to build CKB, only C provides good enough quality for building the contracts we need. We don&amp;rsquo;t recommend using C to build any smart contract when you have a better choice, but we do admit sometimes C has to be the last resort.&lt;/p&gt;
&lt;p&gt;In the meantime, we are busy working on Rust support to prepare Rust for this list. While things are still a little rough today, Rust might be a decent choice for building production level smart contracts on CKB soon. And you can bet on that we will continue to maintain and support building Rust smart contracts on CKB. While personally, I know CKB VM can be leveraged in ways that Rust is having a hard time to keep up, the reality is Rust is a very popular and (in many cases) good enough choice for the blockchain world. We are hoping in the not-so-distant future, maybe in a few months, we can sincerely recommend using Rust to build production level smart contracts on CKB.&lt;/p&gt;
&lt;p&gt;While it certainly would not suit all cases, many people might be building smart contracts that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Needs rapid changes or dynamic behaviors;&lt;/li&gt;
&lt;li&gt;Are built by not so low-level focused engineers;&lt;/li&gt;
&lt;li&gt;Might not be so easily affected by cycle consumptions;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this group of people, JavaScript might also be a decent smart contract choice. We are now evaluating the possibilities if we can perform a round of security audit on duktape, or some other JavaScript engine that is suitable on CKB. While you still need to audit the JavaScript source written by yourself, we can help you ensure that the underlying JavaScript engine you use, will perform in a correct and secure behavior.&lt;/p&gt;
&lt;h1 id=&#34;experimental-languages&#34;&gt;Experimental Languages&lt;/h1&gt;
&lt;p&gt;When it comes to experimenting on CKB, you have more freedom to use different other languages. I will divide my recommendation here based on the second question above: the stuff you want to build on CKB.&lt;/p&gt;
&lt;h2 id=&#34;cryptographic-primitive-explorer&#34;&gt;Cryptographic Primitive Explorer&lt;/h2&gt;
&lt;p&gt;One unique aspect of CKB, is that it helps flourish cryptographic innovations. It&amp;rsquo;s now different from the old days, when you have to wait for a hardfork so someone can include your brand new cryptographic algorithms in a blockchain. With CKB, you can build any cryptographic algorithm, and ship it on chain immediately. You might say: well this is great, but what programming language shall we use here?&lt;/p&gt;
&lt;p&gt;If you have checked out &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts&#34;&gt;our code&lt;/a&gt;, you will noticed that we&amp;rsquo;ve taken the &lt;a href=&#34;https://github.com/bitcoin-core/secp256k1&#34;&gt;secp256k1 C library&lt;/a&gt; from the Bitcoin team(huge thanks guys!). So obvious, C is a choice here. But C is hardly the only choice: as mentioned above, we are busy working pushing the frontier here, and we are hoping soon Rust can provide a second choice here. There are already many cryptographic libraries built in Rust, we do want to embrace the whole blockchain community, rather than distancing from it. But there is actually more interesting story here besides C or Rust:&lt;/p&gt;
&lt;p&gt;If you dig &lt;a href=&#34;https://github.com/bitcoin-core/secp256k1/blob/4f27e344c69c33b4f3f448baa0196b9892287081/src/asm/field_10x26_arm.s&#34;&gt;deep&lt;/a&gt; &lt;a href=&#34;https://github.com/briansmith/ring/blob/00c21e253ba9cd3b66ab41155414b0d0e91b6c95/crypto/poly1305/asm/poly1305-x86_64.pl&#34;&gt;enough&lt;/a&gt;, most highly used cryptographic libraries uses hand-written assembly to further speed up the code. There is actually &lt;a href=&#34;https://cr.yp.to/qhasm/20050129-portable.txt&#34;&gt;good reason&lt;/a&gt; behind it. Since CKB builds on a real instruction set used by CPU, there&amp;rsquo;s actually no stopping from us to use hand-written RISC-V assembly to further speed up the crypto algorithms. To make it even more existing, we&amp;rsquo;ve been paying close attentions to 2 new RISC-V instruction set extension:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=GzZ-8bHsD5s&#34;&gt;V: Vector Extension&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/riscv/riscv-bitmanip&#34;&gt;B: Bit Manipulation Extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We believe those 2 extensions can bring up even closer to the full potential of modern days&#39; CPU architecture. Once they are introduced to CKB, hand-written, assembly based crypto algorithms leveraging them can enjoy an even greater speedups, which is very hard to match via a language such as C or Rust.&lt;/p&gt;
&lt;h2 id=&#34;regular-dapp-builder&#34;&gt;Regular Dapp Builder&lt;/h2&gt;
&lt;p&gt;For experimenting regular dapp logic, you will have a much greater number of choices here: we mentioned JavaScript above, we also have &lt;a href=&#34;https://github.com/nervosnetwork/ckb-mruby&#34;&gt;Ruby&lt;/a&gt; support. Rust will also soon be a viable choice. There is one more language that I particularly want to mention: for some weird unknown reason, &lt;a href=&#34;https://assemblyscript.org/&#34;&gt;AssemblyScript&lt;/a&gt; gets widely used in the blockchain industry. Since we do have WASM integration support now, you can also use AssemblyScript to build smart contracts on CKB. We do want to ensure that your existing knowledge in building smart contracts on other blockchains won&amp;rsquo;t go in vain. Innovation is critical of course, but so is preserving histories.&lt;/p&gt;
&lt;h1 id=&#34;beyond-the-horizon&#34;&gt;Beyond The Horizon&lt;/h1&gt;
&lt;p&gt;The advantage on CKB doesn&amp;rsquo;t just stop here. It gets more exciting than this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There are tons of languages that have a pure C VM based implementation, such as Lua, MicroPython;&lt;/li&gt;
&lt;li&gt;There are also many languages that can be compiled down to C, we will show a real example later;&lt;/li&gt;
&lt;li&gt;LLVM now officially has RISC-V support, there are many languages that target LLVM, such as zig;&lt;/li&gt;
&lt;li&gt;We now do have WASM support, there are also languages that target WebAssembly, such as AssemblyScript;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So if you are the pioneer kind, you are very welcome to port new languages and make them work on CKB. And they don&amp;rsquo;t have stop as experimental languages. Once they become more mature with people using it, there is nothing stopping us from treating them as production ready languages on CKB. Fundamentally, it all depends on if we know enough about the language to know where we can expect quirks. We are experimenting with new languages all day, and here I can show you my latest attempt:&lt;/p&gt;
&lt;h1 id=&#34;zetz&#34;&gt;ZetZ&lt;/h1&gt;
&lt;p&gt;I&amp;rsquo;ve been very fascinated by &lt;a href=&#34;https://github.com/zetzit/zz&#34;&gt;ZetZ&lt;/a&gt; these days. It presents a unique feature set that suits CKB VM perfectly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compiled to C, so we can then use GCC to compile it to RISC-V binaries&lt;/li&gt;
&lt;li&gt;Encourages stack usage without dynamic memory allocation&lt;/li&gt;
&lt;li&gt;Leverages an &lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;SMT solver&lt;/a&gt; to verify code execution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This basically provides an immediate to use language that suits blockchain smart contract extremely well: on the lower level, a C compiler helps you generate code that is both small and efficient; on the higher level, a theorem prover helps you check code logic to make sure they make sense. In addition, this is not some sort of pure hobby project, it is developed together with a real &lt;a href=&#34;https://github.com/devguardio/carrier&#34;&gt;usage&lt;/a&gt; in an IoT system with a lot of cryptographic code involved, much like how we would use it in blockchains.&lt;/p&gt;
&lt;p&gt;Here our old carrot example in ZetZ:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using &amp;lt;ckb_syscalls.h&amp;gt; as ckb
using &amp;lt;string.h&amp;gt;::{memcmp};

fn load_data(u64 index, u8 mut * buffer) -&amp;gt; int
   where len(buffer) &amp;gt;= 6 {
  u64 mut l = 6;
  int ret = as&amp;lt;int&amp;gt;ckb::ckb_load_cell_data(buffer, &amp;amp;l, 0, index, 2);
  return ret;
}

export fn main () -&amp;gt; int {
  u64 index = 0;
  while true {
    u8 buffer[6];
    int ret = load_data(index, buffer);
    if ret == 1 {
      break;
    }
    if memcmp(buffer, &amp;quot;carrot&amp;quot;, 6) == 0 {
      return -1;
    }
    index++;
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You don&amp;rsquo;t have to be able to understand anything here. However, if you have a little experience with C, that &lt;code&gt;where len(buffer) &amp;gt;= 6&lt;/code&gt; will immediately catch your attention: ZetZ uses theorem prover to ensure all calling to the &lt;code&gt;load_data&lt;/code&gt; function shall provide a buffer that is at least 6 bytes long. If we change the buffer size in the main function to something less than 6, an error will immediately be generated when we build the source code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ zz build
 [ERROR] unproven callsite assert for infix expression
  --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:15:25
   |
15 |     int ret = load_data(index, buffer);␊
   |                         ^------------^
   |
   = in this callsite

 --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:5:22
  |
5 |    where len(buffer) &amp;gt;= 6 {␊
  |                      ^^
  |
  = function call requires these conditions

 --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:4:1
  |
4 | fn load_data(u64 index, u8 mut * buffer) -&amp;gt; int␊
  | ...
9 | }␊
  | ^
  |
  = for this function

 --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:5:22
  |
5 |    where len(buffer) &amp;gt;= 6 {␊
  |                      ^^
  |
  = for infix expression |0| = false

 --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:5:14
  |
5 |    where len(buffer) &amp;gt;= 6 {␊
  |              ^-----^
  |
  = for literal 3 |0| = 0x3

 --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:5:25
  |
5 |    where len(buffer) &amp;gt;= 6 {␊
  |                         ^
  |
  = for literal 6 |0| = 0x6

  --&amp;gt; /home/ubuntu/code/ckb-zz-demo/src/main.zz:15:25
   |
15 |     int ret = load_data(index, buffer);␊
   |                         ^------------^
   |
   = last callsite
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see here that ZetZ knows that we are passing a buffer of 3 bytes to a function which requires a buffer of at least 6 bytes. The build phase results in an error.&lt;/p&gt;
&lt;p&gt;On the other hand, the final generated code, when cleaned a bit, looks exactly like how we would write this by hand in C:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

static int ckb_zz_demo_main_load_data(uint64_t const index,
                                      uint8_t* const buffer);

#include &amp;lt;string.h&amp;gt;

int __attribute__((visibility(&amp;quot;default&amp;quot;))) ckb_zz_demo_main_main();

#include &amp;lt;ckb_syscalls.h&amp;gt;

static int ckb_zz_demo_main_load_data(uint64_t const index,
                                      uint8_t* const buffer);

int main() {
  uint64_t const index = 0;
  while (true) {
    uint8_t const buffer[6];
    int const ret = ckb_zz_demo_main_load_data(index, buffer);
    if ((ret == 1)) {
      break;
    }
    if ((memcmp(buffer, &amp;quot;carrot&amp;quot;, 6) == 0)) {
      return -1;
    }
    (index++);
  }
  return 0;
}

static int ckb_zz_demo_main_load_data(uint64_t const index,
                                      uint8_t* const buffer) {
  uint64_t l = 6;
  int const ret = (int)(ckb_load_cell_data(buffer, (&amp;amp;l), 0, index, 2));
  return ret;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;No prover checking code is included in the final C code here, it is just how a plain C implementation would look like. We are not paying any runtime cost here.&lt;/p&gt;
&lt;p&gt;This example here only demostrates a small benefit of ZetZ, while the theorem prover in ZetZ can definitely do more sophisticated checking. The language is still in its infancy phase, I don&amp;rsquo;t know how the future would look like, but this is definitely something I&amp;rsquo;d like to keep an eye on.&lt;/p&gt;
&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;
&lt;p&gt;I hope you won&amp;rsquo;t treat me as a ZetZ zealot now. It really is just one example I&amp;rsquo;m playing with now. What I&amp;rsquo;m trying to say here, is that if you have any particular language you love, or discover anything that might be useful for your dapp. There really is nothing that prevents you from porting that to CKB. We really want to put the freedom, back to all the awesome developers out there. And if you have built something that proves to be useful, our &lt;a href=&#34;https://www.nervos.org/grants/&#34;&gt;grant&lt;/a&gt; program is awaiting for your submission.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>What Do We Mean When We Say Account Model?</title>
        <link>https://xuejie.space/2020_03_20_what_do_we_mean_when_we_say_account_model/</link>
        <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_03_20_what_do_we_mean_when_we_say_account_model/</guid>
        <description>&lt;p&gt;It is widely believed in the blockchain world that account model has advantages over UTXO model in terms of usability, and I&amp;rsquo;ve been working on bridging the differences between UTXO model and account model in a &lt;a href=&#34;https://github.com/nervosnetwork/ckb&#34;&gt;blockchain&lt;/a&gt;. There is some &lt;a href=&#34;https://medium.com/nervosnetwork/https-medium-com-nervosnetwork-animagus-part-1-introduction-66fa8ce27ccd-cfb361a7d883&#34;&gt;initial attempt&lt;/a&gt; on the problem. But lately, I start to feel that UTXO model and account model are essentially the same thing, or if we rephrase using buzzwords, UTXO model is just a &lt;strong&gt;software defined&lt;/strong&gt; version of account model. If this puzzles you don&amp;rsquo;t worry, I will explain in more details below.&lt;/p&gt;
&lt;p&gt;To make things easier to understand, in this post I will only use the wording UTXO model. People who know us will know we generalize from the UTXO model into the cell model. The added advantages of cell model do not matter here. I&amp;rsquo;m gonna argue below that any UTXO model that is capable of storing data(such as CKB&amp;rsquo;s cell model, or even plain old Bitcoin&amp;rsquo;s UTXO model when using &lt;code&gt;OP_PUSHDATA&lt;/code&gt;), can be equivalent to the account model when it comes to programming model.&lt;/p&gt;
&lt;h1 id=&#34;what-is-account-model&#34;&gt;What Is Account Model?&lt;/h1&gt;
&lt;p&gt;In an account model based blockchain, transactions only state the action, or function call with parameters. The actual state, is computed and inferred from the blockchain, like the diagram below shows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/account_model_1.svg&#34; alt=&#34;Account Model&#34;&gt;&lt;/p&gt;
&lt;p&gt;Whereas in a UTXO based blockchain, the states are all included in the transaction. You are directly embeding the data you want in transactions. Typically, multiple UTXOs can work together to provide parts of the whole state. When you want to change the data in a part, you include the UTXO for that part as an input in the transaction, and provide a new UTXO containing the updated data. This is shown in the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/utxo_model_1.svg&#34; alt=&#34;UTXO Model&#34;&gt;&lt;/p&gt;
&lt;p&gt;There has been debates on the 2 models for quite some time. One obvious consideration, is that the account model has smaller transaction size, but in exchange, the states have to be computed in the account based blockchain, and worse, transactions for the same account needs to be executed sequentially. On the other hand, UTXO based blockchain only needs to do verification work to make sure submitted data are in correct format, transactions accessing different parts of the same account can also be verified in parallel for the better performance. But a drawback of larger transaction size is usually paid, since transactions will need to contain the actual data.&lt;/p&gt;
&lt;p&gt;But this is not the main point of this post, each solution has its own way of mitigating the challenges. There is a popular belief, that the account model provides superiority over the UTXO model when building dapps. Another way of saying this, is that UTXO based blockchain cannot have dapps using account model. Is this really true? Let&amp;rsquo;s find out here.&lt;/p&gt;
&lt;h1 id=&#34;a-little-transformation&#34;&gt;A Little Transformation&lt;/h1&gt;
&lt;p&gt;We are gonna look at a real ERC20-like token transferring operation here. In an account model blockchain, typically you have a &lt;em&gt;token&lt;/em&gt; account storing the token balances of all users. When someone wants to make a transfer, it just submits a transaction stating &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt; and the &lt;code&gt;balance&lt;/code&gt; to transfer:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/account_model_2.svg&#34; alt=&#34;Account Model Concrete&#34;&gt;&lt;/p&gt;
&lt;p&gt;The blockchain then &lt;strong&gt;executes&lt;/strong&gt; the transaction on chain, and updates the internal state containing the changes.&lt;/p&gt;
&lt;p&gt;How can we represent this in a UTXO based blockchain? One observation, is that typical account based blockchain represents the whole account state via a key-value store. We can embrace the same abstraction here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A pre-defined number of UTXOs are created for each account. Actually, you only need to define the number here, the absent of a UTXO could be interpreted as a dummy UTXO;&lt;/li&gt;
&lt;li&gt;Each UTXO stores a part of the whole key space in the key-value store;&lt;/li&gt;
&lt;li&gt;If a transaction needs to update some value, it first locates the UTXO containing the key for that value, includes the corresponding UTXO as transaction input, then provides a new UTXO containing updated data;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An example for a transaction in this style is shown in the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/utxo_model_2.svg&#34; alt=&#34;UTXO Model Concrete&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here the whole account state contains 4 UTXOs, but since only 2 UTXOs need to be updated, the transaction only contains those 2 UTXOs.&lt;/p&gt;
&lt;p&gt;You might noticed that this looks a lot like the &lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree&#34;&gt;B-tree&lt;/a&gt; data structure used in database and file systems. In a B-tree structure, you want to minimize the actual pages that are modified, which is exactly the same point for our UTXO based design: you want to include and modify as few UTXOs as possible in the transaction. This means while what we have is a naive design, you could leverage the rich research ideas accumulated in the B-tree area to build better designs that provides better results.&lt;/p&gt;
&lt;p&gt;If we think about the scheme here, it actually exploits no application specific knowledge, the only assumption is that account model uses a key-value store, which is already the case today. This means we can build a generator of account model on top of the UTXO model:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The generator answers read requests from dapp developers, it queries current UTXOs of the account, and extracts values for provided keys;&lt;/li&gt;
&lt;li&gt;The generator also accepts account model style function calls, it runs the function with current UTXOs, and generates a transaction contains updated UTXOs, relays the transaction to the blockchain for acceptance. For flexibility, we can introduction account model style virtual machines here, such as EVM, Move, etc;&lt;/li&gt;
&lt;li&gt;An on-chain smart contract can then run the same code run by the generator, to validate the correct data has been generated. If a VM such as EVM or Move has been used, we can port the same VM to the on-chain smart contract, and execute the same thing here.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course this new generator parts needs to be built to make UTXO based blockchain behave like account based blockchain. My point here, is that this is a total feasible route, meaning the design of a UTXO based blockchain, never really gets in the way of building account model style dapps.&lt;/p&gt;
&lt;h1 id=&#34;duplicating-logic-in-generator-is-not-a-bad-idea&#34;&gt;Duplicating Logic In Generator Is Not A Bad Idea&lt;/h1&gt;
&lt;p&gt;One constant criticism of this path, which was also my previous concern, is that we are duplicating logic in both the off-chain generator part, and in the on-chain smart contract. But lately, I&amp;rsquo;ve been questioning this point: is this really a concern? One widely holded principle in the blockchain world is &amp;ldquo;don&amp;rsquo;t trust, verify&amp;rdquo;. The smart contract contained in one transaction will not just run on a single node, it will run on every single blockchain node out there. We already have &lt;code&gt;N&lt;/code&gt; executions of the same smart contract, does it really matter if the generator executes one more time, and make it &lt;code&gt;N + 1&lt;/code&gt;? We all know when &lt;code&gt;N + 1&lt;/code&gt; in this case has no difference from &lt;code&gt;N&lt;/code&gt;. I would personally consider the generator part just one more light client node that validates the smart contract one more time. This won&amp;rsquo;t cause us any problems in the established blockchain design.&lt;/p&gt;
&lt;p&gt;If you are still paranoid by this, there is actually one more view to the story: the above design is based on no assumptions other than a key-value store based account model. It&amp;rsquo;s very likely that when we are talking specific dapps, there are properties we can exploit, so the on-chain smart contract does not have to run exactly the same code as the off-chain generator. For example, in an ERC20 token example, there are really only 2 rules that need to be verified on chain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transactions have valid signature;&lt;/li&gt;
&lt;li&gt;Normal transactions cannot issue more tokens than currently issued.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once those 2 rules are satisfied, the rest of the ERC20 related code can safely run off-chain. Meaning you don&amp;rsquo;t have to re-run the same code on-chain again.&lt;/p&gt;
&lt;p&gt;But this is just an optimization for a specific dapp, and I would even question if the optimization is necessary. To me, the previous more generic solution already works quite well.&lt;/p&gt;
&lt;h1 id=&#34;software-defined-world&#34;&gt;Software Defined World&lt;/h1&gt;
&lt;p&gt;There is of course the problem that a generator part described above needs to be developed. But if we look outside of the blockchain world, and look at the general software industry, we can notice an unstoppable trend:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPUs are moving from &lt;a href=&#34;https://en.wikipedia.org/wiki/Complex_instruction_set_computer&#34;&gt;CISC&lt;/a&gt; design to &lt;a href=&#34;https://en.wikipedia.org/wiki/Reduced_instruction_set_computer&#34;&gt;RISC&lt;/a&gt; design, software based compilers are used to fill in the missing part in RISC.&lt;/li&gt;
&lt;li&gt;Highly specialized hardware based switches are being eaten by ordinary computers leveraging &lt;a href=&#34;https://github.com/snabbco/snabb&#34;&gt;sophisticated software&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Traditional network attached storage or storage area network have been replaced by commodity cloud employing &lt;a href=&#34;https://www.redhat.com/en/topics/data-storage/software-defined-storage&#34;&gt;software defined storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Even in cellular towers, &lt;a href=&#34;https://venturebeat.com/2019/06/17/ericsson-updates-5g-cell-tower-software-to-improve-speed-and-coverage/&#34;&gt;more software&lt;/a&gt; has been deployed to provide better performance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Have you noticed a pattern? We are seeing a world where complex, sophisticated hardware has been rapidly replaced with simple hardware. Highly specialized software has been used more and more to complement the features which used to be in hardware. At Nervos Network, we believe blockchains are more like hardware than software, and if we look at the UTXO model vs account model debate, we can see similar conflicts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An account based blockchain puts more logic in the blockchain(read: hardware) part;&lt;/li&gt;
&lt;li&gt;A UTXO based blockchain puts less logic in the blockchain(read: hardware) part, and leverage software to fill in more features.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If all we see is one or two single case, it might just be an abnormality, but what we see is an industry-wise shift from more hardware, to more software. I&amp;rsquo;m not sure about you, but I would personally want to bet that all the bright minds in our industry are making the right choice here :P&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 9: Cycle Reductions in Duktape Script</title>
        <link>https://xuejie.space/2020_03_19_cycle_reduction_in_duktape/</link>
        <pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_03_19_cycle_reduction_in_duktape/</guid>
        <description>&lt;p&gt;As shown earlier, plain JavaScript can be used to build CKB scripts. But if you have tried this route before, one problem you would notice, is that JavaScript based scripts tend to consume much more cycles than a native version. While this is less of an issue in experimenting, it is very real in production environment: more cycles can naturally be reflected in more transaction fees. It&amp;rsquo;s obvious that the following solutions can be used to tackle this problem:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Rewrite a JavaScript in a native compiled language, such as C or Rust;&lt;/li&gt;
&lt;li&gt;Use better algorithms that require less cycles;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this post, we would take a different path, and take a look at JavaScript scripts alone. Even though JavaScript can consume more cycles, it still allows fast iteraction, which might be critical in certain use cases. So the question I want to ask here is: if we decide to use JavaScript to build our CKB scripts, and we have already improved the algorithms and implementations to an optimal state, are there any other steps we can take to further optimize cycle reductions? Here we shall see some attempts at the problem.&lt;/p&gt;
&lt;h1 id=&#34;script-to-use&#34;&gt;Script To Use&lt;/h1&gt;
&lt;p&gt;We will build a simple script here that reads and prints current script args. To build the JavaScript script, we will first need the &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape-template&#34;&gt;duktape template&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ export TOP=$(pwd)
$ git clone https://github.com/xxuejie/ckb-duktape-template
$ cd ckb-duktape-template
$ git checkout 1a3536ae1dc14abe1e91461ab356e8967cde8d7b
$ npm i
$ cat &amp;lt;&amp;lt; EOF &amp;gt; src/index.js
import { Script } from &amp;quot;../schema/blockchain.js&amp;quot;

function bytesToHex(b) {
  return &amp;quot;0x&amp;quot; + Array.prototype.map.call(
    new Uint8Array(b),
    function(x) {
      return (&#39;00&#39; + x.toString(16)).slice(-2)
    }
  ).join(&#39;&#39;)
}

const script = new Script(CKB.load_script(0))
const args = script.getArgs().raw()
CKB.debug(bytesToHex(args))
EOF
$ npm run build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note this example also levearges the rebuilt &lt;a href=&#34;https://github.com/xxuejie/moleculec-es&#34;&gt;Molecule JavaScript plugin&lt;/a&gt;. Compared to the previous one, it provides a better API, while at the same time saving huge code size and runtime cycles.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s get a baseline number first:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ git clone --recursive https://github.com/xxuejie/ckb-duktape
$ cd ckb-duktape
$ git checkout d6241938247b402ec56c7af218acfc9049ac753d
$ docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@0d31cad7a539:~# cd /code
root@0d31cad7a539:/code# make
root@0d31cad7a539:/code# exit
exit
$ cd $TOP
$ git clone https://github.com/xxuejie/ckb-standalone-debugger
$ cd ckb-standalone-debugger/bins
$ git checkout 3c503b95962e29057b248aeed4f639180c132fff
$ cargo build --release
$ cd $TOP
$ cat &amp;lt;&amp;lt; EOF &amp;gt; runner.rb
#!/usr/bin/env ruby

require &amp;quot;rbnacl&amp;quot;

def bin_to_hex(bin)
  &amp;quot;0x#{bin.unpack1(&#39;H*&#39;)}&amp;quot;
end

def blake2b(data)
  RbNaCl::Hash::Blake2b.digest(data,
                               personal: &amp;quot;ckb-default-hash&amp;quot;,
                               digest_size: 32)
end

if ARGV.length != 2 &amp;amp;&amp;amp; ARGV.length != 3
  STDERR.puts &amp;quot;Usage: runner.rb &amp;lt;duktape file&amp;gt; &amp;lt;script file&amp;gt; &amp;lt;optional dump file&amp;gt;&amp;quot;
  exit 1
end

duktape_binary = File.read(ARGV[0])
duktape_hash = blake2b(duktape_binary)
script_binary = File.read(ARGV[1])

tx = DATA.read.sub(&amp;quot;@DUKTAPE_CODE&amp;quot;, bin_to_hex(duktape_binary))
       .sub(&amp;quot;@DUKTAPE_HASH&amp;quot;, bin_to_hex(duktape_hash))
       .sub(&amp;quot;@SCRIPT_CODE&amp;quot;, bin_to_hex(script_binary))

File.write(&amp;quot;tx.json&amp;quot;, tx)
commandline = &amp;quot;ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input&amp;quot;
if ARGV.length == 3
  commandline += &amp;quot; -d #{ARGV[2]}&amp;quot;
end
STDERR.puts &amp;quot;Executing: #{commandline}&amp;quot;
exec(commandline)

__END__
{
  &amp;quot;mock_info&amp;quot;: {
    &amp;quot;inputs&amp;quot;: [
      {
        &amp;quot;input&amp;quot;: {
          &amp;quot;previous_output&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
          },
          &amp;quot;since&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x4b9f96b00&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;@DUKTAPE_HASH&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;0x&amp;quot;
      }
    ],
    &amp;quot;cell_deps&amp;quot;: [
      {
        &amp;quot;cell_dep&amp;quot;: {
          &amp;quot;out_point&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
          },
          &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x702198d000&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;@SCRIPT_CODE&amp;quot;
      },
      {
        &amp;quot;cell_dep&amp;quot;: {
          &amp;quot;out_point&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x1&amp;quot;
          },
          &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x702198d000&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;@DUKTAPE_CODE&amp;quot;
      }
    ],
    &amp;quot;header_deps&amp;quot;: [
      {
        &amp;quot;compact_target&amp;quot;: &amp;quot;0x1a1e4c2f&amp;quot;,
        &amp;quot;hash&amp;quot;: &amp;quot;0x51d199c4060f703344eab3c9b8794e6c60195ae9093986c35dba7c3486224409&amp;quot;,
        &amp;quot;number&amp;quot;: &amp;quot;0xd8fc4&amp;quot;,
        &amp;quot;parent_hash&amp;quot;: &amp;quot;0xc02e01eb57b205c6618c9870667ed90e13adb7e9a7ae00e7a780067a6bfa6a7b&amp;quot;,
        &amp;quot;nonce&amp;quot;: &amp;quot;0xca8c7caa8100003400231b4f9d6e0300&amp;quot;,
        &amp;quot;timestamp&amp;quot;: &amp;quot;0x17061eab69e&amp;quot;,
        &amp;quot;transactions_root&amp;quot;: &amp;quot;0xffb0863f4ae1f3026ba99b2458de2fa69881f7508599e2ff1ee51a54c88b5f88&amp;quot;,
        &amp;quot;proposals_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
        &amp;quot;uncles_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;0x0&amp;quot;,
        &amp;quot;epoch&amp;quot;: &amp;quot;0x53f00fa000232&amp;quot;,
        &amp;quot;dao&amp;quot;: &amp;quot;0x4bfe53a5a9bb9a30c88898b9dfe22300a58f2bafed47680000d3b9f5b6630107&amp;quot;
      }
    ]
  },
  &amp;quot;tx&amp;quot;: {
    &amp;quot;version&amp;quot;: &amp;quot;0x0&amp;quot;,
    &amp;quot;cell_deps&amp;quot;: [
      {
        &amp;quot;out_point&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
      },
      {
        &amp;quot;out_point&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x1&amp;quot;
        },
        &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
      }
    ],
    &amp;quot;header_deps&amp;quot;: [
      &amp;quot;0x51d199c4060f703344eab3c9b8794e6c60195ae9093986c35dba7c3486224409&amp;quot;
    ],
    &amp;quot;inputs&amp;quot;: [
      {
        &amp;quot;previous_output&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;since&amp;quot;: &amp;quot;0x0&amp;quot;
      }
    ],
    &amp;quot;outputs&amp;quot;: [
      {
        &amp;quot;capacity&amp;quot;: &amp;quot;0x0&amp;quot;,
        &amp;quot;lock&amp;quot;: {
          &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
          &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
          &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
        },
        &amp;quot;type&amp;quot;: null
      }
    ],
    &amp;quot;witnesses&amp;quot;: [
      &amp;quot;0x210000000c0000001d0000000d0000006920616d20612073656372657400000000&amp;quot;
    ],
    &amp;quot;outputs_data&amp;quot;: [
      &amp;quot;0x&amp;quot;
    ]
  }
}
EOF
$ chmod +x runner.rb
$ RUST_LOG=debug ./runner.rb ckb-duktape/build/load0 ckb-duktape-template/build/duktape.js
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0xcf13fa84ff3a615dd496e9ad8647af01078b11ba1c2757889f0a95e2520fdeb9) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 20198757
Transfer cycles: 67328, running cycles: 20131429
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;About 20 million cycles are needed for this simple script. As a comparison, we can also implement similar function in pure C:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ cat &amp;lt;&amp;lt; EOF &amp;gt; c.c
#include &amp;quot;blockchain.h&amp;quot;
#include &amp;quot;ckb_syscalls.h&amp;quot;

#define MAXIMUM_ARG_SIZE 4096
#define SCRIPT_SIZE 32768

#define ERROR_ARGUMENTS_LEN -1
#define ERROR_ENCODING -2
#define ERROR_SYSCALL -3
#define ERROR_SCRIPT_TOO_LONG -21
#define ERROR_OVERFLOWING -51
#define ERROR_AMOUNT -52

int main() {
  unsigned char script[SCRIPT_SIZE];
  uint64_t len = SCRIPT_SIZE;
  int ret = ckb_load_script(script, &amp;amp;len, 0);
  if (ret != CKB_SUCCESS) {
    return ERROR_SYSCALL;
  }
  if (len &amp;gt; SCRIPT_SIZE) {
    return ERROR_SCRIPT_TOO_LONG;
  }
  mol_seg_t script_seg;
  script_seg.ptr = (uint8_t *)script;
  script_seg.size = len;

  if (MolReader_Script_verify(&amp;amp;script_seg, false) != MOL_OK) {
    return ERROR_ENCODING;
  }

  mol_seg_t args_seg = MolReader_Script_get_args(&amp;amp;script_seg);
  mol_seg_t args_bytes_seg = MolReader_Bytes_raw_bytes(&amp;amp;args_seg);
  if (args_bytes_seg.size &amp;gt; MAXIMUM_ARG_SIZE) {
    return ERROR_ARGUMENTS_LEN;
  }

  static const char HEXCHARS[] = &amp;quot;0123456789abcdef&amp;quot;;
  char hex[MAXIMUM_ARG_SIZE * 2 + 1];
  for (size_t i = 0; i &amp;lt; args_bytes_seg.size; i++) {
    hex[i * 2] = HEXCHARS[args_bytes_seg.ptr[i] &amp;gt;&amp;gt; 4];
    hex[i * 2 + 1] = HEXCHARS[args_bytes_seg.ptr[i] &amp;amp; 0xF];
  }
  hex[args_bytes_seg.size * 2] = &#39;\0&#39;;
  ckb_debug(hex);

  return CKB_SUCCESS;
}
EOF
$ docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@57b79063c965:/# cd /code
root@57b79063c965:/code# riscv64-unknown-elf-gcc -O3 -I ckb-duktape/deps/ckb-c-stdlib -I ckb-duktape/deps/molecule c.c -o c -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
root@57b79063c965:/code# exit
exit
$ RUST_LOG=debug ./runner.rb c ckb-duktape-template/build/duktape.js
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x9f637b251b36de8e6c8b48a1db2f2dcbb0e7b667de1d3ec02c589a7b680842e1) DEBUG OUTPUT: 32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 5456
Transfer cycles: 878, running cycles: 4578
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As we shall see here, a similar C script takes only 4578 cycles, which is much less than the JavaScript scripts. Even though our JavaScript script might need consume so less cycles, we can still significantly reduce the cycle consumptions.&lt;/p&gt;
&lt;h1 id=&#34;step-1-skip-initialization&#34;&gt;Step 1: Skip Initialization&lt;/h1&gt;
&lt;p&gt;Those who are familiar with dynamic languages, would realize that all dynamic language implementations will need an initialization phase to create and properly setup the VM, this could take significant work, costing a lot of cycles. Our first idea comes from this: what if we can save the already initialized state, and reuse that state in later VM executions? The whole state of a CKB VM instance, is 33 registers(32 general purpose registers + PC register) and the memory states. If we can dump those into a separate binary, and recreate the same VM state later, we won&amp;rsquo;t need to do the whole initialization step again and again.&lt;/p&gt;
&lt;p&gt;ckb-standalone-debugger actually provides such a dump feature. It adds a new syscall to the VM instance created by the debugger(notice this syscall is useless in production, and will probably never make it into production). When the syscall gets executed, the debugger instance would serialize all VM states, including all registers and memories into a custom-built executable. Later if we instantiate a new VM instance with this generated executable, it will restore all VM states, and the VM will continue to run as if it just returns from the syscall. This way we can do the necessary initialization steps offline via the debugger, then only deploy the generated executable to CKB, all later executions on the executable, can skip the costly initialization part, hence saving a huge amount of cycles.&lt;/p&gt;
&lt;p&gt;I have already prepared a duktape &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape/blob/d6241938247b402ec56c7af218acfc9049ac753d/c/dump_load0.c&#34;&gt;instance&lt;/a&gt; which performs the setup, then execute the dump syscall, we can now give this a test:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ RUST_LOG=debug ./runner.rb ckb-duktape/build/dump_load0 ckb-duktape-template/build/duktape.js dump0.bin
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input -d dump0.bin
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0xb5656359cbcd52cfa68e163cdd217657f0cfc533c909d13a1fdd8032f6b4f1f0) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 20199104
Transfer cycles: 67352, running cycles: 20131752

$ RUST_LOG=debug ./runner.rb dump0.bin ckb-duktape-template/build/duktape.js
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x51959c6288a1cfba0d7f7dc8c5a90cf9a84bf5b58f1d5ed3b355497d119fba16) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 16249542
Transfer cycles: 96998, running cycles: 16152544
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first command here executes the script as normals, but internally it &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape/blob/d6241938247b402ec56c7af218acfc9049ac753d/c/dump_load0.c#L14&#34;&gt;calls&lt;/a&gt; the dump syscall, resultling in a dumping of the VM state then into &lt;code&gt;dump0.bin&lt;/code&gt; executable file. Later when we run CKB VM on &lt;code&gt;dump0.bin&lt;/code&gt; directly, we can notice it performs the same action as the above duktape binary, but saves us close to 4 million cycles.&lt;/p&gt;
&lt;h1 id=&#34;step-2-bytecode-over-source&#34;&gt;Step 2: Bytecode Over Source&lt;/h1&gt;
&lt;p&gt;Previously, we&amp;rsquo;ve been running duktape on CKB VM directly against JavaScript source, this means at runtime, duktape would first need to parse the JavaScript source code, then execute it. The parsing time exists in every single invocation of the same JavaScript file, which could also be a huge waste of cycles. Luckily, duktape provides a &lt;a href=&#34;https://github.com/svaarala/duktape/blob/master/doc/bytecode.rst&#34;&gt;bytecode&lt;/a&gt; format: we can parse the JavaScript source to duktape bytecode format, and only loads and runs the bytecode at runtime. Let&amp;rsquo;s try this now:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ ckb-duktape/build/dump_bytecode ckb-duktape-template/build/duktape.js script.bin
$ RUST_LOG=debug ./runner.rb ckb-duktape/build/dump_load0 script.bin dump0.bin
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input -d dump0.bin
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0xb5656359cbcd52cfa68e163cdd217657f0cfc533c909d13a1fdd8032f6b4f1f0) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 9239414
Transfer cycles: 67352, running cycles: 9172062

$ RUST_LOG=debug ./runner.rb dump0.bin script.bin
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x51959c6288a1cfba0d7f7dc8c5a90cf9a84bf5b58f1d5ed3b355497d119fba16) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 5289852
Transfer cycles: 96998, running cycles: 5192854
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape/blob/d6241938247b402ec56c7af218acfc9049ac753d/c/dump_load0.c#L26-L37&#34;&gt;dump_load0&lt;/a&gt; binary actually supports both duktape bytecode and JavaScript source. It does a runtime check to see if the loaded data here is duktape bytecode or JavaScript source. Here we can see that by combining the previous 2 solutions, we can already shrink the cycle consumption from ~ 20 million to ~ 5 million.&lt;/p&gt;
&lt;p&gt;Note that duktape bytecode does come with tradeoffs. It never ensures version compatibility, so different versions of duktape, or even different builds of the same duktape version could use different bytecode format. In a normal environment, this could be a problem, but since here we also ship duktape binary as a smart contract, we can lock the version of duktape binary we are using, ensuring the bytecode always works. Another drawback, and a big surprise to many, is that the bytecode file is in fact usually larger than the original JavaScript source file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ ls -l script.bin
-rw-rw-r-- 1 ubuntu 7810 Mar 19 05:28 script.bin
$ ls -l ckb-duktape-template/build/duktape.js
-rw-rw-r-- 1 ubuntu 3551 Mar 19 04:46 ckb-duktape-template/build/duktape.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In our example, while the original minimize JavaScript file is about 3.5K, the generated bytecode file is closed to 8K. This brings a tradeoff depending on your use case: do you want smaller file, or less cycle consumption?&lt;/p&gt;
&lt;h1 id=&#34;step-3-skip-cleanup-work&#34;&gt;Step 3: Skip Cleanup Work&lt;/h1&gt;
&lt;p&gt;CKB VM works slightly different from other environment: it provides you with a fixed 4MB memory segment, and the whole segment will just be thrown away once the code finishes execution. This brings an interesting insight: in a normal environment, you definitely want to cleanup the resource you use before exiting, but in CKB VM environment, this is not necessary, since the whole memory segment will be destroyed all together. As long as you signal the correct response, cleanup steps are actually just a waste of cycles in CKB VM. Given this consideration, I&amp;rsquo;ve provided &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape/blob/d6241938247b402ec56c7af218acfc9049ac753d/c/dump_load0_nocleanup.c&#34;&gt;dump_load0_nocleanup&lt;/a&gt; variation, which &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape/blob/d6241938247b402ec56c7af218acfc9049ac753d/c/dump_load0_nocleanup.c#L48-L49&#34;&gt;does not perform&lt;/a&gt; any cleanup work after running the script. Now it is the time to try this final version:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ RUST_LOG=debug ./runner.rb ckb-duktape/build/dump_load0_nocleanup script.bin dump0.bin
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input -d dump0.bin
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x06034ffb00fec553882c6a9c7614333a728828772d3c236a7f8fa6af60669538) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 7856033
Transfer cycles: 67348, running cycles: 7788685

$ RUST_LOG=debug ./runner.rb dump0.bin script.bin
Executing: ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type lock -i 0 -e input
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x0e948e69dd75f2d6676048569073afe4ec2b284144bbe33a6216b13171606d18) DEBUG OUTPUT: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8
Run result: Ok(0)
Total cycles consumed: 3903352
Transfer cycles: 96994, running cycles: 3806358
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With all the solutions combined, we managed to reduce the cycle consumption of a JavaScript based CKB smart contract from 20 million to less than 4 million. This is still far from the C version, which takes less than 5000 cycles. But in many cases, a higher level language like JavaScript will provide superiority over plain old C, and the cycle consumption here might already be good enough.&lt;/p&gt;
&lt;h1 id=&#34;future&#34;&gt;Future&lt;/h1&gt;
&lt;p&gt;The above are just 3 simple solutions you can levarage, there are very likely to be more way you can use to reduce cycles. One thing to remember, is that you don&amp;rsquo;t have to cater for rules established in an everyday running program. As long as the script satisfies the verification needs on chain, you can employ any techniques to reduce the cycle consumption.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Let&#39;s Build a Minimal Blockchain 3: What Is A Blockchain?</title>
        <link>https://xuejie.space/2020_03_16_lets_build_a_minimal_blockchain_what_is_a_blockchain/</link>
        <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_03_16_lets_build_a_minimal_blockchain_what_is_a_blockchain/</guid>
        <description>&lt;p&gt;If you have followed through this series, you would find the title quite misleading: I&amp;rsquo;m not gonna build the actual blockchain, I&amp;rsquo;m just dumping random ideas in the design of modern blockchains. Sadly this series is gonna be of contents like this for a while, at least till I have dumped all the ideas in my head, and I have got some time to do the actual coding part.&lt;/p&gt;
&lt;p&gt;Another issue of this series, is that so far it&amp;rsquo;s just full of ideas and no concrete examples. This can be changed easily, in this article we will have real examples to play with. But first let&amp;rsquo;s get to the question: what is a blockchain?&lt;/p&gt;
&lt;p&gt;One obvious way to answer that, is whatever is published by the blockchain authors can be consider a blockchain. You can treat the Bitcoin binary released by Bitcoin developers as the Bitcoin blockchain, you can also think the CKB releases as the CKB blockchain. But is this the real answer? Let&amp;rsquo;s think deeper: what is the part that uniquely defines a blockchain? Foundamentally, what is the part that uniquely defines one blockchain, such as CKB, from other blockchains, such as Bitcoin, or Ethereum.&lt;/p&gt;
&lt;p&gt;Personally, I feel the answer here, is the consensus protocol, in other words, the logic used to verify a block. If this part is changed, CKB will not be CKB anymore, Bitcoin will also not be Bitcoin. At the very core part, it really is the block accepting code, that truly defines a blockchain.&lt;/p&gt;
&lt;p&gt;This brings an interesting question: typically, you would see a big monolithic binary as the blockchain release. This suits ordinary users quite well, but for developers who strives to optimize for performance and resource usage everyday, is this the best option? Would it work better if a monolithic blockchain can be decoupled into the core part as well as optional components? This way one can choose to deactivate components that are not needed, or switch to a different implementation of certain component that suits his/her need better. I do want to mention I&amp;rsquo;m not talking about micro-service s**t here, I&amp;rsquo;m merely talking about a plugin-based architecture enabling 2 benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;rsquo;t have to pay the cost for components I don&amp;rsquo;t need&lt;/li&gt;
&lt;li&gt;I can swap to a different component that suits my need better&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To me, this would enable a lot of possibilities in the blockchain world. If this still sounds quite abstract to you, let&amp;rsquo;s take a look at a real example.&lt;/p&gt;
&lt;h1 id=&#34;ckb-boxer&#34;&gt;ckb-boxer&lt;/h1&gt;
&lt;p&gt;Luckily, not all blockchains are a big blob of mess. CKB, for instance, has been designed into individual components that communicate to work together. It&amp;rsquo;s quite easy to split the very core block verification part into a separate project. &lt;a href=&#34;https://github.com/xxuejie/ckb-boxer&#34;&gt;ckb-boxer&lt;/a&gt; is a result of the separation, it contains the very core block verification logic and accompanying storage engine into a separate project, and exposes a very simple stdin/stdout based text protocol, in which you can interact with it. The name comes from the sport boxing. In boxing, the athletes, called boxers, need to control their own body weight to the absolutely needed part, so they can gain the maximum advantage against opponents. ckb-boxer works exactly the same way: it keeps only what the name CKB means, and strip everything else, so you can build whatever tools on top of it, enabling different behaviors. Notice this is never a replacement for the current CKB, for the vast majority of the users, current CKB release is the ideal solution for them, we&amp;rsquo;ve got awesome engineers maintaining the codebase for a bright future. But for a very small group of people who want to push the boundaries of CKB, ckb-boxer can be a handy addition in the toolbox.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s actually one more benefit of ckb-boxer: it packs CKB&amp;rsquo;s storage engine, so it is compatible from the data perspective with the full featured CKB node. One the one hand, this means you can freely copy the data folder from a full features CKB node to ckb-boxer, and vice versa; on another hand, this also means tools that directly read CKB&amp;rsquo;s data folder will also work with ckb-boxer. &lt;a href=&#34;https://github.com/xxuejie/ckb-graphql-server&#34;&gt;ckb-graphql-server&lt;/a&gt; is such an example, you can use ckb-graphql-server directly on top of ckb-boxer without any problems.&lt;/p&gt;
&lt;p&gt;With ckb-boxer in place, let&amp;rsquo;s see a real demo of how one component in a blockchain can be swapped.&lt;/p&gt;
&lt;h1 id=&#34;alternate-syncing-protocol&#34;&gt;Alternate Syncing Protocol&lt;/h1&gt;
&lt;p&gt;One obvious idea, is that we can now switch to a different syncing protocol. Notice this never means the current syncing protocol in CKB is not good, it is just that depending on different deployed environments, an alternative syncing protocol might enable different gains. For example, the current syncing protocol spends a great deal of efforts preventing all kinds of attacks, which makes sense in a decentralized environment. But if you have CKB deployed in an Intranet, you are dealing with nodes that you can have a higher level of trust, do you still need a protocol that deals with all kinds of protocol-level attacks? With a different syncing protocol, it&amp;rsquo;s possible to achieve even better performance.&lt;/p&gt;
&lt;p&gt;Depending on the requirements, a syncing protocol doesn&amp;rsquo;t even have to complicated, here we can design a very simple syncing protocol that works as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A node keeps sending &lt;code&gt;get_block_by_number&lt;/code&gt; requests to a full featured CKB node, fetching latest blocks&lt;/li&gt;
&lt;li&gt;It then sends blocks to ckb-boxer for processing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Different people might have different angles, personally, I would classify this as a syncing protocol as well. Yes it only syncs blocks from another node, it never relays blocks to other nodes, but it fulfills the purpose of downloading all the blocks and create a node one can use.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s now implement this protocol, as we can see below, it just takes a 50-line JS file to implement the protocol:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ export TOP=$(pwd)
$ cat &amp;lt;&amp;lt; EOF &amp;gt; fib.ts
#!/usr/bin/env node

const Blockchain = require(&amp;quot;./blockchain.umd.js&amp;quot;);
const Toolkit = require(&amp;quot;ckb-js-toolkit&amp;quot;);
const { spawn } = require(&amp;quot;child_process&amp;quot;);
const process = require(&amp;quot;process&amp;quot;);
const readline = require(&amp;quot;readline&amp;quot;);

if (process.argv.length !== 5) {
  console.log(`Usage: ${process.argv[1]} &amp;lt;rpc path&amp;gt; &amp;lt;ckb-boxer binary&amp;gt; &amp;lt;start block number&amp;gt;`)
  process.exit(1)
}

const RPC = process.argv[process.argv.length - 3];
const BOXER_PATH = process.argv[process.argv.length - 2];
const START_BLOCK_NUMBER = BigInt(process.argv[process.argv.length - 1]);

function sleep(ms = 0) {
  return new Promise(r =&amp;gt; setTimeout(r, ms));
}

(async () =&amp;gt; {
  const boxer = spawn(BOXER_PATH, [&amp;quot;run&amp;quot;, &amp;quot;-C&amp;quot;, &amp;quot;data&amp;quot;],
                      Object.assign({}, process.env, {
                        RUST_LOG: &amp;quot;debug&amp;quot;
                      }));
  boxer.stdout.on(&amp;quot;data&amp;quot;, data =&amp;gt; {
    console.log(`Boxer STDOUT: ${data}`);
  });
  boxer.stderr.on(&amp;quot;data&amp;quot;, data =&amp;gt; {
    console.log(`Boxer STDERR: ${data}`);
  });

  const rpc = new Toolkit.RPC(RPC);
  const tip_number = BigInt((await rpc.get_tip_header()).number);
  let current_number = START_BLOCK_NUMBER;
  while (current_number &amp;lt;= tip_number) {
    const block = await rpc.get_block_by_number(&amp;quot;0x&amp;quot; + current_number.toString(16));
    const normalizedBlock = Toolkit.normalizers.NormalizeBlock(block);

    const serializedBlock = Blockchain.SerializeBlock(normalizedBlock);
    const serializedBlockHex = new Toolkit.Reader(serializedBlock).serializeJson();

    console.log(`Sending block ${current_number} to ckb-boxer`);
    boxer.stdin.write(&amp;quot;0001NBLK&amp;quot; + serializedBlockHex.substr(2) + &amp;quot;\n&amp;quot;);
    current_number += BigInt(1);
  }

  await sleep(2000);
}) ();
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will need a couple of dependencies to run the protocol here:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ npm install ckb-js-toolkit@0.6.0 rollup@2.0.6
$ cargo install moleculec
$ git clone https://github.com/xxuejie/ckb-boxer
$ cd ckb-boxer
$ cargo build --release
$ cd $TOP
# I&#39;m running the code under Linux, if you use other platforms, you might need
# to tweak the downloaded binaries here
$ curl -LO https://github.com/nervosnetwork/ckb/releases/download/v0.29.0/ckb_v0.29.0_x86_64-unknown-linux-gnu.tar.gz
$ curl -LO https://github.com/xxuejie/moleculec-es/releases/download/0.1.1/moleculec-es_0.1.1_Linux_x86_64.tar.gz
$ curl -LO https://raw.githubusercontent.com/nervosnetwork/ckb/a8dbc63c4e1a1a6c4432979cb48e8df831560ef5/util/types/schemas/blockchain.mol
$ tar xzf ckb_v0.29.0_x86_64-unknown-linux-gnu.tar.gz
$ tar xzf moleculec-es_0.1.1_Linux_x86_64.tar.gz
$ moleculec --language - --schema-file blockchain.mol --format json &amp;gt; blockchain.json
$ ./moleculec-es -inputFile blockchain.json -outputFile blockchain.js
$ npx rollup -f umd -i blockchain.js -o blockchain.umd.js --name Blockchain
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s start a full featured CKB node that syncs mainnet as normal here:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ ./ckb_v0.29.0_x86_64-unknown-linux-gnu/ckb init -C mainnet -c mainnet
$ ./ckb_v0.29.0_x86_64-unknown-linux-gnu/ckb run -C mainnet
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Wait for a while for the full featured CKB to sync some blocks. Now in a different terminal, we can now start our alternative syncing solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ ./ckb_v0.29.0_x86_64-unknown-linux-gnu/ckb init -C alternate -c mainnet
$ chmod +x runner.js
$ ./runner.js http://127.0.0.1:8114 ckb-boxer/target/release/ckb-boxer 1
(omitted some log lines...)
Sending block 129 to ckb-boxer
Sending block 130 to ckb-boxer
Sending block 131 to ckb-boxer
Sending block 132 to ckb-boxer
Sending block 133 to ckb-boxer
Boxer STDOUT: 0000TIPH0000000000000000
2020-03-16 04:34:36.843 +00:00 main INFO ckb-boxer  ckb-boxer is now booted
2020-03-16 04:34:36.847 +00:00 ChainService INFO ckb-chain  block: 1, hash: 0x2567f226c73b04a6cb3ef04b3bb10ab99f37850794cd9569be7de00bac4db875, epoch: 0(1/1743), total_diff: 0x3b1bb3d4c1376a, txs: 1
0000NBLK2567f226c73b04a6cb3ef04b3bb10ab99f37850794cd9569be7de00bac4db875
2020-03-16 04:34:36.848 +00:00 ChainService INFO ckb-chain  block: 2, hash: 0x2af0fc6ec802df6d1da3db2bfdd59159d210645092a3df82125d20b523e0ea83, epoch: 0(2/1743), total_diff: 0x58a98dbf21d31f, txs: 1
0000NBLK2af0fc6ec802df6d1da3db2bfdd59159d210645092a3df82125d20b523e0ea83
2020-03-16 04:34:36.848 +00:00 ChainService INFO ckb-chain  block: 3, hash: 0x247167d03a723f6b8999da09d94b61fadf47f94364d729cb6272edc1f20009b7, epoch: 0(3/1743), total_diff: 0x763767a9826ed4, txs: 1
0000NBLK247167d03a723f6b8999da09d94b61fadf47f94364d729cb6272edc1f20009b7
(more log lines...)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here you can notice that ckb-boxer is already started to accept blocks. Our simple syncing protocol works!&lt;/p&gt;
&lt;p&gt;Of course this is a overly-simplified example, it won&amp;rsquo;t do us any good in a real production setup. However it is enough to state a point: a syncing protocol only has to satisfy the given requirements, it doesn&amp;rsquo;t have to be complex. In some cases, a similar protocol could indeed work: suppose someone sets up a writer that writes all CKB blocks to AWS S3, a minimal runner much like the above can then be used to grab blocks on S3 and feed them to ckb-boxer.&lt;/p&gt;
&lt;h2 id=&#34;generaized-syncing-protocol&#34;&gt;Generaized Syncing Protocol&lt;/h2&gt;
&lt;p&gt;The main point I want to make here, is that I question if a generalized syncing protocols for most, if not all, blockchains can be viable. I could definitely be wrong on this, but the more I think, the more I feel a vast number of blockchains out there, can work with such a generalized syncing protocol:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The syncing protocol consists of 3 main entities: headers, blocks, and compact blocks;&lt;/li&gt;
&lt;li&gt;Headers are synced first among nodes, preliminary checks on the headers can help the node eliminate most invalid blocks. For example PoW check in PoW blockchains can work here, PoS blockchains might have similar mechanisms that the node can levarage(notice I&amp;rsquo;m not super familiar with PoS blockchains on a protocol level, so this might be wrong here);&lt;/li&gt;
&lt;li&gt;Blocks are then downloaded and validated on the best chain per downloaded headers, if block validation fails somewhere, the node might need to go back to previous steps to sync headers on a different fork;&lt;/li&gt;
&lt;li&gt;When the full content for the latest block can be inferred from previous few blocks or other information(such as data synced in a separate protocol), a compact block containing only the necessary information can be sent instead to save the bandwith.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you think about this, I believe you will agree with me, that many blockchains can be abstracted and synced via this single protocol. There will always be outliers of course, but if we have a single syncing protocol that works with enough blockchains, I personally feel that will help us build a better blockchain world. We already started to see cross-chain initiatives, if multiple chains can share more infrastructure, such as syncing protocol, that will greatly reduce operational burden on dapp developers.&lt;/p&gt;
&lt;p&gt;So this is my wish for the future: we first shrink each blockchain to the core part, then a unified syncing protocols can be used to support multiple blockchains at once. And it&amp;rsquo;s not just syncing protocols, there might be more components, such as transaction pools, RPC calls for fetching blockchains, it might result in a better world: even though existing solutions already provide sample syncing protocols that are quite good in many cases, they still require you to run the whole thing, which might still be operational burdens. If a new blockchain can be shrinked to the minimal core blockchain part, a common infrastructure can be used to run many blockchains in parallel without affecting one another, resulting in much less development and operation burdens.&lt;/p&gt;
&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;
&lt;p&gt;I do believe we should go back to the basis: a blockchain should only be the core blockchain logic. Right now there are just too many things that will hinder your eyes, such as building a syncing protocol, building a transaction pool, tuning a multi-threaded infrastructure. The result of all of those, is that a developer might only be able to spend a tiny fraction of the time on the core logic of the blockchain, which IMHO, is not the best way to build a blockchain. We deserve something much better, I yearn for a world where a blockchain developer can focus the entire efforts on making sure the blockchain logic is flawless, instead of wasting efforts on surrounding components that are only essential, but not unique to the developer&amp;rsquo;s own innovated blockchain.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 8: Performant WASM</title>
        <link>https://xuejie.space/2020_03_03_introduction_to_ckb_script_programming_performant_wasm/</link>
        <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_03_03_introduction_to_ckb_script_programming_performant_wasm/</guid>
        <description>&lt;p&gt;In an &lt;a href=&#34;../2019_10_09_introduction_to_ckb_script_programming_wasm_on_ckb/&#34;&gt;earlier post&lt;/a&gt;, I&amp;rsquo;ve shown you that you can have WASM programming running on CKB, with a little caveat that the WASM programs might not be so performant. I also mentioned that there is a potential solution that could solve the problem. And now it&amp;rsquo;s the day! We now have a new &lt;a href=&#34;https://github.com/xxuejie/wavm-aot-generator&#34;&gt;project&lt;/a&gt; that could be used to generate performant WASM programs. Let&amp;rsquo;s see how it works in this post.&lt;/p&gt;
&lt;h1 id=&#34;background&#34;&gt;Background&lt;/h1&gt;
&lt;p&gt;(If you are impatient, you can skip this section and jump directly to Examples)&lt;/p&gt;
&lt;p&gt;In the previous post, we are translating the WebAssembly programs back to C code, then compile it from C code to RISC-V again. But this has many drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s not always possible to preserve all the optimizations done on the code in a C intermediate layer.&lt;/li&gt;
&lt;li&gt;Due to limitations in C, it is not possible to fully customize memory layout for the maximum performance.&lt;/li&gt;
&lt;li&gt;A C layer can be flaky at times and is not always easy to debug.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here we are trying a different solution: &lt;a href=&#34;https://github.com/WAVM/WAVM&#34;&gt;WAVM&lt;/a&gt; is a high performance(&lt;a href=&#34;https://00f.net/2019/10/22/updated-webassembly-benchmark/&#34;&gt;benchmarks&lt;/a&gt; show this is the highest performance WASM implementation so far) translation layer that compiles WASM code directly to native code via LLVM. Since LLVM 9+ has official RISC-V support, we can just retarget WAVM to RISC-V code, it will then be able to translate WASM program directly to RISC-V native code.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s one additional problem: WAVM requires a runtime part to complement the native with surrounding environments. Currently this is included within WAVM with dependency on LLVM, which makes the binary quite huge. One day it suddenly occurs to me that all the information needed to build the runtime, is already included in the original WASM file, so we can just build a separate project, that processes the original WASM file and emits a minimal runtime part in plain C code, then we link it together with generated native code, the result will be a single RISC-V native program that is compiled from WASM code, and can run independently.&lt;/p&gt;
&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;
&lt;p&gt;Here we will use the exact same examples as the previous post: the fibonacci code written in AssemblyScript, and secp256k1 example in pure Rust. We will do a side-by-side comparison on the generated code size, and cycles consumed running in CKB VM. For the sake of completeness, we will also include native versions written in pure C in each example. As we will see below, even if our current WASM solution still has way to go towards the pure C version, it is already quite close and could enable many use cases.&lt;/p&gt;
&lt;p&gt;First let&amp;rsquo;s clone all the needed repos and do necessary preparations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ export TOP=$(pwd)
$ git clone https://github.com/AssemblyScript/assemblyscript.git
$ cd assemblyscript
$ git checkout b433bc425633c3df6a4a30c735c91c78526a9eb7
$ npm install

$ cd $TOP
$ git clone --recursive https://github.com/WebAssembly/wabt
$ cd wabt
$ git checkout bec78eafbc203d81b9a6d1ce81f5a80dd7bf692a
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .

$ cd $TOP
$ git clone https://github.com/xxuejie/WAVM
$ cd WAVM
$ git checkout cb35225feeb4ba1b5a9c73cbbdb07f4cace9b359
$ mkdir build
$ cd build
# Make sure you are using LLVM 9+, you might need to tweak this path depending
# on your environment
$ cmake .. -DLLVM_DIR=/usr/lib/llvm-9/lib/cmake/llvm
$ cmake --build .

$ cd $TOP
$ git clone https://github.com/xxuejie/wavm-aot-generator
$ cd wavm-aot-generator
$ git checkout 8c818747eb19494fc9c5e0289810aa7ad484a22e
$ cargo build --release

$ cd $TOP
$ git clone https://github.com/xxuejie/ckb-standalone-debugger
$ cd ckb-standalone-debugger
$ git checkout 15e8813b8cb886e95e2c81bbee9f26d47a831850
$ cd bins
$ cargo build --release

$ cd $TOP
$ git clone https://github.com/xxuejie/ckb-binary-patcher
$ cd ckb-binary-patcher
$ git checkout 930f0b468a8f426ebb759d9da735ebaa1e2f98ba
$ cd ckb-binary-patcher
$ cargo build --release

$ cd $TOP
$ git clone https://github.com/nervosnetwork/ckb-c-stdlib
$ cd ckb-c-stdlib
$ git checkout 693c58163fe37d6abd326c537447260a846375f0
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;assemblyscript-example&#34;&gt;AssemblyScript Example&lt;/h2&gt;
&lt;p&gt;Here&amp;rsquo;s our old fibonacci example in AssemblyScript, let&amp;rsquo;s compile it to WebAssembly program first:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ cat &amp;lt;&amp;lt; EOF &amp;gt; fib.ts
export function fib(n: i32): i32 {
  var a = 0, b = 1;
    for (let i = 0; i &amp;lt; n; i++) {
        let t = a + b; a = b; b = t;
  }
  return b;
}
EOF
$ assemblyscript/bin/asc fib.ts -b fib.wasm -O3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will compile the WASM code to 2 different versions: C code, and RISC-V native code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ wabt/build/wasm2c fib.wasm -o fib.c
$ WAVM/build/bin/wavm compile --target-triple riscv64 fib.wasm fib_precompiled.wasm
$ wavm-aot-generator/target/release/wavm-aot-generator fib_precompiled.wasm fib_precompiled
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might noticed that instead of generating native RISC-V code, we are using WAVM to generated a &lt;code&gt;precompiled object&lt;/code&gt; formatted file. This is essentially the original WASM file with native code embedded in a custom section, this way we can feed a single file to our generator for convenience reasons.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s attach 2 distinct wrapper files used in 2 WASM solutions, and also provide a native implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ cat &amp;lt;&amp;lt; EOF &amp;gt; fib_wabt_main.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;quot;ckb_syscalls.h&amp;quot;

#include &amp;quot;fib.h&amp;quot;

void (*Z_envZ_abortZ_viiii)(u32, u32, u32, u32);

void env_abort(u32 a, u32 b, u32 c, u32 d) {
  abort();
}

int main() {
  uint32_t value;
  uint64_t len = 4;
  int ret = ckb_load_witness((void*) &amp;amp;value, &amp;amp;len, 0, 0,
                             CKB_SOURCE_GROUP_INPUT);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (len &amp;lt; 4) {
    return -1;
  }

  init();
  u8 result = Z_fibZ_ii(value);

  return result;
}
EOF
$ cat &amp;lt;&amp;lt; EOF &amp;gt; fib_wavm_main.c
#include &amp;quot;fib_precompiled_glue.h&amp;quot;
#include &amp;quot;abi/ckb_vm_wasi_abi.h&amp;quot;
#include &amp;quot;ckb_syscalls.h&amp;quot;

void* wavm_env_abort(void* dummy, int32_t code, int32_t a, int32_t b, int32_t c)
{
  ckb_exit(code);

  return dummy;
}

int main() {
  uint32_t value;
  uint64_t len = 4;
  int ret = ckb_load_witness((void*) &amp;amp;value, &amp;amp;len, 0, 0,
                             CKB_SOURCE_GROUP_INPUT);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (len &amp;lt; 4) {
    return -1;
  }

  wavm_ret_int32_t wavm_ret = wavm_exported_function_fib(NULL, value);
  return wavm_ret.value;
}
EOF
$ cat &amp;lt;&amp;lt; EOF &amp;gt; fib_native_main.c
#include &amp;quot;ckb_syscalls.h&amp;quot;

int32_t fib(int32_t n) {
  int32_t a = 0;
  int32_t b = 1;

  for (int32_t i = 0; i &amp;lt; n; i++) {
    int32_t t = a + b;
    a = b;
    b = t;
  }

  return b;
}

int main() {
  uint32_t value;
  uint64_t len = 4;
  int ret = ckb_load_witness((void*) &amp;amp;value, &amp;amp;len, 0, 0,
                             CKB_SOURCE_GROUP_INPUT);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (len &amp;lt; 4) {
    return -1;
  }

  return fib(value);
}
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might noticed that we altered the wabt wrapper used in previous post, so that all 3 versions here load the input to fibonacci function from witness data, this way we can set the same standard for comparison.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s compile the 3 files first:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@7f24745ca702:/# cd /code
root@7f24745ca702:/code# riscv64-unknown-elf-gcc -O3 -I ckb-c-stdlib -I wavm-aot-generator -I wabt/wasm2c fib_wabt_main.c fib.c wabt/wasm2c/wasm-rt-impl.c -o fib_wabt
root@7f24745ca702:/code# riscv64-unknown-elf-gcc -O3 -I ckb-c-stdlib -I wavm-aot-generator -I wabt/wasm2c fib_wavm_main.c wavm-aot-generator/abi/riscv64_runtime.S fib_precompiled.o -o fib_wavm -Wl,-T wavm-aot-generator/abi/riscv64.lds
root@7f24745ca702:/code# riscv64-unknown-elf-gcc -O3 -I ckb-c-stdlib -I wavm-aot-generator -I wabt/wasm2c fib_native_main.c -o fib_native
root@7f24745ca702:/code# exit
exit
$ ckb-binary-patcher/target/release/ckb-binary-patcher -i fib_wavm -o fib_wavm_patched
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Due to a &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm/issues/92&#34;&gt;VM bug&lt;/a&gt;, a &lt;a href=&#34;https://github.com/xxuejie/ckb-binary-patcher&#34;&gt;patcher&lt;/a&gt; utility has been provided to workaround RISC-V code that would generate the bug. Even though we only observed LLVM affected by this bug(GCC has optimizations that would generate different code), it still recommended to run the patcher against any script that you would want to run on CKB.&lt;/p&gt;
&lt;p&gt;We also prepare a runner to run the scripts:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ cat &amp;lt;&amp;lt; EOF &amp;gt; runner.rb
#!/usr/bin/env ruby

require &amp;quot;rbnacl&amp;quot;

def bin_to_hex(bin)
  &amp;quot;0x#{bin.unpack1(&#39;H*&#39;)}&amp;quot;
end

def blake2b(data)
  RbNaCl::Hash::Blake2b.digest(data,
                               personal: &amp;quot;ckb-default-hash&amp;quot;,
                               digest_size: 32)
end

if ARGV.length != 2
  STDERR.puts &amp;quot;Usage: runner.rb &amp;lt;script file&amp;gt; &amp;lt;witness args&amp;gt;&amp;quot;
  exit 1
end

script_binary = File.read(ARGV[0])
script_hash = blake2b(script_binary)

tx = DATA.read.sub(&amp;quot;@FIB_CODE&amp;quot;, bin_to_hex(script_binary))
       .sub(&amp;quot;@FIB_HASH&amp;quot;, bin_to_hex(script_hash))
       .sub(&amp;quot;@FIB_ARG&amp;quot;, ARGV[1])

File.write(&amp;quot;tx.json&amp;quot;, tx)
commandline = &amp;quot;ckb-standalone-debugger/bins/target/release/ckb-debugger --tx-file tx.json --script-group-type type -i 0 -e input&amp;quot;
STDERR.puts &amp;quot;Executing: #{commandline}&amp;quot;
exec(commandline)

__END__
{
  &amp;quot;mock_info&amp;quot;: {
    &amp;quot;inputs&amp;quot;: [
      {
        &amp;quot;input&amp;quot;: {
          &amp;quot;previous_output&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
          },
          &amp;quot;since&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x4b9f96b00&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;@FIB_HASH&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          }
        },
        &amp;quot;data&amp;quot;: &amp;quot;0x&amp;quot;
      }
    ],
    &amp;quot;cell_deps&amp;quot;: [
      {
        &amp;quot;cell_dep&amp;quot;: {
          &amp;quot;out_point&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
          },
          &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x702198d000&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;@FIB_CODE&amp;quot;
      }
    ],
    &amp;quot;header_deps&amp;quot;: []
  },
  &amp;quot;tx&amp;quot;: {
    &amp;quot;version&amp;quot;: &amp;quot;0x0&amp;quot;,
    &amp;quot;cell_deps&amp;quot;: [
      {
        &amp;quot;out_point&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
      }
    ],
    &amp;quot;header_deps&amp;quot;: [
    ],
    &amp;quot;inputs&amp;quot;: [
      {
        &amp;quot;previous_output&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;since&amp;quot;: &amp;quot;0x0&amp;quot;
      }
    ],
    &amp;quot;outputs&amp;quot;: [
      {
        &amp;quot;capacity&amp;quot;: &amp;quot;0x0&amp;quot;,
        &amp;quot;lock&amp;quot;: {
          &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
          &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
          &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
        },
        &amp;quot;type&amp;quot;: null
      }
    ],
    &amp;quot;witnesses&amp;quot;: [
      &amp;quot;@FIB_ARG&amp;quot;
    ],
    &amp;quot;outputs_data&amp;quot;: [
      &amp;quot;0x&amp;quot;
    ]
  }
}
EOF
$ chmod +x runner.rb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can take a look at the binary size of each version, and run the 3 versions of fibonacci calculation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls -lh fib_wabt fib_wavm_patched fib_native
-rwxr-xr-x 1 root 11K Mar  3 03:27 fib_native*
-rwxr-xr-x 1 root 53K Mar  3 03:26 fib_wabt*
-rwxr-xr-x 1 root 88K Mar  3 03:26 fib_wavm_patched*
$ ./runner.rb fib_wabt 0x10000000
Run result: Ok(61)
Total cycles consumed: 549478
Transfer cycles: 6530, running cycles: 542948
$ ./runner.rb fib_wabt 0x20000000
Run result: Ok(-30)
Total cycles consumed: 549590
Transfer cycles: 6530, running cycles: 543060
$ ./runner.rb fib_wabt 0x00010000
Run result: Ok(29)
Total cycles consumed: 551158
Transfer cycles: 6530, running cycles: 544628
$ ./runner.rb fib_wavm_patched 0x10000000
Run result: Ok(61)
Total cycles consumed: 22402
Transfer cycles: 19696, running cycles: 2706
$ ./runner.rb fib_wavm_patched 0x20000000
Run result: Ok(-30)
Total cycles consumed: 22578
Transfer cycles: 19696, running cycles: 2882
$ ./runner.rb fib_wavm_patched 0x00010000
Run result: Ok(29)
Total cycles consumed: 25042
Transfer cycles: 19696, running cycles: 5346
$ ./runner.rb fib_native 0x10000000
Run result: Ok(61)
Total cycles consumed: 3114
Transfer cycles: 1137, running cycles: 1977
$ ./runner.rb fib_native 0x20000000
Run result: Ok(-30)
Total cycles consumed: 3226
Transfer cycles: 1137, running cycles: 2089
$ ./runner.rb fib_native 0x00010000
Run result: Ok(29)
Total cycles consumed: 4794
Transfer cycles: 1137, running cycles: 3657
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The input value is encoded in witness part as 32-bit unsigned little endian integer, meaning &lt;code&gt;0x10000000&lt;/code&gt;, &lt;code&gt;0x20000000&lt;/code&gt; and &lt;code&gt;0x00010000&lt;/code&gt; here represent &lt;code&gt;16&lt;/code&gt;, &lt;code&gt;32&lt;/code&gt; and &lt;code&gt;256&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Since CKB VM emits 8-bit signed value as output, the calculated value are truncated here. But we do not care so much about the actual fibonacci number(well of course, assuming the 3 versions generate the same result), it&amp;rsquo;s the cycle consumption that we care about here.&lt;/p&gt;
&lt;p&gt;Some insights can thus be deduced from the values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The WAVM version generates the biggest binary size(88K), in fact it also requires loading more bytes into the VM as confirmed by &lt;code&gt;transfer cycles&lt;/code&gt; of 19696(roughly speaking, 1 transfer cycle means 4 bytes loaded into the VM).&lt;/li&gt;
&lt;li&gt;The WABT version and native version both take about 7 cycles to calculate one round of fibonacci iteration, while the WAVM version takes about 11 cycles to calculate one round of iteration&lt;/li&gt;
&lt;li&gt;However, the WAVM version requires only about 2530 cycles to set up the running environment, while the WABT version takes about 542836 cycles to set up.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can see that the WAVM version does take significant less cycles in the initial setup(this is hugely due to the custom memory layout we can leverage in WAVM version), but the WAVM version is slightly slower per fibonacci iteration. This might be due to the fact that LLVM still needs some work to catch up GCC&amp;rsquo;s code generation quality for RISC-V, and it could also be that fibonacci is so simple, that GCC can perfectly pick up the calculation structure from the restored C code. For more complex examples, this might not be the case anymore.&lt;/p&gt;
&lt;p&gt;I personally did do some investigation into the large binary size of WAVM binary, and the problem, is that all the symbols generated in WAVM, are declared public symbols. That means we cannot rely on dead code elimination(DCE) to purge those variables and functions that we are not used, hence a larger binary is generated here. If the original WASM program is generated by Rust or LLVM directly, this won&amp;rsquo;t be a problem since DCE is already performed, but Assemblyscript tends to do less DCE, hence we have a larger binary. Later I might look into WAVM to see if there&amp;rsquo;s a way we can tweak non-exported functions to be module local, if that can be resolved, we should be able to reduce the binary size of WAVM version to the same level like the other solutions.&lt;/p&gt;
&lt;h1 id=&#34;rust-secp256k1-example&#34;&gt;Rust Secp256k1 Example&lt;/h1&gt;
&lt;p&gt;Let&amp;rsquo;s also try the more complicated Rust based secp256k1 example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ git clone https://github.com/nervosnetwork/wasm-secp256k1-test
$ cd wasm-secp256k1-test
$ cargo build --release --target=wasm32-unknown-unknown

$ cd $TOP
$ wabt/bin/wasm2c wasm-secp256k1-test/target/wasm32-unknown-unknown/release/wasm-secp256k1-test.wasm -o secp.c
# There&#39;s a symbol confliction in the latest versioni of gcc with wabt here, this
# can serve as a temporary solutin
$ sed -i s/bcmp/bcmp1/g secp.c
$ WAVM/build/bin/wavm compile --target-triple riscv64 wasm-secp256k1-test/target/wasm32-unknown-unknown/release/wasm-secp256k1-test.wasm secp_precompiled.wasm
$ wavm-aot-generator/target/release/wavm-aot-generator secp_precompiled.wasm secp_precompiled

$ cd $TOP
$ cat &amp;lt;&amp;lt; EOF &amp;gt; secp_wabt_main.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;quot;ckb_syscalls.h&amp;quot;

#include &amp;quot;secp.h&amp;quot;

int main() {
  uint32_t value;
  uint64_t len = 4;
  int ret = ckb_load_witness((void*) &amp;amp;value, &amp;amp;len, 0, 0,
                             CKB_SOURCE_GROUP_INPUT);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (len &amp;lt; 4) {
    return -1;
  }

  init();

  uint32_t times = value &amp;gt;&amp;gt; 8;
  value = value &amp;amp; 0xFF;
  uint8_t result = 0;

  for (int i = 0; i &amp;lt; times; i++) {
    result += Z_runZ_ii(value);
  }

  return result;
}
EOF
$ cat &amp;lt;&amp;lt; EOF &amp;gt; secp_wavm_main.c
#include &amp;quot;secp_precompiled_glue.h&amp;quot;
#include &amp;quot;abi/ckb_vm_wasi_abi.h&amp;quot;
#include &amp;quot;ckb_syscalls.h&amp;quot;

int main() {
  uint32_t value;
  uint64_t len = 4;
  int ret = ckb_load_witness((void*) &amp;amp;value, &amp;amp;len, 0, 0,
                             CKB_SOURCE_GROUP_INPUT);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (len &amp;lt; 4) {
    return -1;
  }

  uint32_t times = value &amp;gt;&amp;gt; 8;
  value = value &amp;amp; 0xFF;
  uint8_t result = 0;

  for (int i = 0; i &amp;lt; times; i++) {
    ckb_debug(&amp;quot;One run!&amp;quot;);
    wavm_ret_int32_t wavm_ret = wavm_exported_function_run(NULL, value);
    result += wavm_ret.value;
  }

  return result;
}
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can compile the code, then compare binary size as well as running cycles:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@a237c0d00b1c:/# cd /code/
root@a237c0d00b1c:/code# riscv64-unknown-elf-gcc -O3 -I ckb-c-stdlib -I wavm-aot-generator -I wabt/wasm2c secp_wabt_main.c secp.c wabt/wasm2c/wasm-rt-impl.c -o secp_wabt
root@a237c0d00b1c:/code# riscv64-unknown-elf-gcc -O3 -I ckb-c-stdlib -I wavm-aot-generator -I wabt/wasm2c secp_wavm_main.c wavm-aot-generator/abi/riscv64_runtime.S secp_precompiled.o -o secp_wavm -Wl,-T wavm-aot-generator/abi/riscv64.lds
root@a237c0d00b1c:/code# exit
exit
$ ckb-binary-patcher/target/release/ckb-binary-patcher -i secp_wavm -o secp_wavm_patched

$ ls -l secp_wabt secp_wavm_patched
-rwxrwxr-x 1 ubuntu 1791744 Mar  3 05:27 secp_wabt*
-rw-rw-r-- 1 ubuntu 1800440 Mar  3 05:29 secp_wavm_patched
$ ./runner.rb secp_wabt 0x01010000
Run result: Ok(0)
Total cycles consumed: 35702943
Transfer cycles: 438060, running cycles: 35264883
$ ./runner.rb secp_wabt 0x01050000
Run result: Ok(0)
Total cycles consumed: 90164183
Transfer cycles: 438060, running cycles: 89726123
$ ./runner.rb secp_wavm_patched 0x01010000
Run result: Ok(0)
Total cycles consumed: 10206568
Transfer cycles: 428764, running cycles: 9777804
$ ./runner.rb secp_wavm_patched 0x01050000
Run result: Ok(0)
Total cycles consumed: 49307936
Transfer cycles: 428764, running cycles: 48879172
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Like the previous case, we can deduce facts from the values as well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The binary sizes generated by the 2 version are only slightly different, WAVM has a slightly larger binary but the bytes needed to load into VM is less.&lt;/li&gt;
&lt;li&gt;In this case, a single secp256k1 verification step takes 9775342 in the WAVM version, while 13615310 cycles are needed in the WABT version. Here we can see doing translations in LLVM directly does provide better performance than a restored C version in WABT.&lt;/li&gt;
&lt;li&gt;For such a complex program, the WAVM version still only takes 2462 cycles to set up, while the WABT version would take an enourmous 21649573 cycles to set up things. Here WAVM version can provide you with big wins.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since the current direct path from Rust to RISC-V does not allow std to be used. We cannot provide a similar native version directly. But just for the curious ones, I still provide a similar function in pure C, and we can measure the cycles taken by the C version compiled directly into RISC-V:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ git clone --recursive https://github.com/nervosnetwork/ckb-vm-bench-scripts
$ cd ckb-vm-bench-scripts
$ git checkout f7ab37c055b1a59bbc4f931c732331642c728c1d
$ cd $TOP
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@ad22c452cb54:/# cd /code/ckb-vm-bench-scripts
root@ad22c452cb54:/code/ckb-vm-bench-scripts# make
(omitted ...)
root@ad22c452cb54:/code/ckb-vm-bench-scripts# exit
exit

$ ./runner.rb ckb-vm-bench-scripts/build/secp256k1_bench 0x01010000
Run result: Ok(0)
Total cycles consumed: 1621594
Transfer cycles: 272630, running cycles: 1348964

$ ./runner.rb ckb-vm-bench-scripts/build/secp256k1_bench 0x01050000
Run result: Ok(0)
Total cycles consumed: 7007598
Transfer cycles: 272630, running cycles: 6734968
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As we can see here, the C native version takes 1346501 cycles per secp256k1 step, and 2463 cycles for initial bookkeeping work. Both the binary sizes and loaded bytes are also smaller.&lt;/p&gt;
&lt;p&gt;I do want to mention here that we are not comparing the same code here, the C version and Rust version use different implementation, and we haven&amp;rsquo;t benched the quality of the 2 implementations directly. That being said, assuming the 2 versions have similar performance, the Rust code, compiled to WASM first, then to RISC-V, is roughly 7x the performance of C code. Considering bound checking logic might also be performed by the Rust version, I would consider this is good performance for many many use cases. There&amp;rsquo;re a whole lot of scripts that can work with this level of performance. What&amp;rsquo;s more, you can always combine the C implemented performance oriented code and Rust implemented logic code together to enjoy the best of both works. And we haven&amp;rsquo;t mentioned the best of this new route. Last but not least, all the involved projects, including Rust, LLVM, WAVM and our generator are active projects with development work going on, soon this gap might become much narrower with progresses made by all the awesome engineers.&lt;/p&gt;
&lt;h1 id=&#34;wasi&#34;&gt;WASI&lt;/h1&gt;
&lt;p&gt;I kept talking about doing Rust on CKB via WASM, my colleague has &lt;a href=&#34;https://justjjy.com/Build-CKB-contract-with-Rust-part-1&#34;&gt;proved&lt;/a&gt; there is a path you can go directly from Rust to RISC-V, what does a WASM intermediate path help here? The problem with a native path, is that Rust&amp;rsquo;s std is not supported in RISC-V port, to make matters worse, libc binding is also absent. This means you will really have to work with core Rust, a minimal and limited set of Rust. Please don&amp;rsquo;t get me wrong, there&amp;rsquo;s nothing bad about going with core Rust, if your use case is enough with Rust&amp;rsquo;s std, you are perfectly good going that path. But I do want to provide a different path, where std is available, so most Rust libraries on crates can be used to build awesome CKB scripts. This is what the WASM path can enable us with WASI.&lt;/p&gt;
&lt;p&gt;If you haven&amp;rsquo;t heard of it, &lt;a href=&#34;https://wasi.dev/&#34;&gt;WASI&lt;/a&gt; is a standard way of interfacing with the running environment for a WebAssembly program. It has &lt;a href=&#34;https://github.com/alexcrichton/cc-rs/issues/447&#34;&gt;been&lt;/a&gt; &lt;a href=&#34;https://github.com/alexcrichton/cc-rs/issues/446&#34;&gt;proved&lt;/a&gt; that Rust&amp;rsquo;s WASM future lies in a new &lt;code&gt;wasm32-wasi&lt;/code&gt; target. By doing the WASM intermediate step, we can build WASI support right into CKB script, enjoying the future-proof &lt;code&gt;wasm32-wasi&lt;/code&gt; target of Rust! In fact, WAVM already provides an &lt;a href=&#34;https://github.com/xxuejie/WAVM/blob/master/Examples/helloworld.wast&#34;&gt;example&lt;/a&gt; that leverages 2 of WASI&amp;rsquo;s API, let&amp;rsquo;s see if we can get that to work on CKB:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ WAVM/build/bin/wavm compile --target-triple riscv64 WAVM/Examples/helloworld.wast helloworld_precompiled.wasm
$ wavm-aot-generator/target/release/wavm-aot-generator helloworld_precompiled.wasm helloworld_precompiled
$ cat &amp;lt;&amp;lt; EOF &amp;gt; helloworld_wavm_main.c
#include &amp;quot;helloworld_precompiled_glue.h&amp;quot;
#include &amp;quot;abi/ckb_vm_wasi_abi.h&amp;quot;

/* main is already generated via wavm-aot-generator */
EOF
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@d28602dba318:/# cd /code
root@d28602dba318:/code# riscv64-unknown-elf-gcc -O3 -I ckb-c-stdlib -I wavm-aot-generator -I wabt/wasm2c helloworld_wavm_main.c wavm-aot-generator/abi/riscv64_runtime.S
helloworld_precompiled.o -o helloworld_wavm -Wl,-T wavm-aot-generator/abi/riscv64.lds
root@d28602dba318:/code# exit
exit
$ ckb-binary-patcher/target/release/ckb-binary-patcher -i helloworld_wavm -o helloworld_wavm_patched
$ RUST_LOG=debug ./runner.rb helloworld_wavm_patched 0x
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x86cfac3b49b8f97f913aa5a09d02ad1e5b1ab5be0be793815e9cb714ba831948) DEBUG OUTPUT: Hello World!

Run result: Ok(0)
Total cycles consumed: 20260
Transfer cycles: 17728, running cycles: 2532
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see the WASI APIs work perfectly! This is because I have already provided the &lt;a href=&#34;https://github.com/xxuejie/wavm-aot-generator/blob/8c818747eb19494fc9c5e0289810aa7ad484a22e/abi/ckb_vm_wasi_abi.h#L51-L91&#34;&gt;implementation&lt;/a&gt; for the 2 APIs used here. While it is incomplete now, I will work to add shims for all WASI APIs. After that we can have Rust programs, with std supported, compiled to &lt;code&gt;wasm32-wasi&lt;/code&gt; target&amp;rsquo;s WASM code, then translated to RISC-V perfectly.&lt;/p&gt;
&lt;p&gt;You see many different blockchains claiming they use WebAssembly everyday, but what they don&amp;rsquo;t tell you, is that WebAssembly is designed to have many flavors, and they just choose to support one of them. In fact &lt;a href=&#34;https://github.com/paritytech/substrate/issues/4043&#34;&gt;many&lt;/a&gt; &lt;a href=&#34;https://github.com/confio/cosmwasm/blob/master/Building.md#requirements&#34;&gt;famous&lt;/a&gt; &lt;a href=&#34;https://github.com/CasperLabs/CasperLabs/tree/dev/execution-engine/cargo-casperlabs#building-the-contract~&#34;&gt;blockchains&lt;/a&gt; &lt;a href=&#34;https://github.com/EOSIO/eosio.cdt/blob/master/tools/external/wabt/src/emscripten-helpers.cc&#34;&gt;only&lt;/a&gt; tend to support a bare minimal WebAssembly program. While most of them let you use Rust, they only use the flaky and could-be-deprecated &lt;code&gt;wasm32-unknown-unknown&lt;/code&gt; target. As a result, they either just disable Rust std directly, claiming you don&amp;rsquo;t need it, or has flaky support that might break going into the future, or they cannot afford to change the code for compatibility reasons. On the other hand, you can enjoy WASI and full feature Rust in CKB. Many ask us why we don&amp;rsquo;t use WebAssembly directly, I would say that we are the first one, or at least among the first ones to get WebAssembly right on blockchains.&lt;/p&gt;
&lt;h1 id=&#34;vice-verca-doesnt-always-work-well&#34;&gt;&amp;ldquo;Vice Verca&amp;rdquo; doesn&amp;rsquo;t always work well&lt;/h1&gt;
&lt;p&gt;One recurring topic we heard, is that if you can translate WASM to RISC-V, you can also translate RISC-V to WASM! In a sense that is true, but there&amp;rsquo;s a difference betweeen one thing that works, and one thing that works well.&lt;/p&gt;
&lt;p&gt;RISC-V, due to its design, is a very simple specification that maps extremely well to modern day CPUs. If you check our VM implementation, you might notice that most RISC-V instructions map directly onto a dozen x86-64 CPU instructions. We are just building a minimal secure layer that works on top of the CPUs in your machines. WASM, on the other hand, is a &lt;a href=&#34;https://webassembly.org/docs/future-features/&#34;&gt;beast&lt;/a&gt; much like JVM, there are tons of features in the spec already, there are also tons of features being added to the spec everyday. Many of the new features don&amp;rsquo;t have direct mappings on CPUs, ranging from lower level instructions such as  &lt;code&gt;memory.grow&lt;/code&gt; or &lt;code&gt;callIndirect&lt;/code&gt;, to higher level features such as garbage collections, or threading. When you pick WebAssembly as your blockchain&amp;rsquo;s engine, you will have to pick a set of features, and decide how/if you want to migrate when new features keep coming out. To complicate this matter, you cannot just change the implementation of some features in your current WebAssembly engine, cuz that might bring incompatible changes.&lt;/p&gt;
&lt;p&gt;When you pick RISC-V as the underlying engine, you don&amp;rsquo;t have such concerns. RISC-V is designed for hardware that never changes. When the spec is fixed, it will be fixed forever, and all compilers have to respect bugs in the spec. And when you are implementing WebAssembly programs on top of RISC-V, you are free to change the implementations of higher constructs in WebAssembly anyway you want. For example, you might discover a new garbage collection algorithm that will help your smart contracts, you can deploy the algorithm by upgrading the a different smart contract, no forks are needed to support this. All of these are extremely hard to being even impossible if you tackle the problem starting from a WebAssembly engine. That is where I believe the true beauty of CKB&amp;rsquo;s unique design lies.&lt;/p&gt;
&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Here&amp;rsquo;s one suggestion: if someone tells you his/her blockchain uses WebAssembly, do yourself a favor, and ask what specific spec his/her WebAssembly engine uses, and how he/she plan to tackle the problem when more features are added to the WebAssembly specification. WebAssembly is an evergrowing specification due to its Web roots, picking one specification and freeze there is never a good strategy for employing WebAssembly in a stack. There&amp;rsquo;s nothing wrong relying on WebAssembly in the blockchain world, but it matters if WebAssembly is used in the correct way. To me, CKB is one example that WebAssembly is used in the correct way with future issues considered. I do believe you will thank yourself years later, if you take the extra effort ensuring your choice of blockchain deploys WebAssembly the correct way.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 7: Advanced Duktape Examples</title>
        <link>https://xuejie.space/2020_02_21_introduction_to_ckb_script_programming_advanced_duktape_examples/</link>
        <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_02_21_introduction_to_ckb_script_programming_advanced_duktape_examples/</guid>
        <description>&lt;p&gt;I&amp;rsquo;ve introduced duktape before, shown how you can run JavaScript code on Nervos CKB. But up to this point, the code I&amp;rsquo;ve shown is all single piece of code with very simple logic. What if we need to parse CKB data structures? What if I need external libraries in my script? In this post we will create a duktape-powered CKB script with the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;External library dependency&lt;/li&gt;
&lt;li&gt;Serialization/Deserialization of CKB data structures&lt;/li&gt;
&lt;li&gt;Hashing&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before continuing on this post, I want to mention that the major work used in this post, is not written by me. The credit really goes to &lt;a href=&#34;https://github.com/Keith-CY&#34;&gt;one&lt;/a&gt; of my colleagues, who spent the effort putting together a very nice &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape-template&#34;&gt;template&lt;/a&gt; we can use here, so we can have a streamlined CKB script development experience via JavaScript &amp;amp; duktape.&lt;/p&gt;
&lt;p&gt;This post is written based on current CKB Lina mainnet version now.&lt;/p&gt;
&lt;h1 id=&#34;scope&#34;&gt;Scope&lt;/h1&gt;
&lt;p&gt;In this post, we will write a simple &lt;a href=&#34;https://en.bitcoin.it/wiki/Hash_Time_Locked_Contracts&#34;&gt;HTLC&lt;/a&gt; script in JavaScript. Let me admit that I&amp;rsquo;m not the world&amp;rsquo;s best teacher, there&amp;rsquo;re many, many people who are better than me in &lt;a href=&#34;https://liquality.io/blog/hash-time-locked-contracts-htlcs-explained/~&#34;&gt;explaining HTLC&lt;/a&gt;. So if you want to know what HTLC is, feel free to check other places first and come back here later.&lt;/p&gt;
&lt;p&gt;Now I will assume you know what HTLC is :P The HTLC script we create here, will be unlocked if either one of the following conditions is met:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A correct secret string, and a valid signature for public key A are provided;&lt;/li&gt;
&lt;li&gt;Certain amount of time is passed, and a valid signature for public key B is provided&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And there are also several points made in the design of our HTLC script:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For simplicity, we will use a trick to do signature verification here: instead of doing signature verification directly in JavaScript, we will rely on a separate cell to provide that a signature of the correct public key is provided. Later in this post we will explain the consequence and consideration regarding signature verifi2ation in JavaScript;&lt;/li&gt;
&lt;li&gt;A hash of the correct secret string will be included in &lt;code&gt;args&lt;/code&gt; part of the CKB HTLC script structure, so when the script runs, it can run a hashing function on the provided secret string, testing if it is correct;&lt;/li&gt;
&lt;li&gt;The amount of time is always set as 100 blocks. To verify 100 blocks has passed, the unlock transaction should include a block header which at least 100 blocks after the cell to unlock is committed on chain.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With the design set in stone, let&amp;rsquo;s jump to the implementation now.&lt;/p&gt;
&lt;h1 id=&#34;getting-our-hands-dirty&#34;&gt;Getting Our Hands Dirty&lt;/h1&gt;
&lt;p&gt;While you are certainly welcome to craft the skeleton on your own, a decent &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape-template&#34;&gt;template&lt;/a&gt; has already been prepared by one of my colleagues to save us the time. In this post, we will start from the already built template here:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ export TOP=$(pwd)
$ git clone https://github.com/xxuejie/ckb-duktape-template htlc-template
$ cd htlc-template
$ npm install
# now you can try building the script first to ensure everything works
$ npm run build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can use your favorite editor to open &lt;code&gt;src/index.js&lt;/code&gt; file in &lt;code&gt;htlc-template&lt;/code&gt; repo, the current content of the file looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ cat src/index.js
const { Molecule } = require(&#39;molecule-javascript&#39;)
const schema = require(&#39;../schema/blockchain-combined.json&#39;)

const names = schema.declarations.map(declaration =&amp;gt; declaration.name)
const scriptTypeIndex = names.indexOf(&#39;Script&#39;)
const scriptType = schema.declarations[scriptTypeIndex]

// Write your script logic here.
CKB.debug(scriptType)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will modify this file to add the logic we need.&lt;/p&gt;
&lt;h2 id=&#34;script-debugger-preparation&#34;&gt;Script Debugger Preparation&lt;/h2&gt;
&lt;p&gt;To aid script programming, let&amp;rsquo;s put together a debugging environment. The debugging environment will serve 2 purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prepare a complete transaction that can be loaded to CKB debugger;&lt;/li&gt;
&lt;li&gt;Create transactions and relay them to CKB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s first create the environment skeleton:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ mkdir htlc-runner
$ cd htlc-runner
$ npm init
$ npm install --save @nervosnetwork/ckb-sdk-core
$ npm install --save @nervosnetwork/ckb-sdk-utils
$ npm install --save molecule-javascript
$ npm install --save crc32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&amp;rsquo;s create a transaction skeleton for debugger usage:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ cat skeleton.json
{
  &amp;quot;mock_info&amp;quot;: {
    &amp;quot;inputs&amp;quot;: [
      {
        &amp;quot;input&amp;quot;: {
          &amp;quot;previous_output&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
          },
          &amp;quot;since&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x4b9f96b00&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947c219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd970dd9a8&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;@DUKTAPE_HASH&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;0x&amp;quot;
      }
    ],
    &amp;quot;cell_deps&amp;quot;: [
      {
        &amp;quot;cell_dep&amp;quot;: {
          &amp;quot;out_point&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
          },
          &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x702198d000&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;@SCRIPT_CODE&amp;quot;
      },
      {
        &amp;quot;cell_dep&amp;quot;: {
          &amp;quot;out_point&amp;quot;: {
            &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
            &amp;quot;index&amp;quot;: &amp;quot;0x1&amp;quot;
          },
          &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
        },
        &amp;quot;output&amp;quot;: {
          &amp;quot;capacity&amp;quot;: &amp;quot;0x702198d000&amp;quot;,
          &amp;quot;lock&amp;quot;: {
            &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
            &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
            &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
          },
          &amp;quot;type&amp;quot;: null
        },
        &amp;quot;data&amp;quot;: &amp;quot;@DUKTAPE_CODE&amp;quot;
      }
    ],
    &amp;quot;header_deps&amp;quot;: [
      {
        &amp;quot;compact_target&amp;quot;: &amp;quot;0x1a1e4c2f&amp;quot;,
        &amp;quot;hash&amp;quot;: &amp;quot;0x51d199c4060f703344eab3c9b8794e6c60195ae9093986c35dba7c3486224409&amp;quot;,
        &amp;quot;number&amp;quot;: &amp;quot;0xd8fc4&amp;quot;,
        &amp;quot;parent_hash&amp;quot;: &amp;quot;0xc02e01eb57b205c6618c9870667ed90e13adb7e9a7ae00e7a780067a6bfa6a7b&amp;quot;,
        &amp;quot;nonce&amp;quot;: &amp;quot;0xca8c7caa8100003400231b4f9d6e0300&amp;quot;,
        &amp;quot;timestamp&amp;quot;: &amp;quot;0x17061eab69e&amp;quot;,
        &amp;quot;transactions_root&amp;quot;: &amp;quot;0xffb0863f4ae1f3026ba99b2458de2fa69881f7508599e2ff1ee51a54c88b5f88&amp;quot;,
        &amp;quot;proposals_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
        &amp;quot;uncles_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
        &amp;quot;version&amp;quot;: &amp;quot;0x0&amp;quot;,
        &amp;quot;epoch&amp;quot;: &amp;quot;0x53f00fa000232&amp;quot;,
        &amp;quot;dao&amp;quot;: &amp;quot;0x4bfe53a5a9bb9a30c88898b9dfe22300a58f2bafed47680000d3b9f5b6630107&amp;quot;
      }
    ]
  },
  &amp;quot;tx&amp;quot;: {
    &amp;quot;version&amp;quot;: &amp;quot;0x0&amp;quot;,
    &amp;quot;cell_deps&amp;quot;: [
      {
        &amp;quot;out_point&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
      },
      {
        &amp;quot;out_point&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xfcd1b3ddcca92b1e49783769e9bf606112b3f8cf36b96cac05bf44edcf5377e6&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x1&amp;quot;
        },
        &amp;quot;dep_type&amp;quot;: &amp;quot;code&amp;quot;
      }
    ],
    &amp;quot;header_deps&amp;quot;: [
      &amp;quot;0x51d199c4060f703344eab3c9b8794e6c60195ae9093986c35dba7c3486224409&amp;quot;
    ],
    &amp;quot;inputs&amp;quot;: [
      {
        &amp;quot;previous_output&amp;quot;: {
          &amp;quot;tx_hash&amp;quot;: &amp;quot;0xa98c57135830e1b91345948df6c4b8870828199a786b26f09f7dec4bc27a73da&amp;quot;,
          &amp;quot;index&amp;quot;: &amp;quot;0x0&amp;quot;
        },
        &amp;quot;since&amp;quot;: &amp;quot;0x0&amp;quot;
      }
    ],
    &amp;quot;outputs&amp;quot;: [
      {
        &amp;quot;capacity&amp;quot;: &amp;quot;0x0&amp;quot;,
        &amp;quot;lock&amp;quot;: {
          &amp;quot;args&amp;quot;: &amp;quot;0x&amp;quot;,
          &amp;quot;code_hash&amp;quot;: &amp;quot;0x0000000000000000000000000000000000000000000000000000000000000000&amp;quot;,
          &amp;quot;hash_type&amp;quot;: &amp;quot;data&amp;quot;
        },
        &amp;quot;type&amp;quot;: null
      }
    ],
    &amp;quot;witnesses&amp;quot;: [
      &amp;quot;0x210000000c0000001d0000000d0000006920616d20612073656372657400000000&amp;quot;
    ],
    &amp;quot;outputs_data&amp;quot;: [
      &amp;quot;0x&amp;quot;
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might notice that the skeleton skips dep cell data part, this is because as we develop the HTLC script, we might need to insert different contents in the skeleton. Hence a runner here is needed to prepare the skeleton to a full transaction, then run it via CKB debugger:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ cat runner.js
#!/usr/bin/env node

const { Molecule } = require(&#39;molecule-javascript&#39;)
const schema = require(&#39;../htlc-template/schema/blockchain-combined.json&#39;)
const utils = require(&amp;quot;@nervosnetwork/ckb-sdk-utils&amp;quot;)
const process = require(&#39;process&#39;)
const fs = require(&#39;fs&#39;)

function blake2b(buffer) {
  return utils.blake2b(32, null, null, utils.PERSONAL).update(buffer).digest(&#39;binary&#39;)
}

if (process.argv.length !== 4) {
  console.log(`Usage: ${process.argv[1]} &amp;lt;duktape load0 binary&amp;gt; &amp;lt;js script&amp;gt;`)
  process.exit(1)
}

const duktape_binary = fs.readFileSync(process.argv[2])
const duktape_hash = blake2b(duktape_binary)
const js_script = fs.readFileSync(process.argv[3])

const data = fs.readFileSync(&#39;skeleton.json&#39;, &#39;utf8&#39;).
      replace(&amp;quot;@DUKTAPE_HASH&amp;quot;, utils.bytesToHex(duktape_hash)).
      replace(&amp;quot;@SCRIPT_CODE&amp;quot;, utils.bytesToHex(js_script)).
      replace(&amp;quot;@DUKTAPE_CODE&amp;quot;, utils.bytesToHex(duktape_binary))

fs.writeFileSync(&#39;tx.json&#39;, data)

const resolved_tx = JSON.parse(data)
const json_lock_script = resolved_tx.mock_info.inputs[0].output.lock
const lock_script = {
  codeHash: json_lock_script.code_hash,
  hashType: json_lock_script.hash_type,
  args: json_lock_script.args
}
const lock_script_hash = blake2b(utils.hexToBytes(utils.serializeScript(lock_script)))

console.log(`../ckb-standalone-debugger/bins/target/release/ckb-debugger -g lock -h ${utils.bytesToHex(lock_script_hash)} -t tx.json`)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We need to compile duktape here:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ git clone --recursive https://github.com/xxuejie/ckb-duktape
$ cd ckb-duktape
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191209 bash
root@18d4b1952624:/# cd /code
root@18d4b1952624:/code# make
root@18d4b1952624:/code# exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And also CKB debugger:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ git clone --recursive https://github.com/xxuejie/ckb-standalone-debugger
$ cd ckb-standalone-debugger/bins
$ cargo build --release
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can try running generated script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ chmod +x runner.js
$ RUST_LOG=debug `./runner.js ../ckb-duktape/build/load0 ../htlc-template/build/duktape.js`
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x8209891745eb858abd6f5e53c99b4f101bca221bd150a2ece58a389b7b4f8fa7) DEBUG OUTPUT: [object Object]
Run result: Ok(0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will prepare the transaction to run from duktape binary and JS script, then run it via CKB debugger, debug outputs and final results will be printed to stdout.&lt;/p&gt;
&lt;p&gt;Or if you find a REPL more helpful, you can use the following line to execute the script and then start a REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ RUST_LOG=debug `./runner.js ../ckb-duktape/build/repl0 ../htlc-template/build/duktape.js`
duk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With the debugger ready, let&amp;rsquo;s now start to implement the HTLC script.&lt;/p&gt;
&lt;h2 id=&#34;custom-arguments&#34;&gt;Custom Arguments&lt;/h2&gt;
&lt;p&gt;CKB provides 2 places that we can use to hold arguments to scripts running on CKB:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;args&lt;/code&gt; field in &lt;code&gt;Script&lt;/code&gt; structure&lt;/li&gt;
&lt;li&gt;&lt;code&gt;witnesses&lt;/code&gt; field in &lt;code&gt;Transaction&lt;/code&gt; structure&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The difference between them, is that &lt;code&gt;args&lt;/code&gt; field is used to hold arguments that remains the same for all usage of the same script, while &lt;code&gt;witnesses&lt;/code&gt; field is used for temporary arguments that are used in one-time transaction validation. One example here is: for a script that does signature verification, &lt;code&gt;args&lt;/code&gt; field is typically used to store public key hash, while &lt;code&gt;witnesses&lt;/code&gt; field is used to hold valid signature.&lt;/p&gt;
&lt;p&gt;For maximum flexibility, both &lt;code&gt;args&lt;/code&gt; field and each item in the &lt;code&gt;witnesses&lt;/code&gt; array field are just plain raw bytes. It&amp;rsquo;s up to dapp developers to design the actual format of data they want to hold. In our HTLC script, we will use &lt;a href=&#34;https://github.com/nervosnetwork/molecule&#34;&gt;molecule&lt;/a&gt; serialization format. Molecule is widely used in CKB. If you want to interact with CKB, such as reading certain cell/script used in the current transaction, you will need to deal with molecule format. Now this is a perfect opportunity to explain how one can interact with CKB via molecule in great details, hence we will implement the custom structure used by &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;witness&lt;/code&gt; in molecule format. Though you are free to use any serialization format in your own scripts.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s first create a file with the 2 needed data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ cat htlc.mol
array Uint32 [byte; 4];
array Byte32 [byte; 32];
vector Bytes &amp;lt;byte&amp;gt;;

struct HtlcArgs {
  a: Byte32,
  b: Byte32,
  hash: Uint32,
}

table HtlcWitness {
  s: Bytes,
  i: Uint32,
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For more information on molecule, please refer to the &lt;a href=&#34;https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0008-serialization/0008-serialization.md&#34;&gt;RFC&lt;/a&gt;. Here we are defining 2 structures with following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HtlcArgs&lt;/code&gt; requires 2 32-byte long raw bytes for storing both public keys(later we shall the HTLC script here actually generalizes a bit from this design), and a single 32-bit integer value for storing hash. For simplicity, our HTLC will use CRC32 as the hash function, but in a production setting, this is far from a secure solution, and you should definitely use a proper secure hash function for this;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HtlcWitness&lt;/code&gt; has 2 optional(denoted by the &lt;code&gt;table&lt;/code&gt; construct) arguments: it contains either a variable length string containing the secret string for HTLC, or a 32-bit integer value denoting the header to check for 100 block rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deserializing-in-molecule&#34;&gt;Deserializing in Molecule&lt;/h2&gt;
&lt;p&gt;With the molecule definition in place for the custom data structure, we need to first convert them into a format that can be consumed by the JavaScript implementation of molecule:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ cargo install moleculec
$ moleculec --language - --format json --schema-file htlc.mol &amp;gt; src/htlc.json
$ npx moleculec-js -ns src/htlc.json &amp;gt; src/htlc-combined.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can fill in the code that loads current Script, and parses the serialized args into a valid structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ cat src/index.js
const { Molecule } = require(&#39;molecule-javascript&#39;)
const schema = require(&#39;../schema/blockchain-combined.json&#39;)

const names = schema.declarations.map(declaration =&amp;gt; declaration.name)
const scriptTypeIndex = names.indexOf(&#39;Script&#39;)
const scriptType = new Molecule(schema.declarations[scriptTypeIndex])

// Write your script logic here.
const customSchema = require(&#39;./htlc-combined.json&#39;)
const customNames = customSchema.declarations.map(d =&amp;gt; d.name)

const htlcArgsIndex = customNames.indexOf(&#39;HtlcArgs&#39;)
const htlcArgsType = new Molecule(customSchema.declarations[htlcArgsIndex])

function bytesToHex(b) {
  return &amp;quot;0x&amp;quot; + Array.prototype.map.call(
    new Uint8Array(b),
    function(x) {
      return (&#39;00&#39; + x.toString(16)).slice(-2)
    }
  ).join(&#39;&#39;)
}

function hexStringArrayToHexString(a) {
  let s = &amp;quot;0x&amp;quot;;
  for (let i = 0; i &amp;lt; a.length; i++) {
    s = s + a[i].substr(2)
  }
  return s
}

const current_script = scriptType.deserialize(bytesToHex(CKB.load_script(0)))
const args = hexStringArrayToHexString(current_script[2][1])
const htlcArgs = htlcArgsType.deserialize(args)

CKB.debug(`a: ${hexStringArrayToHexString(htlcArgs[0][1])}`)
CKB.debug(`b: ${hexStringArrayToHexString(htlcArgs[1][1])}`)
CKB.debug(`c: ${hexStringArrayToHexString(htlcArgs[2][1])}`)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we ignore the bookkeeping code for a sec, what matters here, is that we first use CKB syscall to load script, parse script structure, then get args:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const current_script = scriptType.deserialize(bytesToHex(CKB.load_script(0)))
const args = hexStringArrayToHexString(current_script[2][1])
const htlcArgs = htlcArgsType.deserialize(args)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We assume script args contain serialized HtlcArgs structure defined above, then we apply similar method to exact them:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const htlcArgs = htlcArgsType.deserialize(args)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have already provided some meaningful data in the skeleton, so if we try to execute the script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ npm run build
$ cd $TOP/htlc-runner
$ RUST_LOG=debug `./runner.js ../ckb-duktape/build/load0 ../htlc-template/build/duktape.js`
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x35ab3d033e66c426573ed4b7ce816e248cb042d908fd8cfe7bba27acb37fb108) DEBUG OUTPUT: a: 0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x35ab3d033e66c426573ed4b7ce816e248cb042d908fd8cfe7bba27acb37fb108) DEBUG OUTPUT: b: 0xc219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x35ab3d033e66c426573ed4b7ce816e248cb042d908fd8cfe7bba27acb37fb108) DEBUG OUTPUT: c: 0x970dd9a8
Run result: Ok(0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can find parsed results from debug logs.&lt;/p&gt;
&lt;h2 id=&#34;adding-new-library&#34;&gt;Adding new library&lt;/h2&gt;
&lt;p&gt;Another thing I want to show here, is that you can include many libraries out there already on npm, assuming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There&amp;rsquo;s a ES5 version(or you can actually adjust the webpack pipeline yourself to add polyfills) of the library;&lt;/li&gt;
&lt;li&gt;It is implemented purely in JavaScript without native code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the HTLC script, I&amp;rsquo;m gonna add &lt;a href=&#34;https://github.com/beatgammit/crc32&#34;&gt;crc32&lt;/a&gt;, and use crc32 to calculate secret string hash. I want to mention again here that CRC32 is never a secure hash function. We pick it out of simplicity, not security. In a production setting, you should really use a real secure hash function probably implemented natively rather than using JavaScript. But for now, crc32 is quite perfect for our tutorial :P&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s include crc32 in our template, and write some debugging code to test it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ npm install --save crc32
$ cat src/index.js
const { Molecule } = require(&#39;molecule-javascript&#39;)
const schema = require(&#39;../schema/blockchain-combined.json&#39;)

const names = schema.declarations.map(declaration =&amp;gt; declaration.name)
const scriptTypeIndex = names.indexOf(&#39;Script&#39;)
const scriptType = new Molecule(schema.declarations[scriptTypeIndex])

// Write your script logic here.
const customSchema = require(&#39;./htlc-combined.json&#39;)
const customNames = customSchema.declarations.map(d =&amp;gt; d.name)

const htlcArgsIndex = customNames.indexOf(&#39;HtlcArgs&#39;)
const htlcArgsType = new Molecule(customSchema.declarations[htlcArgsIndex])

function bytesToHex(b) {
  return &amp;quot;0x&amp;quot; + Array.prototype.map.call(
    new Uint8Array(b),
    function(x) {
      return (&#39;00&#39; + x.toString(16)).slice(-2)
    }
  ).join(&#39;&#39;)
}

function hexStringArrayToHexString(a) {
  let s = &amp;quot;0x&amp;quot;;
  for (let i = 0; i &amp;lt; a.length; i++) {
    s = s + a[i].substr(2)
  }
  return s
}

const current_script = scriptType.deserialize(bytesToHex(CKB.load_script(0)))
const args = hexStringArrayToHexString(current_script[2][1])
const htlcArgs = htlcArgsType.deserialize(args)

CKB.debug(`c: ${hexStringArrayToHexString(htlcArgs[2][1])}`)

const crc32 = require(&#39;crc32&#39;)
CKB.debug(crc32(&#39;i am a secret&#39;))
$ npm run build
$ cd $TOP/htlc-runner
$ RUST_LOG=debug `./runner.js ../ckb-duktape/build/load0 ../htlc-template/build/duktape.js`
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x35ab3d033e66c426573ed4b7ce816e248cb042d908fd8cfe7bba27acb37fb108) DEBUG OUTPUT: c: 0x970dd9a8
DEBUG:&amp;lt;unknown&amp;gt;: script group: Byte32(0x35ab3d033e66c426573ed4b7ce816e248cb042d908fd8cfe7bba27acb37fb108) DEBUG OUTPUT: 970dd9a8
Run result: Ok(0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might noticed that the 2 values we printed here are exactly the same! That&amp;rsquo;s because &lt;code&gt;i am a secret&lt;/code&gt; is exactly the secret string I&amp;rsquo;m picking when preparing the skeleton.&lt;/p&gt;
&lt;h2 id=&#34;piecing-the-contract-together&#34;&gt;Piecing the Contract Together&lt;/h2&gt;
&lt;p&gt;With all the libraries and required knowledge in place, we can now finish implementing the script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-template
$ cat src/index.js
const { Molecule } = require(&#39;molecule-javascript&#39;)
const schema = require(&#39;../schema/blockchain-combined.json&#39;)

const names = schema.declarations.map(declaration =&amp;gt; declaration.name)
const scriptTypeIndex = names.indexOf(&#39;Script&#39;)
const scriptType = new Molecule(schema.declarations[scriptTypeIndex])

// Write your script logic here.
const customSchema = require(&#39;./htlc-combined.json&#39;)
const customNames = customSchema.declarations.map(d =&amp;gt; d.name)

const htlcArgsIndex = customNames.indexOf(&#39;HtlcArgs&#39;)
const htlcArgsType = new Molecule(customSchema.declarations[htlcArgsIndex])

function bytesToHex(b) {
  return &amp;quot;0x&amp;quot; + Array.prototype.map.call(
    new Uint8Array(b),
    function(x) {
      return (&#39;00&#39; + x.toString(16)).slice(-2)
    }
  ).join(&#39;&#39;)
}

function hexStringArrayToString(a) {
  let s = &amp;quot;&amp;quot;;
  for (let i = 0; i &amp;lt; a.length; i++) {
    s = s + String.fromCharCode(parseInt(a[i]))
  }
  return s
}

function hexStringArrayToHexString(a) {
  let s = &amp;quot;0x&amp;quot;;
  for (let i = 0; i &amp;lt; a.length; i++) {
    s = s + a[i].substr(2)
  }
  return s
}

function parseLittleEndianHexStringArray(a) {
  let v = 0
  const l = a.length
  for (let i = 0; i &amp;lt; l; i++) {
    v = (v &amp;lt;&amp;lt; 8) | parseInt(a[l - i - 1])
  }
  return v
}

const current_script = scriptType.deserialize(bytesToHex(CKB.load_script(0)))
const args = hexStringArrayToHexString(current_script[2][1])
const htlcArgs = htlcArgsType.deserialize(args)

// Load and parse witness data using the same method as above
const htlcWitnessIndex = customNames.indexOf(&#39;HtlcWitness&#39;)
const htlcWitnessType = new Molecule(customSchema.declarations[htlcWitnessIndex])

const rawWitness = CKB.load_witness(0, 0, CKB.SOURCE.GROUP_INPUT)
if (typeof rawWitness === &#39;number&#39;) {
  throw new Error(`Invalid response when loading witness: ${rawWitness}`)
}
const htlcWitness = htlcWitnessType.deserialize(bytesToHex(rawWitness))

let lockHashToMatch;
if (htlcWitness[0][1].length &amp;gt; 0) {
  // Test secret string hash
  const crc32 = require(&#39;crc32&#39;)
  const hash = &#39;0x&#39; + crc32(hexStringArrayToString(htlcWitness[0][1]))
  if (hash !== hexStringArrayToHexString(htlcArgs[2][1])) {
    throw new Error(`Invalid secret string!`)
  }
  lockHashToMatch = hexStringArrayToHexString(htlcArgs[0][1])
} else {
  // Test header block
  const headerTypeIndex = names.indexOf(&#39;Header&#39;)
  const headerType = new Molecule(schema.declarations[headerTypeIndex])

  // Load header for current input first
  const rawInputHeader = CKB.load_header(0, 0, CKB.SOURCE.GROUP_INPUT)
  if (typeof rawWitness === &#39;number&#39;) {
    throw new Error(`Invalid response when loading input header: ${rawInputHeader}`)
  }
  const inputHeader = headerType.deserialize(bytesToHex(rawInputHeader))
  const inputHeaderNumber = parseLittleEndianHexStringArray(inputHeader[0][1][3][1])

  const targetHeaderIndex = parseLittleEndianHexStringArray(htlcWitness[1][1])
  const rawTargetHeader = CKB.load_header(0, targetHeaderIndex,
                                          CKB.SOURCE.HEADER_DEP)
  if (typeof rawTargetHeader === &#39;number&#39;) {
    throw new Error(`Invalid response when loading target header: ${rawTargetHeader}`)
  }
  const targetHeader = headerType.deserialize(bytesToHex(rawTargetHeader))
  const targetHeaderNumber = parseLittleEndianHexStringArray(targetHeader[0][1][3][1])

  if (targetHeaderNumber &amp;lt; inputHeaderNumber + 100) {
    throw new Error(`Timeout period has not reached!`)
  }
  lockHashToMatch = hexStringArrayToHexString(htlcArgs[1][1])
}

// Now we know which lock hash to test against, we look for an input cell
// with the specified lock hash
let i = 0
while (true) {
  const rawHash = CKB.load_cell_by_field(0, i, CKB.SOURCE.INPUT, CKB.CELL.LOCK_HASH)
  if (rawHash == CKB.CODE.INDEX_OUT_OF_BOUND) {
    throw new Error(`Cannot find input cell using lock hash ${lockHashToMatch}`)
  }
  if (typeof rawHash === &#39;number&#39;) {
    throw new Error(`Invalid response when loading input cell: ${rawHash}`)
  }
  if (bytesToHex(rawHash) == lockHashToMatch) {
    break
  }
  i += 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It uses similar techniques as shown above to parse witness and block headers, which are also in molecule format.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s one trick worth mentioning: in the design of HTLC script, I mentioned that the script needs to do signature verification for a given public key. The actual implemention we have here, generalizes slightly from this design:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instead of test a given public key, we are testing for the whole lock script hash. While this certainly satisfies our requirement, it provides more possibilities: if everyone is using the default secp256k1 lock script, different public keys will be reflected in script args part, resulting in differnet lock scripts. So testing lock scripts can certainly ensure different public keys are using. On the other hand, not everyone might be using the default secp256k1 lock script, so testing lock script hash directly, can enable more flexibilities in the HTLC script usage.&lt;/li&gt;
&lt;li&gt;While one can certainly embeds the signature verification logic within the HTLC script, we opt for a different and simpler solution here: we just test that one of the input cell has the specified lock script. Per CKB&amp;rsquo;s validation rules, if the transaction is accepted by the blockchain, each input cells&#39; lock script must pass validation, which means the lock script specified in the HTLC script will also pass validation, satisfying the validation rules of HTLC script.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To summarize a bit, we are actually showing 2 patterns that can be handy when desining dapps on CKB:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Instead of testing signature verification for a public key, one can test for the validation of a lock script to enable flexibilities.&lt;/li&gt;
&lt;li&gt;Instead of duplicating a different lock script, one can check for the existence of an input cell using the same lock, and delegate the validation work to the input cell&amp;rsquo;s lock script.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Fundamentally, it depends on your use case to see if those patterns can apply. Later we might also build real composable scripts via dynamic linking to supplyment pattern 2. But having those in your armory might turn out to be useful when your design can be simply by them.&lt;/p&gt;
&lt;h2 id=&#34;always-audit-your-script&#34;&gt;Always Audit Your Script&lt;/h2&gt;
&lt;p&gt;One final note here, is that you should always remember to audit the script before deploying it and putting real tokens in it. The above HTLC script is primarily for introductory purposes. I can easily recognize a few vulnerabilities in them. You should never use it directly on CKB mainnet. However, it does provide a quite interesting exercise, so if you are interested, feel free to read the script and see if you can spot the vulnerabilities yourself :P&lt;/p&gt;
&lt;h1 id=&#34;running-htlc-script-on-chain&#34;&gt;Running HTLC Script on Chain&lt;/h1&gt;
&lt;p&gt;There&amp;rsquo;re 2 parts in testing a CKB script: previously, we were using a off-chain debugger environment to test the script for faster iteration. Now that we have a complete HTLC script, we should also deploy it on a dev chain and test the whole workflow. After all any blockchain smart contracts cannot live alone, they have to have a surrounding environments that help prepare the transaction and invoke them on chain. This is more the case for CKB, since CKB uses a separated validator-generator model.&lt;/p&gt;
&lt;p&gt;To test our HTLC script on chain, we are gonna reuse our &lt;code&gt;htlc-runner&lt;/code&gt; environment here, and write a few more node executables that can deploy and test the HTLC script on chain. The first executable we will write, is an executable to deploy duktape binary as well as our HTLC script on chain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ cat deploy_scripts.js
#!/usr/bin/env node

const CKB = require(&amp;quot;@nervosnetwork/ckb-sdk-core&amp;quot;).default
const utils = require(&amp;quot;@nervosnetwork/ckb-sdk-utils&amp;quot;)
const process = require(&#39;process&#39;)
const fs = require(&#39;fs&#39;)

if (process.argv.length !== 6) {
  console.log(`Usage: ${process.argv[1]} &amp;lt;duktape load0 binary&amp;gt; &amp;lt;js script&amp;gt; &amp;lt;private key&amp;gt; &amp;lt;node URL&amp;gt;`)
  process.exit(1)
}

const duktapeBinary = fs.readFileSync(process.argv[2])
const jsScript = fs.readFileSync(process.argv[3])

const privateKey = process.argv[4]
const nodeUrl = process.argv[5]

const run = async () =&amp;gt; {
  const ckb = new CKB(nodeUrl)
  const secp256k1Dep = await ckb.loadSecp256k1Dep()

  const publicKey = ckb.utils.privateKeyToPublicKey(privateKey)
  const publicKeyHash = `0x${ckb.utils.blake160(publicKey, &#39;hex&#39;)}`

  const lockScript = {
    hashType: secp256k1Dep.hashType,
    codeHash: secp256k1Dep.codeHash,
    args: publicKeyHash
  }
  const lockHash = ckb.utils.scriptToHash(lockScript)

  const unspentCells = await ckb.loadCells({
    lockHash
  })
  const totalCapacity = unspentCells.reduce((sum, cell) =&amp;gt; sum + BigInt(cell.capacity), 0n)

  // For simplicity, we will just use 1 CKB as fee. On a real setup you
  // might not want to do this.
  const fee = 100000000n
  const duktapeBinaryCapacity = BigInt(duktapeBinary.length) * 100000000n + 4100000000n
  const jsScriptCapacity = BigInt(jsScript.length) * 100000000n + 4100000000n

  const outputs = [
    {
      lock: {
        codeHash: &#39;0x0000000000000000000000000000000000000000000000000000000000000000&#39;,
        hashType: &#39;data&#39;,
        args: &#39;0x&#39;
      },
      type: null,
      capacity: &#39;0x&#39; + duktapeBinaryCapacity.toString(16)
    },
    {
      lock: {
        codeHash: &#39;0x0000000000000000000000000000000000000000000000000000000000000000&#39;,
        hashType: &#39;data&#39;,
        args: &#39;0x&#39;
      },
      type: null,
      capacity: &#39;0x&#39; + jsScriptCapacity.toString(16)
    },
    {
      lock: lockScript,
      type: null,
      capacity: &#39;0x&#39; + (totalCapacity - jsScriptCapacity - duktapeBinaryCapacity - fee).toString(16)
    }
  ]
  const outputsData = [
    utils.bytesToHex(duktapeBinary),
    utils.bytesToHex(jsScript),
    &#39;0x&#39;
  ]

  const transaction = {
    version: &#39;0x0&#39;,
    cellDeps: [
      {
        outPoint: secp256k1Dep.outPoint,
        depType: &#39;depGroup&#39;
      }
    ],
    headerDeps: [],
    inputs: unspentCells.map(cell =&amp;gt; ({
      previousOutput: cell.outPoint,
      since: &#39;0x0&#39;
    })),
    outputs,
    witnesses: [
      {
        lock: &#39;&#39;,
        inputType: &#39;&#39;,
        outputType: &#39;&#39;
      }
    ],
    outputsData
  }
  const signedTransaction = ckb.signTransaction(privateKey)(transaction)

  const txHash = await ckb.rpc.sendTransaction(signedTransaction, &#39;passthrough&#39;)

  console.log(`Transaction hash: ${txHash}`)
  fs.writeFileSync(&#39;deploy_scripts_result.txt&#39;, txHash)
}

run()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second executable creates a cell using HTLC script as lock:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ cat create_htlc_cell.js
#!/usr/bin/env node

const { Molecule } = require(&#39;molecule-javascript&#39;)
const crc32 = require(&#39;crc32&#39;)
const CKB = require(&amp;quot;@nervosnetwork/ckb-sdk-core&amp;quot;).default
const utils = require(&amp;quot;@nervosnetwork/ckb-sdk-utils&amp;quot;)
const process = require(&#39;process&#39;)
const fs = require(&#39;fs&#39;)

function blake2b(buffer) {
  return utils.blake2b(32, null, null, utils.PERSONAL).update(buffer).digest(&#39;binary&#39;)
}

if (process.argv.length !== 8) {
  console.log(`Usage: ${process.argv[1]} &amp;lt;duktape load0 binary&amp;gt; &amp;lt;deployed tx hash&amp;gt; &amp;lt;private key&amp;gt; &amp;lt;node URL&amp;gt; &amp;lt;lock hash A&amp;gt; &amp;lt;lock hash B&amp;gt;`)
  process.exit(1)
}

const duktapeBinary = fs.readFileSync(process.argv[2])
const duktapeHash = blake2b(duktapeBinary)

const deployedTxHash = process.argv[3]
const privateKey = process.argv[4]
const nodeUrl = process.argv[5]
const lockHashA = process.argv[6]
const lockHashB = process.argv[7]

function hexStringToHexStringArray(s) {
  let arr = []
  for (let i = 2; i &amp;lt; s.length; i += 2) {
    arr.push(&#39;0x&#39; + s.substr(i, 2))
  }
  return arr
}

const run = async () =&amp;gt; {
  const ckb = new CKB(nodeUrl)
  const secp256k1Dep = await ckb.loadSecp256k1Dep()

  const publicKey = ckb.utils.privateKeyToPublicKey(privateKey)
  const publicKeyHash = `0x${ckb.utils.blake160(publicKey, &#39;hex&#39;)}`

  const lockScript = {
    hashType: secp256k1Dep.hashType,
    codeHash: secp256k1Dep.codeHash,
    args: publicKeyHash
  }
  const lockHash = ckb.utils.scriptToHash(lockScript)

  const unspentCells = await ckb.loadCells({
    lockHash
  })
  const totalCapacity = unspentCells.reduce((sum, cell) =&amp;gt; sum + BigInt(cell.capacity), 0n)

  // For simplicity, we will just use 1 CKB as fee. On a real setup you
  // might not want to do this.
  const fee = 100000000n
  const htlcCellCapacity = 200000000000n

  const customSchema = JSON.parse(fs.readFileSync(&#39;../htlc-template/src/htlc-combined.json&#39;))
  const htlcArgsType = new Molecule(
    customSchema.declarations.find(d =&amp;gt; d.name == &amp;quot;HtlcArgs&amp;quot;))
  const htlcScriptArgs = htlcArgsType.serialize([
    [&#39;a&#39;, hexStringToHexStringArray(lockHashA)],
    [&#39;b&#39;, hexStringToHexStringArray(lockHashB)],
    [&#39;hash&#39;, hexStringToHexStringArray(&#39;0x&#39; + crc32(&#39;i am a secret&#39;))]
  ])

  const transaction = {
    version: &#39;0x0&#39;,
    cellDeps: [
      {
        outPoint: secp256k1Dep.outPoint,
        depType: &#39;depGroup&#39;
      }
    ],
    headerDeps: [],
    inputs: unspentCells.map(cell =&amp;gt; ({
      previousOutput: cell.outPoint,
      since: &#39;0x0&#39;
    })),
    outputs: [
      {
        lock: {
          codeHash: utils.bytesToHex(duktapeHash),
          hashType: &#39;data&#39;,
          args: htlcScriptArgs
        },
        type: null,
        capacity: &#39;0x&#39; + htlcCellCapacity.toString(16)
      },
      {
        lock: lockScript,
        type: null,
        capacity: &#39;0x&#39; + (totalCapacity - fee - htlcCellCapacity).toString(16)
      }
    ],
    witnesses: [
      {
        lock: &#39;&#39;,
        inputType: &#39;&#39;,
        outputType: &#39;&#39;
      }
    ],
    outputsData: [
      &#39;0x&#39;,
      &#39;0x&#39;
    ]
  }
  const signedTransaction = ckb.signTransaction(privateKey)(transaction)

  const txHash = await ckb.rpc.sendTransaction(signedTransaction, &#39;passthrough&#39;)

  console.log(`Transaction hash: ${txHash}`)
  fs.writeFileSync(&#39;create_htlc_cell_result.txt&#39;, txHash)
}

run()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One thing worth mentioning, is that this executable shows how we can serialize a molecule formatted data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ...

function hexStringToHexStringArray(s) {
  let arr = []
  for (let i = 2; i &amp;lt; s.length; i += 2) {
    arr.push(&#39;0x&#39; + s.substr(i, 2))
  }
  return arr
}

// ...

const customSchema = JSON.parse(fs.readFileSync(&#39;../htlc-template/src/htlc-combined.json&#39;))
const htlcArgsType = new Molecule(
  customSchema.declarations.find(d =&amp;gt; d.name == &amp;quot;HtlcArgs&amp;quot;))
const htlcScriptArgs = htlcArgsType.serialize([
  [&#39;a&#39;, hexStringToHexStringArray(lockHashA)],
  [&#39;b&#39;, hexStringToHexStringArray(lockHashB)],
  [&#39;hash&#39;, hexStringToHexStringArray(&#39;0x&#39; + crc32(&#39;i am a secret&#39;))]
])

// ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And now a executable that tries to unlock HTLC guarded cell by providing secret string:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ cat unlock_via_secret_string.js
#!/usr/bin/env node

const { Molecule } = require(&#39;molecule-javascript&#39;)
const crc32 = require(&#39;crc32&#39;)
const CKB = require(&amp;quot;@nervosnetwork/ckb-sdk-core&amp;quot;).default
const utils = require(&amp;quot;@nervosnetwork/ckb-sdk-utils&amp;quot;)
const process = require(&#39;process&#39;)
const fs = require(&#39;fs&#39;)

function blake2b(buffer) {
  return utils.blake2b(32, null, null, utils.PERSONAL).update(buffer).digest(&#39;binary&#39;)
}

if (process.argv.length !== 8) {
  console.log(`Usage: ${process.argv[1]} &amp;lt;deployed tx hash&amp;gt; &amp;lt;htlc cell tx hash&amp;gt; &amp;lt;private key&amp;gt; &amp;lt;node URL&amp;gt; &amp;lt;secret string&amp;gt; &amp;lt;dry run&amp;gt;`)
  process.exit(1)
}

const deployedTxHash = process.argv[2]
const htlcCellTxHash = process.argv[3]
const privateKey = process.argv[4]
const nodeUrl = process.argv[5]
const secretString = process.argv[6]
const dryrun = process.argv[7] === &#39;true&#39;

function stringToHexStringArray(s) {
  let a = []
  for (let i = 0; i &amp;lt; s.length; i++) {
    a.push(&#39;0x&#39; + (&#39;00&#39; + s.charCodeAt(i).toString(16)).slice(-2))
  }
  return a
}

const run = async () =&amp;gt; {
  const ckb = new CKB(nodeUrl)
  const secp256k1Dep = await ckb.loadSecp256k1Dep()

  const publicKey = ckb.utils.privateKeyToPublicKey(privateKey)
  const publicKeyHash = `0x${ckb.utils.blake160(publicKey, &#39;hex&#39;)}`

  const lockScript = {
    hashType: secp256k1Dep.hashType,
    codeHash: secp256k1Dep.codeHash,
    args: publicKeyHash
  }
  const lockHash = ckb.utils.scriptToHash(lockScript)

  const unspentCells = await ckb.loadCells({
    lockHash
  })
  const totalCapacity = unspentCells.reduce((sum, cell) =&amp;gt; sum + BigInt(cell.capacity), 0n)

  // For simplicity, we will just use 1 CKB as fee. On a real setup you
  // might not want to do this.
  const fee = 100000000n
  const htlcCellCapacity = 200000000000n

  const customSchema = JSON.parse(fs.readFileSync(&#39;../htlc-template/src/htlc-combined.json&#39;))
  const htlcWitnessType = new Molecule(
    customSchema.declarations.find(d =&amp;gt; d.name == &amp;quot;HtlcWitness&amp;quot;))
  const htlcWitness = htlcWitnessType.serialize([
    [&#39;s&#39;, stringToHexStringArray(secretString)],
    [&#39;i&#39;, [&#39;0x0&#39;, &#39;0x0&#39;, &#39;0x0&#39;, &#39;0x0&#39;]]
  ])

  const transaction = {
    version: &#39;0x0&#39;,
    cellDeps: [
      // Due to the requirement of load0 duktape binary, JavaScript source cell
      // should be the first one in cell deps
      {
        outPoint: {
          txHash: deployedTxHash,
          index: &amp;quot;0x1&amp;quot;
        },
        depType: &#39;code&#39;
      },
      {
        outPoint: {
          txHash: deployedTxHash,
          index: &amp;quot;0x0&amp;quot;
        },
        depType: &#39;code&#39;
      },
      {
        outPoint: secp256k1Dep.outPoint,
        depType: &#39;depGroup&#39;
      }
    ],
    headerDeps: [],
    inputs: unspentCells.map(cell =&amp;gt; ({
      previousOutput: cell.outPoint,
      since: &#39;0x0&#39;
    })),
    outputs: [
      {
        lock: lockScript,
        type: null,
        capacity: &#39;0x&#39; + (totalCapacity + htlcCellCapacity - fee).toString(16)
      }
    ],
    witnesses: unspentCells.map(_cell =&amp;gt; &#39;0x&#39;),
    outputsData: [
      &#39;0x&#39;,
      &#39;0x&#39;
    ]
  }
  transaction.inputs.push({
    previousOutput: {
      txHash: htlcCellTxHash,
      index: &amp;quot;0x0&amp;quot;
    },
    since: &#39;0x0&#39;
  })
  transaction.witnesses[0] = {
    lock: &#39;&#39;,
    inputType: &#39;&#39;,
    outputType: &#39;&#39;
  }
  const signedTransaction = ckb.signTransaction(privateKey)(transaction)
  signedTransaction.witnesses.push(htlcWitness)

  if (dryrun) {
    try {
      const result = await ckb.rpc.dryRunTransaction(signedTransaction)
      console.log(`Dry run success result: ${JSON.stringify(result, null, 2)}`)
    } catch (e) {
      console.log(`Dry run failure result: ${JSON.stringify(JSON.parse(e.message), null, 2)}`)
    }
  } else {
    const txHash = await ckb.rpc.sendTransaction(signedTransaction, &#39;passthrough&#39;)

    console.log(`Transaction hash: ${txHash}`)
    fs.writeFileSync(&#39;unlock_via_secret_string_result.txt&#39;, txHash)
  }
}

run()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally a executable that tries to unlock HTLC guarded cell assuming the waiting period has passed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP/htlc-runner
$ cat unlock_via_timeout.js
#!/usr/bin/env node

const { Molecule } = require(&#39;molecule-javascript&#39;)
const crc32 = require(&#39;crc32&#39;)
const CKB = require(&amp;quot;@nervosnetwork/ckb-sdk-core&amp;quot;).default
const utils = require(&amp;quot;@nervosnetwork/ckb-sdk-utils&amp;quot;)
const process = require(&#39;process&#39;)
const fs = require(&#39;fs&#39;)

function blake2b(buffer) {
  return utils.blake2b(32, null, null, utils.PERSONAL).update(buffer).digest(&#39;binary&#39;)
}

if (process.argv.length !== 8) {
  console.log(`Usage: ${process.argv[1]} &amp;lt;deployed tx hash&amp;gt; &amp;lt;htlc cell tx hash&amp;gt; &amp;lt;private key&amp;gt; &amp;lt;node URL&amp;gt; &amp;lt;header hash&amp;gt; &amp;lt;dry run&amp;gt;`)
  process.exit(1)
}

const deployedTxHash = process.argv[2]
const htlcCellTxHash = process.argv[3]
const privateKey = process.argv[4]
const nodeUrl = process.argv[5]
const headerHash = process.argv[6]
const dryrun = process.argv[7] === &#39;true&#39;

const run = async () =&amp;gt; {
  const ckb = new CKB(nodeUrl)
  const secp256k1Dep = await ckb.loadSecp256k1Dep()

  const htlcCellTx = await ckb.rpc.getTransaction(htlcCellTxHash)
  const htlcCellHeaderHash = htlcCellTx.txStatus.blockHash

  const publicKey = ckb.utils.privateKeyToPublicKey(privateKey)
  const publicKeyHash = `0x${ckb.utils.blake160(publicKey, &#39;hex&#39;)}`

  const lockScript = {
    hashType: secp256k1Dep.hashType,
    codeHash: secp256k1Dep.codeHash,
    args: publicKeyHash
  }
  const lockHash = ckb.utils.scriptToHash(lockScript)

  const unspentCells = await ckb.loadCells({
    lockHash
  })
  const totalCapacity = unspentCells.reduce((sum, cell) =&amp;gt; sum + BigInt(cell.capacity), 0n)

  // For simplicity, we will just use 1 CKB as fee. On a real setup you
  // might not want to do this.
  const fee = 100000000n
  const htlcCellCapacity = 200000000000n

  const customSchema = JSON.parse(fs.readFileSync(&#39;../htlc-template/src/htlc-combined.json&#39;))
  const htlcWitnessType = new Molecule(
    customSchema.declarations.find(d =&amp;gt; d.name == &amp;quot;HtlcWitness&amp;quot;))
  const htlcWitness = htlcWitnessType.serialize([
    [&#39;s&#39;, []],
    [&#39;i&#39;, [&#39;0x1&#39;, &#39;0x0&#39;, &#39;0x0&#39;, &#39;0x0&#39;]]
  ])

  const transaction = {
    version: &#39;0x0&#39;,
    cellDeps: [
      // Due to the requirement of load0 duktape binary, JavaScript source cell
      // should be the first one in cell deps
      {
        outPoint: {
          txHash: deployedTxHash,
          index: &amp;quot;0x1&amp;quot;
        },
        depType: &#39;code&#39;
      },
      {
        outPoint: {
          txHash: deployedTxHash,
          index: &amp;quot;0x0&amp;quot;
        },
        depType: &#39;code&#39;
      },
      {
        outPoint: secp256k1Dep.outPoint,
        depType: &#39;depGroup&#39;
      }
    ],
    headerDeps: [
      htlcCellHeaderHash,
      headerHash,
    ],
    inputs: unspentCells.map(cell =&amp;gt; ({
      previousOutput: cell.outPoint,
      since: &#39;0x0&#39;
    })),
    outputs: [
      {
        lock: lockScript,
        type: null,
        capacity: &#39;0x&#39; + (totalCapacity + htlcCellCapacity - fee).toString(16)
      }
    ],
    witnesses: unspentCells.map(_cell =&amp;gt; &#39;0x&#39;),
    outputsData: [
      &#39;0x&#39;,
      &#39;0x&#39;
    ]
  }
  transaction.inputs.push({
    previousOutput: {
      txHash: htlcCellTxHash,
      index: &amp;quot;0x0&amp;quot;
    },
    since: &#39;0x0&#39;
  })
  transaction.witnesses[0] = {
    lock: &#39;&#39;,
    inputType: &#39;&#39;,
    outputType: &#39;&#39;
  }
  const signedTransaction = ckb.signTransaction(privateKey)(transaction)
  signedTransaction.witnesses.push(htlcWitness)

  if (dryrun) {
    try {
      const result = await ckb.rpc.dryRunTransaction(signedTransaction)
      console.log(`Dry run success result: ${JSON.stringify(result, null, 2)}`)
    } catch (e) {
      console.log(`Dry run failure result: ${JSON.stringify(JSON.parse(e.message), null, 2)}`)
    }
  } else {
    const txHash = await ckb.rpc.sendTransaction(signedTransaction, &#39;passthrough&#39;)

    console.log(`Transaction hash: ${txHash}`)
    fs.writeFileSync(&#39;unlock_via_timeout_result.txt&#39;, txHash)
  }
}

run()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are putting the header dep for HTLC input cell at index 0, the header to test for current timestamp at index 1, hence when we are preparing witness data, we use 0x01000000 for i, which is the little endian representation for 1.&lt;/p&gt;
&lt;p&gt;This also provides a different inspiration. To prove certain time has past in CKB, you can use &lt;code&gt;since&lt;/code&gt; field as shown in Nervos DAO validator script, you can also include a header on chain, and rely on the header&amp;rsquo;s block number or timestamp to prove that certain time has already been reached. It really depends on your use case to tell which one is the better choice here.&lt;/p&gt;
&lt;p&gt;With all 4 executables ready here, we are ready to play with our HTLC script a bit. But first, let&amp;rsquo;s start a new CKB dev chain.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ export CKB=&amp;quot;&amp;lt;path to your ckb binary&amp;gt;&amp;quot;
$ $CKB --version
ckb 0.28.0 (728eff2 2020-02-04)
# Block assembler args configured here correspond to the following private key:
# 0x0a14c6fd7af6a3f13c9e2aacad80d78968de5d068a342828080650084bf20104
$ $CKB init -c dev -C ckb-data --ba-arg 0x5a7487f529b8b8fd4d4a57c12dc0c70f7958a196
$ $CKB run -C ckb-data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On a different terminal, let&amp;rsquo;s start a miner instance:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $TOP
$ $CKB miner -C ckb-data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using CKB&amp;rsquo;s dev chain, since there are already 2 handy &lt;a href=&#34;https://github.com/nervosnetwork/ckb/blob/dad394ea3f50f518a40e5a8a457dfb6811ba245a/resource/specs/dev.toml#L70-L82&#34;&gt;addresses&lt;/a&gt; with issued balance, so we don&amp;rsquo;t have to mine the CKB before testing. In addition, with a dev chain you can customize block issuing speed. However if you like you can also use the testnet, just remember never to use mainnet for testing here.&lt;/p&gt;
&lt;p&gt;With the CKB instance running, HTLC script can be deployed and tested for real on chain.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Make sure the HTLC script is successfully built first
$ cd $TOP/htlc-template
$ npm run build
# Ensure all scripts are runnable
$ cd $TOP/htlc-runner
$ chmod +x deploy_scripts.js
$ chmod +x create_htlc_cell.js
$ chmod +x unlock_via_secret_string.js
$ chmod +x unlock_via_timeout.js

# Let&#39;s first deploy duktape binary and JS scripts
$ ./deploy_scripts.js \
    ../ckb-duktape/build/load0 \
    ../htlc-template/build/duktape.js \
    0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc \
    &amp;quot;http://127.0.0.1:8114/&amp;quot;
This method is only for demo, don&#39;t use it in production
Transaction hash: 0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4

# Let&#39;s create a HTLC cell
$ ./create_htlc_cell.js \
    ../ckb-duktape/build/load0 \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    0x32e555f3ff8e135cece1351a6a2971518392c1e30375c1e006ad0ce8eac07947 \
    0xc219351b150b900e50a7039f1e448b844110927e5fd9bd30425806cb8ddff1fd
This method is only for demo, don&#39;t use it in production
Transaction hash: 0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd

# To save us the hassle of recreating cells, both unlock executables support
# a dry run mode, where we only does full transaction verification, but do not
# commit the success ones on chain.
# First let&#39;s show that we can unlock a HTLC cell given the right secret string
# and lock script
$ ./unlock_via_secret_string.js \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd \
    0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    &amp;quot;i am a secret&amp;quot; \
    true
This method is only for demo, don&#39;t use it in production
Dry run success result: {
  &amp;quot;cycles&amp;quot;: &amp;quot;0xb1acc38&amp;quot;
}

# Given an invalid secret string, the transaction would fail the validation.
# If you have enabled debug output in CKB&#39;s configuration like mentioned here:
# https://docs.nervos.org/dev-guide/debugging-ckb-script.html#debug-syscall
# you can notice the failure lines in CKB&#39;s debug logs.
$ ./unlock_via_secret_string.js \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd \
    0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    &amp;quot;invalid secret&amp;quot; \
    true
Dry run failure result: {
  &amp;quot;code&amp;quot;: -3,
  &amp;quot;message&amp;quot;: &amp;quot;Error { kind: ValidationFailure(-2) ...}&amp;quot;
}

# Given the correct secret string but an invalid public key, this would still
# fail the validation:
$ ./unlock_via_secret_string.js \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd \
    0x63d86723e08f0f813a36ce6aa123bb2289d90680ae1e99d4de8cdb334553f24d \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    &amp;quot;i am a secret&amp;quot; \
    true
Dry run failure result: {
  &amp;quot;code&amp;quot;: -3,
  &amp;quot;message&amp;quot;: &amp;quot;Error { kind: ValidationFailure(-2) ...}&amp;quot;
}

# Now we&#39;ve tested unlocking by providing secret string, let&#39;s try unlocking
# via waiting enough time. In my setup, I have the following values:
# HTLC cell is packed in transaction:
# 0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4
# which is commited in block:
# 0x04539cff3e1a106773bc1ec35804340c0981804093ce8d7a17e9ebc37a3268ff
# whose block number is 399.
#
# I&#39;m gonna test it with block:
# 0xe93ebb311d156847fbcdc159d1fa3c38f12613121e51582272d909379c4d1a60
# whose block number is 409, and block:
# 0x665ccfab2d854afa035f4697a2301f2bad9d4aa86506090b104f8ed18772ca01
# whose block number is 510.
# Let&#39;s first try block 510 to verify that we can unlock the HTLC cell this way:
$ ./unlock_via_timeout.js \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd \
    0x63d86723e08f0f813a36ce6aa123bb2289d90680ae1e99d4de8cdb334553f24d \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    0x665ccfab2d854afa035f4697a2301f2bad9d4aa86506090b104f8ed18772ca01 \
    true
This method is only for demo, don&#39;t use it in production
Dry run success result: {
  &amp;quot;cycles&amp;quot;: &amp;quot;0x16c500ba&amp;quot;
  }
# Notice here we are unlocking using lock script hash:
# 0x63d86723e08f0f813a36ce6aa123bb2289d90680ae1e99d4de8cdb334553f24d
# which is different from unlocking by providing secret string.

# Now let&#39;s try block 409 here:
$ ./unlock_via_timeout.js \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd \
    0x63d86723e08f0f813a36ce6aa123bb2289d90680ae1e99d4de8cdb334553f24d \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    0xe93ebb311d156847fbcdc159d1fa3c38f12613121e51582272d909379c4d1a60 \
    true
Dry run failure result: {
  &amp;quot;code&amp;quot;: -3,
  &amp;quot;message&amp;quot;: &amp;quot;Error { kind: ValidationFailure(-2) ...}&amp;quot;
}
# As expected, this fails validatin, and if we check CKB&#39;s debug log(if you
# have enabled it), we can find log lines containing &amp;quot;Timeout period has not
# reached!&amp;quot;, proving our script works as expected.

# One final step would checking unlocking with enough waiting, but using the
# wrong public key.
$ ./unlock_via_timeout.js \
    0xf30e1e8989fc3a4cb1e52dacc85090f8ff74b05e008d636b8c9154f5c296e1f4 \
    0x7de8ea6b0d6cb9941e76976d1d55edf844c4fa81485e00fb8eba2d161b5830cd \
    0xd00c06bfd800d27397002dca6fb0993d5ba6399b4238b2f29ee9deb97593d2bc \
    &amp;quot;http://127.0.0.1:8114/&amp;quot; \
    0x665ccfab2d854afa035f4697a2301f2bad9d4aa86506090b104f8ed18772ca01 \
    true
Dry run failure result: {
  &amp;quot;code&amp;quot;: -3,
  &amp;quot;message&amp;quot;: &amp;quot;Error { kind: ValidationFailure(-2) ...}&amp;quot;
}
# As expected, this also fails validation.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice the generated transaction hashes might different in each different run. So make sure to adjust parameters to the cells as needed.&lt;/p&gt;
&lt;p&gt;This concludes our HTLC script runs as expected(well, excluding those vulnarable situations), hooray!&lt;/p&gt;
&lt;h1 id=&#34;compute-intensive-code-in-javascript&#34;&gt;Compute Intensive Code in JavaScript&lt;/h1&gt;
&lt;p&gt;Let&amp;rsquo;s jump back for a second. I&amp;rsquo;ve been avoiding doing signatue verification code in our HTLC script written in JavaScript here. You might notice we also use a very simple CRC32 hashing algorithm, instead of the more secure hashing algorithms such as blake2b. While one major reason I did, is for the simplicity of this post(if you read till this point you will notice this post is already insanely long!), it is still not recommended to do those operations in JavaScript since:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A crypto algorithm requires precise implementation, while I&amp;rsquo;m not saying you cannot do that, it certainly requires more care to build crypto algorithms in a higher-level language like JavaScript. It&amp;rsquo;s much better to leverage existing battle-tested libraries written in C or Rust.&lt;/li&gt;
&lt;li&gt;Crypto algorithms are typical compute intensive code, since we are running JavaScript code in duktape, it can easily slow your code by 10x or even 100x. A native implementation can be much faster and saves significant cycles on CKB.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Right now the &lt;a href=&#34;https://github.com/xxuejie/ckb-duktape&#34;&gt;duktape&lt;/a&gt; distribution used here only contains duktape with no external libraries. In the future I might add other distributions with certain crypto algorithms shipped together, such as secp256k1 and blake2b. This way you will be able to invoke fast and secure crypto algorithms well within JavaScript. But please also remember sometimes, the delegate patterns mentioned above might suit your use case better.&lt;/p&gt;
&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;
&lt;p&gt;I sincerely hope you have read till this far, instead of skipping it. This is a ridiculously long post, but it contains a lot of useful information when building scripts on CKB:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to prepare a debugging environment that aids writting the script&lt;/li&gt;
&lt;li&gt;How to build custom data structure in molecule format&lt;/li&gt;
&lt;li&gt;How to serialize/deserialize molecule data structures&lt;/li&gt;
&lt;li&gt;How to include external libraries on npm and pack a single JavaScript for CKB use&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While I might still add more posts to this series if I noticed interesting stuff to write, I&amp;rsquo;m sure the existing 7 posts in this series, together with &lt;a href=&#34;https://justjjy.com/Build-CKB-contract-with-Rust-part-1&#34;&gt;many&lt;/a&gt; &lt;a href=&#34;https://justjjy.com/CKB-contract-in-Rust-part-2-Rewrite-contract-with-ckb&#34;&gt;other&lt;/a&gt; &lt;a href=&#34;https://docs.nervos.org/dev-guide/debugging-ckb-script.html&#34;&gt;awesome&lt;/a&gt; &lt;a href=&#34;https://mp.weixin.qq.com/s/9cP_Qik-AsdpiqL-q0ac4w&#34;&gt;posts&lt;/a&gt; by my colleagues, have well prepared you to build awesome things on CKB. We are all prepared to amazed by the beautiful things you build on CKB :)&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Let&#39;s Build a Minimal Blockchain 2: Ultimate Upgradability</title>
        <link>https://xuejie.space/2020_02_08_lets_build_a_minimal_blockchain_ultimate_upgradability/</link>
        <pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_02_08_lets_build_a_minimal_blockchain_ultimate_upgradability/</guid>
        <description>&lt;p&gt;&lt;a href=&#34;../2019_10_21_lets_build_a_minimal_blockchain_dawn&#34;&gt;Last time&lt;/a&gt; I mentioned the very core of a blockchain: the block verification logic. This time, we will look at the bigger problem: everyone seems to be providing upgradable block verification logic, no matter it&amp;rsquo;s called &lt;code&gt;runtime&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt; or something else. But there&amp;rsquo;s more to just block verification, how can we ensure the ultimate upgradability of a blockchain?&lt;/p&gt;
&lt;h1 id=&#34;network-stack&#34;&gt;Network Stack&lt;/h1&gt;
&lt;p&gt;The network stack in a blockchain is one component that typically receives the least amount of changes after launch. It is usually left there unchanged, following &amp;ldquo;if it ain&amp;rsquo;t broke, don&amp;rsquo;t fix it&amp;rdquo; principle. Some of the reason might be compatibility needs, other reasons might also include security, etc. And when there is a change needed, you might encounter release notes &lt;a href=&#34;https://bitcoin.org/en/alert/2018-09-21-required-upgrade&#34;&gt;like following&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should not run any version of Bitcoin Core other than 0.16.3. Older versions should not exist on the network. If you know anyone who is running an older version, tell them to upgrade it as soon as possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Different people would have different interpretations here, many would argue this is not a problem. But personally I&amp;rsquo;m not so sure on this: manual intervention is required here to download the latest version of Bitcoin and upgrade the current version. For large organizations with sophisticated ops team, this might seem transparent. But for the many of us running nodes in home computer, manual invervention, while might be easy most of the time, is still work required. In addition, to people who just want a &lt;a href=&#34;https://keys.casa/lightning-bitcoin-node/&#34;&gt;plug-n-forget node&lt;/a&gt; running Bitcoin helping his/her business, manual work is always a hurdle. I know many will have different opinions but to me, this is some sort of &amp;ldquo;fork&amp;rdquo;, cuz forks, when looking from the ordinary eyes of end-user, is just upgrading to a newer version of software, which is no different from what the above release note requires people to do.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m not sure if this question is useful, but I have never seen people raising this question so I want to do it here: is it possible to have a blockchain node that can transparently upgrade network stack(and hopefully many other parts) without restarting the node? Can we truly have a piece of blockchain software that runs forever?&lt;/p&gt;
&lt;p&gt;First, I think we should talk about a totally different issue:&lt;/p&gt;
&lt;h1 id=&#34;native-languages-vs-image-based-languages&#34;&gt;Native Languages vs Image Based Languages&lt;/h1&gt;
&lt;p&gt;I don&amp;rsquo;t usually care for programming languages. I believe we do have far too many programming languages, many of which are only differs in the superficial syntaxes. But looking beyond that, there are still several different unique types of programming langauges, and the choices between them can make quite a big difference.&lt;/p&gt;
&lt;p&gt;In recent years, native languages, such as Rust, Go, Elixir are starting to make their revenges. With the development of type inference algorithms, native languages start to gain some of the benefits of dynamic languages, while at the same time providing better stories in terms of performance, as well as code maintainability. This is indeed an advancement in a sense, but on the other hand we are also losing one unique possibility that is (at least till now) only feasible in dynamic languages: the ability to alter code on the fly.&lt;/p&gt;
&lt;p&gt;While many of the toy grade dynamic languages do not offer this feature, almost hidden in the history there is a unique branch of programming languages named &lt;code&gt;image based languages&lt;/code&gt;. The way they work, is that a runtime environment is started first, then the environment could be used to run different applications, even new applications deployed on the fly. What this means, is that while some code could be packed together with the runtime environment (called an &lt;code&gt;image&lt;/code&gt;) to boot together, more code could be added on the fly which alter the application behavior. This means unlike a native language, an image based language could be used to provide upgradability.&lt;/p&gt;
&lt;p&gt;Unfortunately, most image based languages have either been a lost art or only filled in a niche environment. It is really hard to find an industry grade image based programming language that is not only used by die-core lovers, but I think we do still have one available.&lt;/p&gt;
&lt;h1 id=&#34;beam&#34;&gt;BEAM!&lt;/h1&gt;
&lt;p&gt;Now we are coming to the topic of this talk! I personally believe BEAM, which is the VM powers &lt;a href=&#34;http://erlang.org/&#34;&gt;Erlang&lt;/a&gt;/&lt;a href=&#34;https://elixir-lang.org/&#34;&gt;Elixir&lt;/a&gt;, can be a perfect fit for building blockchains. We have continuously talked about how we feel blockchains are exactly like hardware. Well it turns out BEAM has been used for years to build software for hardware that never stops, such as telephone switches. When putting into the best use, I do feel BEAM will have unique advantages for building blockchains:&lt;/p&gt;
&lt;h2 id=&#34;network-stack-1&#34;&gt;Network stack&lt;/h2&gt;
&lt;p&gt;Believe it or not, the original use for Erlang, is telephone switches with relays voice data from one wire to one of many other wires. If we wrap our head a bit, I personally feel this is exactly what the network stack in modern blockchain does:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You are maintaining a series of connections with other peers, telephone switches do that, check;&lt;/li&gt;
&lt;li&gt;From time to time, you receive a transaction/block, and wants to relay it to one or many different other locations, telephone switches do that and they even do something more: they have real-time requirements, check;&lt;/li&gt;
&lt;li&gt;You do want to minimize the downtime when it happens, telephone switches usually have legal contracts preventing downtime, check&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Besides those points, there are actually more that can be brought by BEAM:&lt;/p&gt;
&lt;h3 id=&#34;zero-downtime&#34;&gt;Zero Downtime&lt;/h3&gt;
&lt;p&gt;As mentioned above, telephone switches usually have legal contracts preventing downtime, they have to do hot upgrades with no downtime, which provides the exact benefit that we can upgrade the network stack of a blockchain, when powered by BEAM.&lt;/p&gt;
&lt;p&gt;In fact our requirements might not be as harsh as telephone switches, we could tolerate slight downtime, all we need to do is reduce manual human interventions. So we can do something simpler here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the initial handshake protocol, each peer includes its own protocol version;&lt;/li&gt;
&lt;li&gt;When a peer using a higher version protocol notices a lower version protocol, it sends the new upgraded network stack code to the other peer;&lt;/li&gt;
&lt;li&gt;When the peer with lower version protocol receives and validates(possibly via signature verification) the code, it reloads it current network stack, and runs the upgraded network stack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This means a reconnection might be needed when a node is upgrading its own network stack, but at least we are cutting the human intervention, and those who are really annoyed by this are well welcome to implement the full Erlang hot upgrading protocol, resulting in a real zero downtime upgrades.&lt;/p&gt;
&lt;h3 id=&#34;fairness&#34;&gt;Fairness&lt;/h3&gt;
&lt;p&gt;A telephone switch doesn&amp;rsquo;t run only one telephone line at a time, it runs numerous telephone lines simultaneously, and all of them should function smoothly without delays. That&amp;rsquo;s why BEAM treats fairness as the top priority when scheduling code running on it. It ensures all parts of the code gets a fair chance to run. This might sound counter-intuitive at first but it actually suits a blockchain stack quite well. Let me explain.&lt;/p&gt;
&lt;p&gt;In the network stack of many blockchains, there is an IBD(Initial Block Download) mode, and a normal mode. This is because when a node initially starts to sync, it needs to grab a lot of blocks, and we have to handle it specially, so it won&amp;rsquo;t affect other peers currently in a network. With a fairness scheduler, we might be able to simply the code, so a network stack without IBD can still handle initial node syncing as well as normal block syncing in a fairness way. Note this might be possible in other stacks, but the thing is: if we have a well-designed foundation that has this property developed and tested for years, why not embrace that instead of rolling one on our own?&lt;/p&gt;
&lt;h2 id=&#34;block-validation-logicand-others&#34;&gt;Block validation logic(and others)&lt;/h2&gt;
&lt;p&gt;People who know Erlang/Elixir well might start to object me: but Erlang/Elixir is slow in modern blockchain&amp;rsquo;s standard! You might never have a fast modern blockchain built with Erlang/Elixir!&lt;/p&gt;
&lt;p&gt;I totally agree with that, that&amp;rsquo;s why I believe the futures lies in a hybrid stack between a network stack via BEAM, and a native, fast language such as Rust that can unleash all potentials of a computer. BEAM is slow indeed, but the other side of story, is that network stack should never take a huge portion of the CPU time in a well-tuned application. I would personally argue 5% of the CPU time is well enough to perform all the networking stack in a modern blockchain, even when we are using Erlang/Elixir running on BEAM. You could use Rust however you want to unleash the beast in your computer for maximum blockchain performance.&lt;/p&gt;
&lt;p&gt;And yet there is still a way to ensure upgradability when using native Rust code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BEAM does provide a &lt;a href=&#34;http://erlang.org/doc/man/erl_nif.html&#34;&gt;way&lt;/a&gt; to perform upgrades on native code it uses. This means even though we are packing our block validation logic(and possibly many other parts, such as storage) in native code, it is still possible to perform hot upgrades on the native part without restarting the whole node. This means it&amp;rsquo;s easy to implement things like &amp;ldquo;when the block number reaches 600000, we will start using the new block validation rules&amp;rdquo;, and this could all work without any restarts to the whole application, a blockchain node can perfectly run forever as long as it needs.&lt;/li&gt;
&lt;li&gt;There will be people who are frightened by the need to dynamiclly run native code, or people who want to leverage more than one CPU architecture. It&amp;rsquo;s perfectly possible to leverage techniques mentioned in the &lt;a href=&#34;../2019_10_21_lets_build_a_minimal_blockchain_dawn&#34;&gt;previous post&lt;/a&gt;: one can pack the core block verification logic in RISC-V, and runs it in a CKB VM instance. That means for the most of the time, all you need to do, is upgrade the program running in the VM, you don&amp;rsquo;t have to touch the dangerous action of upgrading a whole module written in native code. This whole process still works.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ultimate-upgradability&#34;&gt;Ultimate Upgradability&lt;/h1&gt;
&lt;p&gt;People who know me will know that I&amp;rsquo;m a Gopher fan, and there was a time that I used to believe Go can be a quite decent fit for building blockchains. But lately I stopped thinking that way, I believe the future of blockchains lies in a hybrid solution between a BEAM powered network stack, and a native code module written (possibly) in Rust. The result here, will a blockchain that can truly runs forever without needs for any forks.&lt;/p&gt;
&lt;p&gt;And it&amp;rsquo;s actually not about forks, it&amp;rsquo;s just about minimizing human interventions. If I&amp;rsquo;m just a merchant using Bitcoin to accept payments, why should I care about forks? As long as bitcoin continuously works for me, I am not worried about how many forks it performs underneath. Right now people worries about forks since forks require them to upgrade their software at a certain time frame, if a blockchain supports transparent, seamless upgrades, I wonder if forks will still be so hard to perform.&lt;/p&gt;
&lt;p&gt;Some might call this imaginary features, but we are in a very early phase of the field, and we are seeing people throw the old blockchains and start from new all the time. Who knows the stack we have today will work tomorrow? Personally I believe that is a future that is worth to explore more.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 6: Type ID</title>
        <link>https://xuejie.space/2020_02_03_introduction_to_ckb_script_programming_type_id/</link>
        <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2020_02_03_introduction_to_ckb_script_programming_type_id/</guid>
        <description>&lt;p&gt;You might noticed there&amp;rsquo;s a &lt;code&gt;hash_type&lt;/code&gt; field in CKB&amp;rsquo;s Script structure. For simplicity, we&amp;rsquo;ve been ignoring that till now. This post will provide an introduction to the &lt;code&gt;hash_type&lt;/code&gt; field, and the unique capability it can bring.&lt;/p&gt;
&lt;h1 id=&#34;problem&#34;&gt;Problem&lt;/h1&gt;
&lt;p&gt;In the blockchain space, there&amp;rsquo;s a pair of issues that everyone has to pick sides:&lt;/p&gt;
&lt;h3 id=&#34;upgradability&#34;&gt;Upgradability&lt;/h3&gt;
&lt;p&gt;Can I upgrade a smart contract after it&amp;rsquo;s deployed on the blockchain? Suppose a smart contract gets widely adopted, then all of a sudden, someone notices a bug in the smart contract(sadly this will always happen in our industry), can we upgrade the smart contract to a fixed version without affecting all the users?&lt;/p&gt;
&lt;p&gt;A different scenario: as technology advances, there might be new algorithms that could be leveraged to build smart contracts that run faster. Can we upgrade existing smart contracts to benefit more users?&lt;/p&gt;
&lt;h3 id=&#34;determinism&#34;&gt;Determinism&lt;/h3&gt;
&lt;p&gt;This one has 2 parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Determinism A: if I pick a smart contract to guard my tokens, will my tokens stay safe(could be unlocked by me and only by me) in the future?&lt;/li&gt;
&lt;li&gt;Determinism B: if I sign a transaction now, and send it later, will my transaction still be accepted by the blockchain?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that a secure blockchain has more deterministic requirements than those mentioned here. I&amp;rsquo;m only including properties that relate to the discussed problem here.&lt;/p&gt;
&lt;h3 id=&#34;conflicts&#34;&gt;Conflicts&lt;/h3&gt;
&lt;p&gt;If we think about it, we could find that there&amp;rsquo;re always conflicts between upgradability and determinism:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If a smart contract could be upgraded, it might have different behaviors, hence enabling an attacker to unlock a cell, or disabling unlocking from the owner himself/herself.&lt;/li&gt;
&lt;li&gt;If a smart contract could be upgraded, an already signed transaction might run into different behaviors, resulting it be rejected by the blockchain.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Historically, there is only one side you can pick, and most existing blockchains have picked the side of determinism. The &amp;ldquo;code is law&amp;rdquo; idea thus becomes very famous in the blockchain space. But we all know software design is all about tradeoffs. Given certain situation, it might make sense to sacrifice slight determinism, in exchange for the ease of upgradability. For example, a large organization might have special security team monitoring potential vulnerabilities in smart contracts use by them. By granting them the ability to upgrade smart contracts, they have their own control in fixing vulnerabilities instead of waiting on someone. In the meantime, determinism property A won&amp;rsquo;t be an issue for them since they are in charge of their own cells and smart contracts.&lt;/p&gt;
&lt;p&gt;So now the question is: can we enable this new possibility in CKB? It turns out we can and this whole mechanism is already deployed in current mainnet CKB! But to understand the whole mechanism in CKB, we have to first take a look at some other ideas that support this mechanism.&lt;/p&gt;
&lt;p&gt;NOTE: I&amp;rsquo;m sure you will ask: does this mean you will sacrifice determinism in CKB? Let me assure you this feature is totally optional in CKB, you can perfectly practice &amp;ldquo;code is law&amp;rdquo; principle in CKB like in other blockchains. We are just hoping this unique feature will provide new possibilities for people who really need it.&lt;/p&gt;
&lt;h1 id=&#34;write-a-unique-type-script&#34;&gt;Write A Unique Type Script&lt;/h1&gt;
&lt;p&gt;Let&amp;rsquo;s first ask a question: how can we create a type script that ensures only one live cell in CKB can have that unique type script? By unique type script, we mean the whole type script structure, including code hash, hash type and args.&lt;/p&gt;
&lt;p&gt;Note that this question might seem irrelevant to script upgradability right now, but please bear with me, we will see how it will contribute to the final solution in CKB.&lt;/p&gt;
&lt;p&gt;Note if you have seen &lt;a href=&#34;../2019_09_06_introduction_to_ckb_script_programming_udt/&#34;&gt;my previous UDT article&lt;/a&gt;, you might already realize there is a solution. But if you haven&amp;rsquo;t, I do suggest to take a step back and think about how you can implement such a script on your own. It will be a really good learning experience.&lt;/p&gt;
&lt;p&gt;If you are ready, here&amp;rsquo;s the basic workflow of the script:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Count how many output cells use current type script, if there&amp;rsquo;s more than one cell with current type script, returns a failure return code;&lt;/li&gt;
&lt;li&gt;Count how many input cells use current type script, if there&amp;rsquo;s one input cell with current type script, returns a success return code;&lt;/li&gt;
&lt;li&gt;Use CKB syscall to read the first OutPoint in current transaction;&lt;/li&gt;
&lt;li&gt;If the OutPoint data read match the &lt;code&gt;args&lt;/code&gt; part of current type script, returns a success return code;&lt;/li&gt;
&lt;li&gt;Returns a failure return code otherwise.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Putting in simple C code, the script would look like following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;#34;blockchain.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;#34;ckb_syscalls.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;#define INPUT_SIZE 128
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;#define SCRIPT_SIZE 32768
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main() {
  uint64_t len = 0;
  &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; ret = ckb_load_cell(NULL, &amp;amp;len, 0, 1, CKB_SOURCE_GROUP_OUTPUT);
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_INDEX_OUT_OF_BOUND) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;  &lt;span style=&#34;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
  }

  len = 0;
  ret = ckb_load_cell(NULL, &amp;amp;len, 0, 0, CKB_SOURCE_GROUP_INPUT);
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_INDEX_OUT_OF_BOUND) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;  &lt;span style=&#34;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
  }

  &lt;span style=&#34;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
  &lt;span style=&#34;&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; input[INPUT_SIZE];
  uint64_t input_len = INPUT_SIZE;
  ret = ckb_load_input(input, &amp;amp;input_len, 0, 0, CKB_SOURCE_INPUT);
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ret;
  }
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (input_len &amp;gt; INPUT_SIZE) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -100;
  }

  &lt;span style=&#34;&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; script[SCRIPT_SIZE];
  len = SCRIPT_SIZE;
  ret = ckb_load_script(script, &amp;amp;len, 0);
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ret;
  }
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (len &amp;gt; SCRIPT_SIZE) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -101;
  }
  mol_seg_t script_seg;
  script_seg.ptr = (uint8_t *)script;
  script_seg.size = len;

  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (MolReader_Script_verify(&amp;amp;script_seg, false) != MOL_OK) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -102;
  }

  mol_seg_t args_seg = MolReader_Script_get_args(&amp;amp;script_seg);
  mol_seg_t args_bytes_seg = MolReader_Bytes_raw_bytes(&amp;amp;args_seg);

  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; ((input_len == args_bytes_seg.size) &amp;amp;&amp;amp;
      (memcmp(args_bytes_seg.ptr, input, input_len) == 0)) {
    &lt;span style=&#34;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
  }
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -103;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As explained in the UDT post, attackers will be prevented in several different directions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If an attacker tries to create a cell with the exactly same type script, there will be 2 cases:
a. A valid transaction will have different OutPoint data in the first input from the type script args;
b. If the user tries to duplicate type script args as the first transaction input, CKB will signal a double-spent error;&lt;/li&gt;
&lt;li&gt;If the attacker tries to use a different type script args, it will be a different type script by definition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This way, we can ensure a cell will have unique type script across all live cells in CKB. Considering each script has an associated hash, we will have a cell in CKB with its unique hash, or unique ID.&lt;/p&gt;
&lt;h1 id=&#34;resolving-scripts-in-ckb-transaction&#34;&gt;Resolving Scripts in CKB Transaction&lt;/h1&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how CKB resolves the script to run before the &lt;code&gt;hash type&lt;/code&gt; change:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CKB extracts &lt;code&gt;code hash&lt;/code&gt; value from the script structure to run.&lt;/li&gt;
&lt;li&gt;It loops through all dep cells, computes the hash of each dep cell data. If any dep cell data hash matches the specified &lt;code&gt;code hash&lt;/code&gt;, CKB uses the data in the found dep cell as the script to run.&lt;/li&gt;
&lt;li&gt;If no dep cell has data hash matching specified &lt;code&gt;code hash&lt;/code&gt;, CKB results in a validation error.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The upgradability problem, in fact lies in the way we test for dep cells. Right now we are testing against data hash, and when a script is upgraded, a different hash will be generated, the matching would fail. That brings a question: can we test for dep cells using a different solution? Is there something that can stay unchanged when the script is changed? Considering the actual script to run lives in a cell, we can rephrase the question in a different way:&lt;/p&gt;
&lt;p&gt;Is there something that can stay unchanged when a cell&amp;rsquo;s data get updated?&lt;/p&gt;
&lt;p&gt;We can use a script structure! Since lock script is typically used for signature verification, we can use a type script for this problem. A type script can stay perfectly unchanged when a cell&amp;rsquo;s data get changed. Hence we added &lt;code&gt;hash type&lt;/code&gt; field to CKB&amp;rsquo;s script structure, and modified the script resolving flow to the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For each dep cell, we extract the &lt;code&gt;test hash&lt;/code&gt; based on &lt;code&gt;hash type&lt;/code&gt; value in the script structure:
&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;hash type&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt;, the dep cell&amp;rsquo;s data hash is used as &lt;code&gt;test hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;hash type&lt;/code&gt; is &lt;code&gt;type&lt;/code&gt;, the dep cell&amp;rsquo;s type script hash is used as &lt;code&gt;test hash&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CKB extracts &lt;code&gt;code hash&lt;/code&gt; and &lt;code&gt;hash type&lt;/code&gt; values from the script structure to run&lt;/li&gt;
&lt;li&gt;If CKB finds a dep cell whose &lt;code&gt;test hash&lt;/code&gt; matches specified &lt;code&gt;code hash&lt;/code&gt;, CKB uses the data in the found dep cell as the scrip to run.&lt;/li&gt;
&lt;li&gt;If no dep cell has &lt;code&gt;test hash&lt;/code&gt; matching specified &lt;code&gt;code hash&lt;/code&gt;, CKB results in a validation error.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice the &lt;code&gt;hash type&lt;/code&gt; used here, is the value belonging to the script to run, not the values of scripts in a dep cell. You could perfectly have 2 inputs in a transaction, one using &lt;code&gt;data&lt;/code&gt; as &lt;code&gt;hash type&lt;/code&gt;, the other using &lt;code&gt;type&lt;/code&gt; as &lt;code&gt;hash type&lt;/code&gt;. Either one of them will use its own correct way to locate the correct cell.&lt;/p&gt;
&lt;p&gt;This way we have totally conquered determinism property A above, but for property B there will be some subtle affects, we will discuss those in more details below.&lt;/p&gt;
&lt;h1 id=&#34;putting-everything-together&#34;&gt;Putting Everything Together&lt;/h1&gt;
&lt;p&gt;There&amp;rsquo;s still one problem unsolved, there might still be an attack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A lock script L1 is stored in a cell C1 with type script T1&lt;/li&gt;
&lt;li&gt;Alice guards her cells via lock script L1 using &lt;code&gt;hash type&lt;/code&gt; as &lt;code&gt;type&lt;/code&gt;, by definition, she fills her script structure&amp;rsquo;s &lt;code&gt;code hash&lt;/code&gt; field with the hash of type script T1&lt;/li&gt;
&lt;li&gt;Bob creates a different cell C2 with a always success lock script L2, and also use the same type script T1&lt;/li&gt;
&lt;li&gt;Now Bob can use C2 as a dep cell to unlock Alice&amp;rsquo;s cell. CKB won&amp;rsquo;t be able to distinguish that Alice wants to use C1, while Bob provides C2. Both C1 and C2 use T1 as type script&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That teaches us a very important lesson: if you build a lock/type script and want people to leverage the upgradability property, you have to make sure to use a type script that is unique and unforgeable.&lt;/p&gt;
&lt;p&gt;Luckily, we just solved this problem! In the above we just developed a type script that can provide a unique type script hash in CKB. Combined together, this unique type script and &lt;code&gt;hash type&lt;/code&gt; feature in CKB provide a way to upgrade already deployed smart contracts.&lt;/p&gt;
&lt;h1 id=&#34;chicken-egg-problem&#34;&gt;Chicken Egg Problem&lt;/h1&gt;
&lt;p&gt;You might have noticed that CKB already implements such a script, named a &lt;a href=&#34;https://github.com/nervosnetwork/ckb/blob/2145e4e3adee46670b3c9411c4ac547fc76e3a23/script/src/type_id.rs&#34;&gt;type ID&lt;/a&gt; script. But unlike the other system scripts, this one is implemented purely in Rust outside of CKB VM. I&amp;rsquo;m sure you will have this rant: you said CKB VM is flexible, don&amp;rsquo;t you?&lt;/p&gt;
&lt;p&gt;I do have made that claim in many different occasions, and in fact I&amp;rsquo;ve shown you above a way to implement the type ID logic in C code that could be compiled and run in CKB VM. But the problem here, is that we are at a chicken-egg situation: if we implement the type ID script, should we make it upgradable? If so, what should we put in as its type script? And if it&amp;rsquo;s not upgradable, how can we make sure it&amp;rsquo;s free from bugs and all the other vulnerabilities?&lt;/p&gt;
&lt;p&gt;We thought hard on this question, and it really seems the easiest and safest solution, is to implement the type ID script via pure Rust, so we can deal with any potential situations in a more mature and experienced way.&lt;/p&gt;
&lt;p&gt;But unlike some other chains which keep provide discounts for builtin smart contracts, we do set a very large cycle cost on the type ID script to discourage the use of the builtin script. At mainnet, it is now set as 1 million cycles. This is much much larger than the same logic implemented on CKB VM, we are hoping one day there will be fully vetted and secure type ID script that everyone will use instead of using this builtin type ID script.&lt;/p&gt;
&lt;h1 id=&#34;trust-issue&#34;&gt;Trust Issue&lt;/h1&gt;
&lt;p&gt;We do want to mention this new feature is not without its drawbacks. You should really understand how it works and the tradeoffs involved before using it. This section tries to discuss all those considerations, but I do want to warn you it might still miss something, and you should use your own judgments.&lt;/p&gt;
&lt;h2 id=&#34;determinism-property-a&#34;&gt;Determinism Property A&lt;/h2&gt;
&lt;p&gt;The type ID solution does provide a way to solve property A: when a bug is discovered, it&amp;rsquo;s possible to fix the smart contracts without affecting existing cells using the same smart contracts. But it does require certain considerations:&lt;/p&gt;
&lt;h3 id=&#34;ownership&#34;&gt;Ownership&lt;/h3&gt;
&lt;p&gt;With a type ID solution, people might be able to steal your coin by hacking the cell containing smart contracts you use. Since typical cells are guarded by only one or more signatures, some human errors could cause major problems. Fundamentally, it&amp;rsquo;s a tradeoff situation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For the truly paranoid ones, they might want to stick to the old way of referencing a script via its own hash, not the type script hash of the containing cell. The &amp;ldquo;code is law&amp;rdquo; principle is fully enforced here. You will know exactly what can be used to unlock your cell, and it won&amp;rsquo;t change anytime in the future.&lt;/li&gt;
&lt;li&gt;For people willing to sacrifice a little bit, they can gain the ability to upgrade existing smart contracts for different benefits. But please do make sure to fully understand the lock script of the cell containing the script you use.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, if you look at the deployed system scripts in CKB&amp;rsquo;s mainnet, they all use type ID setup, but they all have their lock script&amp;rsquo;s code hash set to all zeros, meaning no one gets to change the lock script easily via a signature. We want to make sure there&amp;rsquo;s a need to change the default lock script, it will be via a fork agreed upon by the whole community, after all IMHO it really is the whole Nervos community that &lt;em&gt;owns&lt;/em&gt; CKB :P&lt;/p&gt;
&lt;p&gt;There is some initial ideas that you can use to guard the script contained in a cell. For example, in addition to type ID logic, the type script can also contains other logics to validate the actual script contained in its cell. For example, formal analysis methods might be used, or certain test cases can be provided in which the type script run the actual script against. Only when the analysis or the test cases pass, will one be able to change script contained in a cell. Though I must say this is just some priliminary ideas, much research and development work needs to be done to make this a reality.&lt;/p&gt;
&lt;h3 id=&#34;availability&#34;&gt;Availability&lt;/h3&gt;
&lt;p&gt;A different issue with type ID, is availability of the script. When you have a cell using a script with &lt;code&gt;hash type&lt;/code&gt; set as &lt;code&gt;data&lt;/code&gt;, you are not worried someone might destroy the used script, you can always redeploy the script on-chain then unlock your cell.&lt;/p&gt;
&lt;p&gt;But with a type ID solution, if something bad happens, and the cell with matching type script hash is destroyed, your cell will be locked forever, since your might never be able to build a cell with the same type script hash. There are some methods you can use, such as restricting the ability to destroy a cell with a type ID script but they all just mitigate the problem, not completely solving the problem.&lt;/p&gt;
&lt;h2 id=&#34;determinism-property-b&#34;&gt;Determinism Property B&lt;/h2&gt;
&lt;p&gt;We do want to mention that type ID does not provide a solution to property B. When you have a signed transaction, the behavior for this transaction won&amp;rsquo;t be changed with the upgrade of one smart contract.&lt;/p&gt;
&lt;p&gt;Though there is way that the type ID solution might affect an already signed transaction: if a transaction uses a script from cell, and the cell gets updated, the transaction will be render invalidated, since the cell referenced in the original OutPoint is already spent. But one could argue with the old referencing solution, this problem might also happen.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;So that&amp;rsquo;s all I know about type ID at the moment :) It certainly has its drawbacks, but we do believe it can be proved very useful for certain users. For other users, this will be completely optional, and you are perfectly ignoring this feature at all. It&amp;rsquo;s my hope that this new feature rarely seen in other blockchains, can provide a starting point to boost more possibilities.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Let&#39;s Build a Minimal Blockchain 1: Dawn</title>
        <link>https://xuejie.space/2019_10_21_lets_build_a_minimal_blockchain_dawn/</link>
        <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2019_10_21_lets_build_a_minimal_blockchain_dawn/</guid>
        <description>&lt;p&gt;This will be a different series from &lt;code&gt;Introduction to CKB Script Programming&lt;/code&gt;, so if you are more keen on CKB scripting, feel free to skip this one. But if you are interested in blockchain in general, this could also be an interesting one :)&lt;/p&gt;
&lt;p&gt;So it all started from an inception: if we look at current generation of blockchains, they are all rather complicated. Bitcoin is quite complex, Ethereum is even more so. And while CKB is (arguably) simpler than Ethereum, it&amp;rsquo;s still way more complicated than Bitcoin(but in a good way!). Coming from a &lt;a href=&#34;https://www.youtube.com/watch?v=tXVr2E1vfmk&#34;&gt;different background&lt;/a&gt;, I couldn&amp;rsquo;t help but wonder: is this level of complexity necessary? Is blockchain just so different, or are we deep down the mud of &lt;a href=&#34;https://www.youtube.com/watch?v=rI8tNMsozo0&#34;&gt;accidental complexity&lt;/a&gt;? Regardless, I&amp;rsquo;d like to find out the answers.&lt;/p&gt;
&lt;p&gt;While simplicity is a debatable question, there&amp;rsquo;re other parts of modern blockchain space that more likely need work. One particular problem, is monolithic. It&amp;rsquo;s very rare that a blockchain let&amp;rsquo;s you swap one part of it for a different implementation. For example, while &lt;a href=&#34;https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03189.html&#34;&gt;alternative networks&lt;/a&gt; might be possible, they are still in the minority, some already abandoned. Most other blockchains do not even have a second syncing protocol. While one could argue syncing protocol could more or less related to the security nature of one blockchain(which I still have my doubts), let&amp;rsquo;s look at one other component: why do I need to run a full transaction pool on my node? I&amp;rsquo;m neither an exchange or mining nodes on my own, can&amp;rsquo;t I just have a node that runs only necessary components, and rely on external services when I do need to send a transaction? Even when I have a transaction pool, it merely just relays transactions to other nodes, the transactions need to reach a mining pool before it can be mined, so why bother wasting resources on one&amp;rsquo;s own machine?&lt;/p&gt;
&lt;p&gt;Looking further, there&amp;rsquo;s additional problems that don&amp;rsquo;t get good answers: blockchains will be updated, whether you call it soft-forks or hard-forks, the inevitable result is that you have software that behaves differently based on the exact blocks you are processing. And slowly, your same codebase will be scattered with logics that behave differently across time, and it will be a pain maintaining such a codebase and all the knowledge in your head. Can modern software engineering &lt;a href=&#34;https://vimeo.com/108441214&#34;&gt;help&lt;/a&gt; with this?&lt;/p&gt;
&lt;p&gt;That brings us to this series: if we start freshly from a different angle, refine our scope carefully, what a minimal viable blockchain is gonna be like?&lt;/p&gt;
&lt;p&gt;I did some thinking on this problem, and to answer the above question, let&amp;rsquo;s back off a bit and think about this simpler question: what&amp;rsquo;s the crucial part in a blockchain?&lt;/p&gt;
&lt;p&gt;Personally, I believe the answer is merely the block verification logic. Literally everything else is just optional, you absolutely do not need a transaction pool, the syncing protocol could also be omitted as long as there&amp;rsquo;s a way to gather blocks. Miner, RPC, etc. can be someone else&amp;rsquo;s problem. Really at fundamental level, a blockchain only needs the block verification logic so as to function.&lt;/p&gt;
&lt;p&gt;Starting from there, we can build a blockchain core that verifies blocks. All it does, is accepting blocks, then signaling either new block updates, or fork switching. From there, we can build the surrounding tools all as plugins, such as syncing clients, transaction pools, miners, etc. There&amp;rsquo;s no need to have a single solution for each tool, as long as something works for its designed use case, it will be useful in this rich ecosystem. For example, mining pools might want to have priority syncing for blocks, while exchanges would want to optimize bandwidths for transactions.&lt;/p&gt;
&lt;p&gt;But that only answers one part of the problem, what about building maintainable blockchains? The root conflict here, is what we want our software to evolve, different logics are grown to handle blocks from different time. If we look carefully, there&amp;rsquo;s actual one construct in modern blockchains designed to cope of the evolution of time: virtual machines are used to enable new behaviors for tomorrow&amp;rsquo;s applications, but right now, virtual machines are mostly limited to transactions. What if we expand virtual machines to process the whole block? Will that bring any difference?&lt;/p&gt;
&lt;p&gt;And before you ask, yes of course, part of my inspiration comes from &lt;a href=&#34;https://substrate.dev/&#34;&gt;substrate&lt;/a&gt; and &lt;a href=&#34;https://solri.org/&#34;&gt;solri&lt;/a&gt;, but as the author of &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm&#34;&gt;CKB VM&lt;/a&gt;. Both substrate, and its choice of WASM feels needlessly complicated. While solri is a huge improvement over substrate, it&amp;rsquo;s still an on-going experiment, and part of me feel that we can aim at a more flexible runtime than solri. Hence I&amp;rsquo;ve come up with the initial scope of the still unnamed minimal blockchain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A block is just a series of bytes, the blockchain itself knows nothing about the block, not even its block hash.&lt;/li&gt;
&lt;li&gt;A program running in CKB VM is in charge of validating and accepting a new block.&lt;/li&gt;
&lt;li&gt;A transactional key-value interface will be provided to the program running in CKB VM for persisting data.&lt;/li&gt;
&lt;li&gt;The core shall only need to provide a pub/sub interface for new block updates as well as fork switching.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The beauty of this scheme, is that any handling of soft/hard forks, will just be simply swapping the program used the validate the blockchain. And your new program could be perfectly containing only logics for handling new code. There&amp;rsquo;s no need to persist old code forever in your codebase. Just like the first time you are reading &lt;a href=&#34;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-5.html#%25_chap_Temp_2&#34;&gt;SICP&lt;/a&gt;: pyramids are magnificant but static for thousands of years, but what you want is organisms which is chaos in a way but evolable for billions of years to come.&lt;/p&gt;
&lt;p&gt;One stretch goal I want, is an &lt;a href=&#34;https://arrow.apache.org/&#34;&gt;Arrow&lt;/a&gt;-style interface where zero copy streaming protocols can be encouraged. Serving blocks to other clients should never be consuming much resource from the sending end. Hopefully this can contribute to better network performance, cuz quite often block syncing is the slow part in modern blockchains.&lt;/p&gt;
&lt;p&gt;Notice I never mentioned whether this is a PoW or PoS blockchain, cuz that question really doesn&amp;rsquo;t make sense: first, while the title says &lt;code&gt;Build a Minimal Blockchain&lt;/code&gt;, this really is not about building a blockchain, it&amp;rsquo;s about building a set of tools that can make blockchains built with it simpler, more flexible and easily maintainable; second, since a program running in virtual machine handles blockchain verification, you are not limited to one side of the world! This could easily support an alternative implementation of permissionless PoW blockchains such as Bitcoin, Ethereum, or CKB; this could also be adapted to layer 2 PoS blockchains running together with Nervos CKB. It really is up to the programs to say what the current blockchain is.&lt;/p&gt;
&lt;p&gt;So that&amp;rsquo;s it for the introductory post, I really don&amp;rsquo;t know how this idea will go, I could be wrong and this could total fail, but one thing I could be sure, is that this surely will be an interesting voyage, I just hope this won&amp;rsquo;t take that long as the &lt;a href=&#34;https://voyager.jpl.nasa.gov/mission/status/&#34;&gt;voyager&lt;/a&gt; :P&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 5: Debugging</title>
        <link>https://xuejie.space/2019_10_18_introduction_to_ckb_script_programming_debugging/</link>
        <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2019_10_18_introduction_to_ckb_script_programming_debugging/</guid>
        <description>&lt;p&gt;Due to the fact that CKB script works at a much lower level than other smart contracts, the debugging story for CKB, has been quite a mysterious one. In this post, we will show how one can debug CKB scripts. As you will find out, debugging a CKB script is not so different from debugging your everyday program.&lt;/p&gt;
&lt;p&gt;This post is written based on current CKB Lina mainnet version now.&lt;/p&gt;
&lt;h1 id=&#34;debugging-c-programs-with-gdb&#34;&gt;Debugging C programs with GDB&lt;/h1&gt;
&lt;p&gt;The first solution to CKB script debugging, works with compiled languages such as C, Rust, etc. Perhaps you are used to writing C programs, and GDB is your best friend. You are wondering if debugging C programs with GDB is possible, and the answer, of course, is: yes, you can definitely debug your CKB script written in C via GDB! Let me show you how.&lt;/p&gt;
&lt;p&gt;First we have the same carrot example from my old posts:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;#34;ckb_syscalls.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;&#34;&gt;char&lt;/span&gt;* argv[]) {
  &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; ret;
  size_t index = 0;
  uint64_t len = 0;
  &lt;span style=&#34;&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; buffer[6];

  &lt;span style=&#34;font-weight:bold&#34;&gt;while&lt;/span&gt; (1) {
    len = 6;
    memset(buffer, 0, 6);
    ret = ckb_load_cell_data(buffer, &amp;amp;len, 0, index, CKB_SOURCE_OUTPUT);
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret == CKB_INDEX_OUT_OF_BOUND) {
      &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
    }

    &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; cmp = memcmp(buffer, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;, 6);
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (cmp) {
      &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }

    index++;
  }

  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I&amp;rsquo;ve made 2 changes to it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ve updated the script to make it compatible with CKB v0.23.0. In this version, we should be using &lt;code&gt;ckb_load_cell_data&lt;/code&gt; to fetch cell data.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;ve also introduced a slight bug to the code, so we can later try the debugging workflow. You might noticed it if you are familiar with C, but no need to worry if you missed it, I will explain it later.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As usual, let&amp;rsquo;s use our official toolchain to compile it to RISC-V code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ls
carrot.c
$ git clone https://github.com/nervosnetwork/ckb-system-scripts
$ cp ckb-system-scripts/c/ckb_*.h ./
$ ls
carrot.c  ckb_consts.h  ckb_syscalls.h  ckb-system-scripts/
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191012 bash
root@3efa454be9af:/# cd /code
root@3efa454be9af:/code# riscv64-unknown-elf-gcc carrot.c -g -o carrot
root@3efa454be9af:/code# exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice when I compile the script, I added &lt;code&gt;-g&lt;/code&gt; so as to generate debugging information which is quite useful in GDB. For a production script, you would almost always want to strip them out to save previous on-chain space.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s deploy the script to CKB. Have your CKB node running, and fire up to Ruby SDK:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; api = CKB::API.new
pry(main)&amp;gt; wallet = CKB::Wallet.from_hex(api, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;&amp;lt;your private key&amp;gt;&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; wallet2 = CKB::Wallet.from_hex(api, CKB::Key.random_private_key)
pry(main)&amp;gt; carrot_data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; carrot_data.bytesize
=&amp;gt; 19296
pry(main)&amp;gt; carrot_tx_hash = wallet.send_capacity(wallet2.address, CKB::Utils.byte_to_shannon(20000), CKB::Utils.bin_to_hex(carrot_data), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 21000)
pry(main)&amp;gt; carrot_data_hash = CKB::Blake2b.hexdigest(carrot_data)
pry(main)&amp;gt; carrot_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: carrot_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; carrot_cell_dep = CKB::Types::CellDep.new(&lt;span style=&#34;font-style:italic&#34;&gt;out_point&lt;/span&gt;: CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: carrot_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With carrot script on blockchain, we can create a transaction to test the carrot script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(100), &lt;span style=&#34;font-style:italic&#34;&gt;use_dep_group&lt;/span&gt;: &lt;span style=&#34;&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 5000)
pry(main)&amp;gt; tx.outputs[0].type = carrot_type_script
pry(main)&amp;gt; tx.cell_deps &amp;lt;&amp;lt; carrot_cell_dep
pry(main)&amp;gt; tx.witnesses[0] = &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;
pry(main)&amp;gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(tx)
CKB::&lt;span style=&#34;font-style:italic&#34;&gt;RPCError&lt;/span&gt;: jsonrpc &lt;span style=&#34;font-style:italic&#34;&gt;error&lt;/span&gt;: {&lt;span style=&#34;font-style:italic&#34;&gt;:code&lt;/span&gt;=&amp;gt;-3, &lt;span style=&#34;font-style:italic&#34;&gt;:message&lt;/span&gt;=&amp;gt;&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Script(ValidationFailure(-1))&amp;#34;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you checked the transaction carefully, you will noticed that none of the output cells has data starting with &lt;code&gt;carrot&lt;/code&gt;. However we still run into validation failure, it means our script must have a bug. Previously, you would run out of options here, you might go back to check the code, hoping you can see where it goes wrong. But that is not necessary now, you can just dump the transaction here, and feed it into a standalone CKB debugger to debug it!&lt;/p&gt;
&lt;p&gt;First, let&amp;rsquo;s dump the transaction together with its surrounding environment, into a local file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; CKB::MockTransactionDumper.new(api, tx).write(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot.json&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What you also need here, is to keep track of the carrot type script hash:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; carrot_type_script.compute_hash
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x039c2fba64f389575cdecff8173882b97be5f8d3bdb2bb0770d8a7e265b91933&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice depending on your environment you might get a different hash from what I have here.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s try &lt;a href=&#34;https://github.com/nervosnetwork/ckb-standalone-debugger&#34;&gt;ckb-standalone-debugger&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git clone https://github.com/nervosnetwork/ckb-standalone-debugger
$ cd ckb-standalone-debugger/bins
$ cargo build --release
$ ./target/release/ckb-debugger -l 0.0.0.0:2000 -g type -h 0x039c2fba64f389575cdecff8173882b97be5f8d3bdb2bb0770d8a7e265b91933 -t carrot.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Keep in mind you might need to tweak the carrot type script hash, or the path to &lt;code&gt;carrot.json&lt;/code&gt; depending on your environment. Now we can try connecting to the debugger via GDB in a differnet terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191012 bash
root@66e3b39e0dfd:/# cd /code
root@66e3b39e0dfd:/code# riscv64-unknown-elf-gdb carrot
GNU gdb (GDB) 8.3.0.20190516-git
Copyright (C) 2019 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
Reading symbols from carrot...
(gdb) target remote 192.168.1.230:2000
Remote debugging using 192.168.1.230:2000
0x00000000000100c6 in _start ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice &lt;code&gt;192.168.1.230&lt;/code&gt;, is the IP address of my workstation in my local network. It&amp;rsquo;s very likely you need to adjust that, since your computer might have a different IP address. Now we can try a normal GDB debugging session:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) b main
Breakpoint 1 at 0x106b0: file carrot.c, line 6.
(gdb) c
Continuing.

Breakpoint 1, main (argc=0, argv=0x400000) at carrot.c:6
6         size_t index = 0;
(gdb) n
7         uint64_t len = 0;
(gdb) n
11          len = 6;
(gdb) n
12          memset(buffer, 0, 6);
(gdb) n
13          ret = ckb_load_cell_data(buffer, &amp;amp;len, 0, index, CKB_SOURCE_OUTPUT);
(gdb) n
14          if (ret == CKB_INDEX_OUT_OF_BOUND) {
(gdb) n
18          int cmp = memcmp(buffer, &amp;quot;carrot&amp;quot;, 6);
(gdb) n
19          if (cmp) {
(gdb) p cmp
$1 = -99
(gdb) p buffer[0]
$2 = 0 &#39;\000&#39;
(gdb) n
20            return -1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we can see where it goes wrong: the first byte in &lt;code&gt;buffer&lt;/code&gt; has value &lt;code&gt;0&lt;/code&gt;, which is different from &lt;code&gt;c&lt;/code&gt;, hence our buffer is different from &lt;code&gt;carrot&lt;/code&gt;. But instead of jumping to next iteration, the condition &lt;code&gt;if (cmp) {&lt;/code&gt; jumps to the true case, where &lt;code&gt;-1&lt;/code&gt; is returned, indicating a match to &lt;code&gt;carrot&lt;/code&gt;! And the reason to this, is that &lt;code&gt;memcmp&lt;/code&gt; would return &lt;code&gt;0&lt;/code&gt; when the 2 buffers are equal, and non-zero value when they are not. But instead of testing the return value of &lt;code&gt;memcmp&lt;/code&gt; is 0, we directly use it in the &lt;code&gt;if&lt;/code&gt; condition, since C would treat any non-zero value as true, &lt;code&gt;-99&lt;/code&gt; in this case would be treated as true. This is a typical C mistake for beginners, I hope you will never run into it :)&lt;/p&gt;
&lt;p&gt;Now we know the reason, it will be a trivial task to fix the bug in the carrot script, but what you just see here, is that we manage to dump the runtime state of an errored transaction from CKB, then debug it via GDB, which is a common tool in the industry! And your existing workflows and tools on top of GDB can also work here, isn&amp;rsquo;t that beautiful?&lt;/p&gt;
&lt;h1 id=&#34;repl-based-developmentdebugging&#34;&gt;REPL based Development/Debugging&lt;/h1&gt;
&lt;p&gt;However, GDB is only one part of the story in modern software development. Dynamic languages have largely taken the landscape, and many programmers are used to REPL baesd development/debugging workflow. This is totally different from GDB in a compiled languages, basically what you get is a running environment, and you can type in any code you want to interact with the environment, getting different results. As we will show here, CKB also has support for this type of development/debugging workflow :P&lt;/p&gt;
&lt;p&gt;Here we will use the &lt;a href=&#34;https://github.com/nervosnetwork/ckb-duktape&#34;&gt;ckb-duktape&lt;/a&gt; showcasing a REPL in JavaScript. But keep in mind this is merely a demo showing the workflow, there&amp;rsquo;s nothing preventing you from porting your favorite dynamic languages(whether it&amp;rsquo;s Ruby, Python, Lisp, etc.) to CKB, and start a REPL for that language.&lt;/p&gt;
&lt;p&gt;First let&amp;rsquo;s try compiling duktape:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git clone https://github.com/nervosnetwork/ckb-duktape
$ cd ckb-duktape
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191012 bash
root@982d1e906b76:/# cd /code
root@982d1e906b76:/code# make
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/entry.c -c -o build/entry.o
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror duktape/duktape.c -c -o build/duktape.o
riscv64-unknown-elf-gcc build/entry.o build/duktape.o -o build/duktape -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/repl.c -c -o build/repl.o
riscv64-unknown-elf-gcc build/repl.o build/duktape.o -o build/repl -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
root@982d1e906b76:/code# exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will need the &lt;code&gt;build/repl&lt;/code&gt; binary generated here. Similar to the carrot example, let&amp;rsquo;s first deploy duktape REPL binary on CKB:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; api = CKB::API.new
pry(main)&amp;gt; wallet = CKB::Wallet.from_hex(api, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;&amp;lt;your private key&amp;gt;&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; wallet2 = CKB::Wallet.from_hex(api, CKB::Key.random_private_key)
pry(main)&amp;gt; duktape_repl_data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;build/repl&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; duktape_repl_data.bytesize
=&amp;gt; 283048
pry(main)&amp;gt; duktape_repl_tx_hash = wallet.send_capacity(wallet2.address, CKB::Utils.byte_to_shannon(300000), CKB::Utils.bin_to_hex(duktape_repl_data), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 310000)
pry(main)&amp;gt; duktape_repl_data_hash = CKB::Blake2b.hexdigest(duktape_repl_data)
pry(main)&amp;gt; duktape_repl_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: duktape_repl_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; duktape_repl_cell_dep = CKB::Types::CellDep.new(&lt;span style=&#34;font-style:italic&#34;&gt;out_point&lt;/span&gt;: CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: duktape_repl_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We will also need to create a transaction containing the duktape script, I&amp;rsquo;m building a simpler one, but you are free to include more data so you can play with CKB:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(100), &lt;span style=&#34;font-style:italic&#34;&gt;use_dep_group&lt;/span&gt;: &lt;span style=&#34;&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 5000)
pry(main)&amp;gt; tx.outputs[0].type = duktape_repl_type_script
pry(main)&amp;gt; tx.cell_deps &amp;lt;&amp;lt; duktape_repl_cell_dep
pry(main)&amp;gt; tx.witnesses[0] = &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s also dump it to file, and check out duktape type script hash:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; CKB::MockTransactionDumper.new(api, tx).write(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;duktape.json&amp;#34;&lt;/span&gt;)
=&amp;gt; 2765824
pry(main)&amp;gt; duktape_repl_type_script.compute_hash
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0xa8b79392c857e29cb283e452f2cd48a8e06c51af64be175e0fe0e2902c482837&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Different from last time, we don&amp;rsquo;t need to start GDB, we can start the program directly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ./target/release/ckb-debugger -g type -h 0xa8b79392c857e29cb283e452f2cd48a8e06c51af64be175e0fe0e2902c482837 -t duktape.json
duk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will see a &lt;code&gt;duk&amp;gt;&lt;/code&gt; prompt for you to enter JS code! Again if you run into errors, check if you need to change to a different type script hash, or use the correct path to &lt;code&gt;duktape.json&lt;/code&gt;. We can see normal JS code works here:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;duk&amp;gt; print(1 + 2)
3
= undefined
duk&amp;gt; &lt;span style=&#34;font-weight:bold&#34;&gt;function&lt;/span&gt; foo(a) { &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; a + 1; }
= undefined
duk&amp;gt; foo(123)
= 124
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There&amp;rsquo;re also CKB related functions you can use:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;duk&amp;gt; var hash = CKB.load_script_hash()
= undefined
duk&amp;gt; &lt;span style=&#34;font-weight:bold&#34;&gt;function&lt;/span&gt; buf2hex(buffer) { &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; Array.prototype.map.call(new Uint8Array(buffer), &lt;span style=&#34;font-weight:bold&#34;&gt;function&lt;/span&gt;(x) { &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;00&amp;#39;&lt;/span&gt; + x.toString(16)).slice(-2); }).join(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;); }
= undefined
duk&amp;gt; buf2hex(hash)
= a8b79392c857e29cb283e452f2cd48a8e06c51af64be175e0fe0e2902c482837
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice the script hash we get here is exactly the current executing type script hash! This verifies CKB syscalls do work here, we can also try more interesting stuff&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;duk&amp;gt; print(CKB.SOURCE.OUTPUT)
2
= undefined
duk&amp;gt; print(CKB.CELL.CAPACITY)
0
= undefined
duk&amp;gt; capacity_field = CKB.load_cell_by_field(0, 0, CKB.SOURCE.OUTPUT, CKB.CELL.CAPACITY)
= [object ArrayBuffer]
duk&amp;gt; buf2hex(capacity_field)
= 00e40b5402000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This &lt;code&gt;00e40b5402000000&lt;/code&gt; might looks slightly mysterious to you at first, but notice that RISC-V uses little endian, so if we reverse the byte order here, we would get &lt;code&gt;00000002540be400&lt;/code&gt;, which is exactly &lt;code&gt;10000000000&lt;/code&gt; in decimal. Also keep in mind that in CKB capacity is stored in shannons, so &lt;code&gt;10000000000&lt;/code&gt; is exactly &lt;code&gt;100&lt;/code&gt; bytes, which is the same amount of coins we want to transfer when we generate the transaction above! Now you can see how you can play with CKB in this duktape environment :)&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Now we&amp;rsquo;ve introduced 2 types of debugging experience in CKB, feel free to play with either one you like(or actually both of them). I can&amp;rsquo;t wait to see all the amazing applications you can build with CKB :)&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 4: WebAssembly on CKB</title>
        <link>https://xuejie.space/2019_10_09_introduction_to_ckb_script_programming_wasm_on_ckb/</link>
        <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2019_10_09_introduction_to_ckb_script_programming_wasm_on_ckb/</guid>
        <description>&lt;p&gt;Since we made the choice to build CKB&amp;rsquo;s virtual machine with RISC-V, we&amp;rsquo;ve been getting a question almost everyday: why don&amp;rsquo;t you build your virtual machine on WebAssembly like everyone else does?&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;re many reasons behind this choice, making it a perfect choice for another article or even a conference talk. But fundamentally there lies one important reason: building software is all about finding the right abstraction, and we believe RISC-V is a better abstraction than WebAssembly for public permissionless blockchain.&lt;/p&gt;
&lt;p&gt;While WebAssembly is already a huge advancement over higher level programming langauges as well as the first generation blockchain virtual machines, RISC-V works at a much lower level than WebAssembly, making it a more suitable choice for public blockchains which are designed to run for decades to come.&lt;/p&gt;
&lt;p&gt;But that still leaves one question unanswered: a significant portion of the blockchain industry is betting on WebAssembly, contributing an (arguably) better ecosystem building on WebAssembly powered dapps. How can CKB compete with that? As mentioned above, RISC-V is actually a lower level of abstraction than WebAssembly, we can port existing WebAssembly programs, and run them on CKB VM directly. This way, we can enjoy the flexibility and stability provided by RISC-V, while also embracing the WebAssembly ecosystem.&lt;/p&gt;
&lt;p&gt;In this article, we will show how you can run WebAssembly programs in CKB VM, we will also show that it actually has more benefits running this way than directly using a WebAssembly VM.&lt;/p&gt;
&lt;p&gt;Personally, while I believe WebAssembly has some interesting features enabling different use cases, I don&amp;rsquo;t believe WebAssembly has a better ecosystem in the blockchain space. If you look around, there are probably just 2 mature choices for building dapps in a WebAssembly-based blockchain: Rust, and AssemblyScript. People keep bragging about WebAssembly&amp;rsquo;s ability to support arbitrary languages in a single abstract VM(I personally refuse to call WebAssembly low-level VM), but it really just comes down to one of the 2 choices here to build a real dapp. I think we probably have different definitions if we can call 2 supported languages a good VM ecosystem. There are some &lt;a href=&#34;https://github.com/tweag/asterius&#34;&gt;other languages&lt;/a&gt; playing catching up here, but they are not yet at stable phase to count as a richful ecosystem. While some &lt;a href=&#34;https://github.com/forest-lang/forest-compiler&#34;&gt;interesting langauges&lt;/a&gt; have potentials in a WebAssembly based environment, no one pays attention to support them. And if you look hard enough, it also remains a question if 2 different blockchains using WebAssembly can share contracts with each other. Of course one might say: &amp;ldquo;well it&amp;rsquo;s just a matter of time, given time more vibrant WebAssembly ecosystem will sprout&amp;rdquo;, but the same argument could apply anywhere: why given time, an ecosystem for RISC-V won&amp;rsquo;t be better?&lt;/p&gt;
&lt;p&gt;But enough for the rant, let&amp;rsquo;s just assume for now, WebAssembly does have a blockchain ecosystem, we can show that the 2 widely used choices, AssemblyScript and Rust, are all supported in a CKB VM environment.&lt;/p&gt;
&lt;h1 id=&#34;assemblyscript&#34;&gt;AssemblyScript&lt;/h1&gt;
&lt;p&gt;I believe no words speak better than a demo you can play with. So let&amp;rsquo;s try the official AssemblyScript and run the compiled program on CKB. We will just use the official example in AssemblyScript&amp;rsquo;s &lt;a href=&#34;https://docs.assemblyscript.org/&#34;&gt;introduction page&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat fib.ts
export function fib(n: i32): i32 {
  var a = 0, b = 1;
    for (let i = 0; i &amp;lt; n; i++) {
        let t = a + b; a = b; b = t;
  }
  return b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please refer to AssemblyScript&amp;rsquo;s documentation on how to install it. For convenience, I have some steps that you can just copy-paste here.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/AssemblyScript/assemblyscript.git
$ cd assemblyscript
$ npm install
$ bin/asc ../fib.ts -b ../fib.wasm -O3
$ cd ..
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have a compiled WebAssembly program to use here. What we can do then, is invoke a program named &lt;a href=&#34;https://github.com/WebAssembly/wabt/tree/master/wasm2c&#34;&gt;wasm2c&lt;/a&gt; to compile it to C source file, then compile it via a RISC-V compiler to a RISC-V program, and run it on CKB VM.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m sure you would ask: but this is a hack! It sort of does a decompilation of the WASM program then make it work, you are cheating here. The answer to this question, is yes and no:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On the one hand, yes I&amp;rsquo;m cheating here, but the question I&amp;rsquo;m gonna raise in response is: all we should care, is the end result, if the result is good enough, why should we care if this is cheating? In addition, modern compiler is already complicated enough like a total black box, how can we be sure this decompilation will achieve worse result?&lt;/li&gt;
&lt;li&gt;On the other hand, this is just one way of transforming WebAssembly into RISC-V. There&amp;rsquo;re numerous other ways in which you can achieve the same result. We will come back to this in the Recap section later.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s fire up &lt;code&gt;wasm2c&lt;/code&gt; and transform the WebAssembly program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/WebAssembly/wabt
$ cd wabt
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
$ cd ../..
$ wabt/bin/wasm2c fib.wasm -o fib.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You will see a pair of &lt;code&gt;fib.c&lt;/code&gt; and &lt;code&gt;fib.h&lt;/code&gt; file in current directory, they contain the transformation result of the WebAssembly program, and when compiled and called correctly, they will achieve the same feature as the WebAssembly program.&lt;/p&gt;
&lt;p&gt;We can use a small wrapper C file to invoke the WebAssembly program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat main.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#include &amp;quot;fib.h&amp;quot;

int main(int argc, char** argv) {
  if (argc &amp;lt; 2) return 2;

  u8 x = atoi(argv[1]);

  init();

  u8 result = Z_fibZ_ii(x);

  return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This just reads an integer from a CLI argument, invokes the fibonacci function in the WebAssembly program, then return the result. Let&amp;rsquo;s try compile it first:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
(docker) $ cd /code
(docker) $ riscv64-unknown-elf-gcc -o fib_riscv64 -O3 -g main.c fib.c /code/wabt/wasm2c/wasm-rt-impl.c -I /code/wabt/wasm2c
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `__retain&#39;:
/code/fib.c:1602: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `i32_load&#39;:
/code/fib.c:42: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `f17&#39;:
/code/fib.c:1564: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/fib.c:1564: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `f6&#39;:
/code/fib.c:1011: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o:/code/fib.c:1012: more undefined references to `Z_envZ_abortZ_viiii&#39; follow
collect2: error: ld returned 1 exit status
(docker) $ exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As shown above, there&amp;rsquo;s an error here. It tells us there&amp;rsquo;s an &lt;code&gt;Z_envZ_abortZ_viiii&lt;/code&gt; function not defined. Let&amp;rsquo;s dive into why this happened.&lt;/p&gt;
&lt;p&gt;First, let&amp;rsquo;s transform the original WebAssembly file into a human readable form:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wabt/bin/wasm2wat fib.wasm -o fib.wast
$ cat fib.wast | grep &amp;quot;(import&amp;quot;
(import &amp;quot;env&amp;quot; &amp;quot;abort&amp;quot; (func (;0;) (type 2)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So the problem is that WebAssembly can import external functions, when invoking, provides additional functionalities. In fact, the famous &lt;a href=&#34;https://wasi.dev/&#34;&gt;WASI&lt;/a&gt; is implemented based on the &lt;code&gt;import&lt;/code&gt; feature. Later we shall see &lt;code&gt;import&lt;/code&gt; can be used to implement more interesting features that are not possible in WebAssembly based blockchain virtual machines.&lt;/p&gt;
&lt;p&gt;For now, let&amp;rsquo;s provide an abort implementation to fix the error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat main.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#include &amp;quot;fib.h&amp;quot;

void (*Z_envZ_abortZ_viiii)(u32, u32, u32, u32);

void env_abort(u32 a, u32 b, u32 c, u32 d) {
  abort();
}

int main(int argc, char** argv) {
  if (argc &amp;lt; 2) return 2;

  u8 x = atoi(argv[1]);

  Z_envZ_abortZ_viiii = &amp;amp;env_abort;

  init();

  u8 result = Z_fibZ_ii(x);

  return result;
}
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
(docker) $ cd /code
(docker) $ riscv64-unknown-elf-gcc -o fib_riscv64 -O3 -g main.c fib.c /code/wabt/wasm2c/wasm-rt-impl.c -I /code/wabt/wasm2c
(docker) $ exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course you can test the compiled &lt;code&gt;fib_riscv64&lt;/code&gt; program on CKB. But as a trick, there&amp;rsquo;s a simple CKB VM &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm-test-suite/tree/master/binary/src&#34;&gt;binary&lt;/a&gt; in the &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm-test-suite&#34;&gt;test suite&lt;/a&gt; we can use the run this particular program. It&amp;rsquo;s worth mentioning that this CKB VM binary works slightly different from the VM in CKB. It suffices to test WebAssembly programs in current example. But for testing proper CKB script, you might want to use the newly built &lt;a href=&#34;https://github.com/nervosnetwork/ckb-standalone-debugger&#34;&gt;standalone debugger&lt;/a&gt;, which follows all CKB semantics. Later posts will explain how the debugger works.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s try compile the binary in test suite and run the program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/nervosnetwork/ckb-vm-test-suite
$ cd ckb-vm-test-suite
$ git clone https://github.com/nervosnetwork/ckb-vm
$ cd binary
$ cargo build --release
$ cd ../..
$ ckb-vm-test-suite/binary/target/release/asm64 fib_riscv64 5
Error result: Ok(8)
$ ckb-vm-test-suite/binary/target/release/asm64 fib_riscv64 10
Error result: Ok(89)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The error here is slightly misleading, the binary will treat any non-zero result from the program as errors. Since the program tested return the fibonacci calculation result as the return value, the binary will treat the return value(which is most likely non-zero) as error, but we can see that the actual error value contains the correct fibonacci value.&lt;/p&gt;
&lt;p&gt;Now we proves AssemblyScript program indeed works on CKB VM! I&amp;rsquo;m sure more complicated programs might run into errors which need separate tweaking, but you already get the workflow and know where to look for when error happens :)&lt;/p&gt;
&lt;h1 id=&#34;rust&#34;&gt;Rust&lt;/h1&gt;
&lt;p&gt;We&amp;rsquo;ve already seen simpler examples in the AssemblyScript part. Let&amp;rsquo;s try something more interesting in the Rust part: can we do a whole signature verification in Rust code?&lt;/p&gt;
&lt;p&gt;Turns out yes we can! But this is signficantly more than what we can fit in a blog post. I&amp;rsquo;ve prepared a &lt;a href=&#34;https://github.com/nervosnetwork/wasm-secp256k1-test&#34;&gt;demo project&lt;/a&gt; showcasing this. It uses a pure Rust implemented &lt;a href=&#34;https://github.com/paritytech/libsecp256k1&#34;&gt;secp256k1 library&lt;/a&gt; to do signature verification. If you follow the instructions in the README, you can reproduce the exact steps of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compile a complicated Rust program into WebAssembly&lt;/li&gt;
&lt;li&gt;Transform the WebAssembly program into RISC-V&lt;/li&gt;
&lt;li&gt;Run the resulting RISC-V program on CKB VM&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;enhancements-to-webassembly&#34;&gt;Enhancements to WebAssembly&lt;/h1&gt;
&lt;p&gt;There&amp;rsquo;s one additional thing we want to mention: if you check out the &lt;code&gt;bindgen&lt;/code&gt; branch of the &lt;a href=&#34;https://github.com/nervosnetwork/wasm-secp256k1-test/tree/bindgen&#34;&gt;Rust secp256k1 demo repository&lt;/a&gt;, and try the same steps, you will run into the following errors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `core::result::unwrap_failed&#39;:
/code/secp.c:342: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:344: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:344: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:347: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:350: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o:/code/secp.c:353: more undefined references to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39; follow
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_store&#39;:
/code/secp.c:56: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_load&#39;:
/code/secp.c:42: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_store&#39;:
/code/secp.c:56: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:56: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_load&#39;:
/code/secp.c:42: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_growZ_ii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:42: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_growZ_ii&#39;
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Following the same steps in the AssemblyScript examples, we can certain &lt;code&gt;imports&lt;/code&gt; in the WebAssembly file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wabt/bin/wasm2wat wasm_secp256k1_test.wasm -o secp.wat
$ cat secp.wat | grep &amp;quot;(import&amp;quot;
(import &amp;quot;__wbindgen_placeholder__&amp;quot; &amp;quot;__wbindgen_describe&amp;quot; (func $__wbindgen_describe (type 3)))
(import &amp;quot;__wbindgen_anyref_xform__&amp;quot; &amp;quot;__wbindgen_anyref_table_grow&amp;quot; (func $__wbindgen_anyref_table_grow (type 4)))
(import &amp;quot;__wbindgen_anyref_xform__&amp;quot; &amp;quot;__wbindgen_anyref_table_set_null&amp;quot; (func $__wbindgen_anyref_table_set_null (type 3)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Those are actually binding environment functions needed in the Rust &lt;a href=&#34;https://github.com/rustwasm/wasm-bindgen&#34;&gt;wasm-bindgen&lt;/a&gt;. We will continue to work to provide the bindings compatible with CKB environment. But let&amp;rsquo;s take a step back and think about this now: the environment functions needed here, are not part of WebAssembly standard. What&amp;rsquo;s required in the standard, is that when an import entry cannot be found, the WebAssembly VM is expected to halt execution with an errors. To achieve different features, different WebAssembly based blockchains might inject different imports here, making it hard to write a WebAssembly program that&amp;rsquo;s compatible across different blockchains.&lt;/p&gt;
&lt;p&gt;In the CKB environment, however, we can attach any environment functions as we like, hence supporting all WebAssembly programs which are targeting different blockchains. What&amp;rsquo;s more, we can use &lt;code&gt;imports&lt;/code&gt; as we like to introduce new features to an existing WebAssembly programs, since the import functions are shipped together with the WebAssembly program, CKB itself doesn&amp;rsquo;t have to do anything to support this, all the magic happens right within a single CKB script. For a WebAssembly powered blockchain, those environment functions are most likely to be fixed and part of the consensus rules, you cannot introduce new ones as you wish. Similarly, this tranformation based workflow on CKB will make it far easier to support new WebAssembly features, such as garbage collection, or threading, it really is just a matter of shipping the support features you need as part of your CKB script, there&amp;rsquo;s no need to wait another 6 months for the next hardfork when a WebAssembly virtual machine gets updated, if it&amp;rsquo;s updated.&lt;/p&gt;
&lt;h1 id=&#34;its-about-ease-of-implementation&#34;&gt;It&amp;rsquo;s About Ease of Implementation&lt;/h1&gt;
&lt;p&gt;You might have one question: &amp;ldquo;I get it, you have WebAssembly on RISC-V, but I could also have RISC-V on WebAssembly! WebAssembly is flexible!&amp;rdquo;. In a sense, this is true, once a language or a VM surpasses a certain level of flexibility, it can be used to build many (even crazy) things. The first version of &lt;a href=&#34;https://bellard.org/jslinux/tech.html&#34;&gt;jslinux&lt;/a&gt; which emulates full x86 was even written in pure JavaScript! But the other side of the problem, is ease of implementation. Building WebAssembly on RISC-V feels more natural, since WebAssembly abstracts at a higher level with many high level features, such as higher level contrl flows, garbage collection, etc. RISC-V, on the other hand, really emulates what a real CPU can do, it is a very thin layer on top of the actual CPU running inside of the computer. So while both directions are possible indeed, certain features are easier to implement in the WebAssembly on RISC-V direction, while roadblocks might sit in front of you in the RISC-V on WebAssembly direction.&lt;/p&gt;
&lt;p&gt;One alternative example is EVM, EVM has been advocating turing complete for years, but the sad truth is that it&amp;rsquo;s close to impossible to build arbitrary complicated algorithsm on EVM: either the coding part is too difficult or gas consumption will be unreasonable. People have to come up with all kinds of hacks so as to introduce latest algorithms on EVM, we can only have reasonable blake2b algorithms in EVM when Istanbul hardfork lands. What about many other algorithms?&lt;/p&gt;
&lt;p&gt;All of those reflect our rationale behind the RISC-V choice: we want to find the minimal layer on top of this generation&amp;rsquo;s CPU architecture, and RISC-V is the most transparent model we can expose to the blockchain world while ensuring security and performance. Any different models, such as WebAssembly, EVM, etc., should be one layer on top of the RISC-V model, and can be naturally implemented via the RISC-V model. The other direction, however, might not feel so smooth at all.&lt;/p&gt;
&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Here we demonstrated that you can run non-trivial WebAssembly programs on CKB VM. But we do want to point out this workflow is not without its problems. One gotcha is performance, our preliminary testing shows that the WebAssembly based secp256k1 demo runs 30 times slower than a similar C based implementation compiled directly to CKB VM. After some investigation, we believe this is due to the following problems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Due to how memory works in WebAssembly, wasm2c has to first put data segments in the code in plain C array, then when booting, allocate enough memory, then do memcpy to copy the data into the allocated memory. For the secp256k1 example, this means every boot of the program has to copy the 1MB pre-computed multiplication table. Combining with the fact that our RISC-V program now uses newlib, which contains a naive memcpy implementation optimized for code size over speed, this can significantly slow down the program.&lt;/li&gt;
&lt;li&gt;While wasm2c can deliver good performance for simpler programs, for a sophisticated and heavily optimized algorithm like secp256k1, the transformation layer could mean that many optimization chances are lost, hence making it slower than a direct implementation compiled directly to RISC-V&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Luckily, the problems here are totally solvable. The above mentioned workflow is one way we can translate WebAssembly programs to RISC-V programs, but it&amp;rsquo;s absolutely not the only way to achieve that. Like we mentioned above, the transformation layer hinders optimization opportunities, what if we bring in modern compilers to unleash all the possible optimizations here?&lt;/p&gt;
&lt;p&gt;There is already &lt;a href=&#34;https://github.com/wasmerio/wasmer/tree/master/lib/llvm-backend&#34;&gt;progress&lt;/a&gt; being done which translates a WebAssembly program via LLVM into native code. The performance obtained here, is really good. Since LLVM 9 &lt;a href=&#34;https://riscv.org/2019/09/llvm-9-releases-with-official-risc-v-target-support-asm-goto-clang-9-and-more-vincy-davis-packt-pub/&#34;&gt;officially supports&lt;/a&gt; RISC-V now, it&amp;rsquo;s perfectly possible to change the code so LLVM generates RISC-V assembly instead of x86_64 assembly. This way we can translate WebAssembly program via LLVM directly into a RISC-V program, enjoying all the advanced optimizations LLVM can performn on our code.&lt;/p&gt;
&lt;p&gt;As a result, our current solution documented in this post shows this path is totally possible while achieving good enough performance for many existing cases(e.g., many type scripts can be written in Rust for safety, while the performance is not a big problem), this new LLVM solution can provide far better performance for the same workflow in the future. It&amp;rsquo;s just a matter of time for us to find the time to work on this.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 3: UDT</title>
        <link>https://xuejie.space/2019_09_06_introduction_to_ckb_script_programming_udt/</link>
        <pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2019_09_06_introduction_to_ckb_script_programming_udt/</guid>
        <description>&lt;p&gt;CKB&amp;rsquo;s cell model and VM enables many new use cases. However that doesn&amp;rsquo;t mean we need to ditch existing ones. One common use in existing blockchains, is to issue new tokens with special purpose/meaning from the token issuer. In Ethereum, we call those ERC20 tokens, let&amp;rsquo;s see how we can build a similar concept in CKB. To distinguish from ERC20, we call the tokens issued in CKB &lt;code&gt;user defined token&lt;/code&gt;, or UDT for short.&lt;/p&gt;
&lt;p&gt;This post is written based on current CKB Lina mainnet version now.&lt;/p&gt;
&lt;h1 id=&#34;data-model&#34;&gt;Data Model&lt;/h1&gt;
&lt;p&gt;While Ethereum has a unique storage space for each contract account, CKB spreads data among multiple cells. A cell&amp;rsquo;s lock &amp;amp; type script then tells which account the cell belongs to, as well as how you can interact with the cell. The consequence of this, is that unlike ERC20 which stores all token users&#39; balances in the ERC20 contract&amp;rsquo;s storage space, in CKB we will need a new design to store the balances of UDT users.&lt;/p&gt;
&lt;p&gt;We could, of course, designate a special cell to keep the balances of all UDT users. This solution would look a lot like Ethereum&amp;rsquo;s ERC20 design. But several problems arise:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The token issuer would have to provide storage space for keeping all the users&#39; balances. As the number of user grows, the storage space would also grow, in CKB&amp;rsquo;s economic model, this won&amp;rsquo;t be an effective design.&lt;/li&gt;
&lt;li&gt;Consider that updating a cell in CKB is essentially destroying the old cell and re-create a new one, having a single cell with all balances would create a bottleneck: every action which needs to update UDT balance would have to update the one and only cell. People will compete on using the cell.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While there are solutions which can mitigate or even solve the above problems, we started to question the basic design here: does it really make sense to keep all UDTs in a single place? Once transferred, the UDTs really should belong to the receiver, why should the balance still be kept in a central place?&lt;/p&gt;
&lt;p&gt;That leads to our proposed design here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A special type script denotes that the cell stores UDTs.&lt;/li&gt;
&lt;li&gt;The first 4 bytes of the cell data contains the amount of UDTs in current cell.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This design has several implications:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The storage cost for a UDT cell is always constant, it is irrelevant to the amount of UDTs stored in the cell.&lt;/li&gt;
&lt;li&gt;A user can transfer either all or part of the UDTs in a cell to others&lt;/li&gt;
&lt;li&gt;In practice, there might be numerous cells containing the same UDTs.&lt;/li&gt;
&lt;li&gt;The lock script used to guard a UDT is decoupled from the UDT itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each token user then keeps their UDTs in their own cells. They are responsible for providing the storage space for the UDTs, and ensure their own tokens are secure. This way UDTs can truly belong to each individual UDT user.&lt;/p&gt;
&lt;p&gt;One question remains here: if tokens are stored in numerous cells belonging to each user instead of a single place, how can we ensure the tokens are indeed created by token issuer? What if someone forges tokens on their own? In Ethereum, this is probably a problem, but as we shall see in this post, a type script in CKB can prevent all those attacks, ensuring your token is safe.&lt;/p&gt;
&lt;h1 id=&#34;writing-the-udt-script&#34;&gt;Writing the UDT Script&lt;/h1&gt;
&lt;p&gt;Given the above design, a minimal UDT type script should guard the following rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In a UDT transfer transaction, the sum of UDTs in the output cells should equal the sum of UDTs in the input cells.&lt;/li&gt;
&lt;li&gt;Only the token issuer can generate new tokens in the initial token creation process.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This might sound a little ambitious, but we will see that with a type script and some CKB&amp;rsquo;s unique design patterns, the eagle can be landed :P&lt;/p&gt;
&lt;p&gt;For simplicity, we will write the UDT script here in pure JavaScript, while a C version might help in saving cycles, the functionality will be the same.&lt;/p&gt;
&lt;p&gt;First, we will need to loop through all input cells and gather the sum of UDTs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/udt.js b/udt.js
index e69de29..4a20bd0 100644
--- a/udt.js
+++ b/udt.js
@@ -0,0 +1,17 @@
+var input_index = 0;
+var input_coins = 0;
+var buffer = new ArrayBuffer(4);
+var ret = CKB.CODE.INDEX_OUT_OF_BOUND;
+
+while (true) {
+  ret = CKB.raw_load_cell_data(buffer, 0, input_index, CKB.SOURCE.GROUP_INPUT);
+  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
+    break;
+  }
+  if (ret !== 4) {
+    throw &amp;quot;Invalid input cell!&amp;quot;;
+  }
+  var view = new DataView(buffer);
+  input_coins += view.getUint32(0, true);
+  input_index += 1;
+}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As explained in the previous post, CKB requires us to use a loop to iterate through all inputs in the same &lt;code&gt;group&lt;/code&gt; and fetch the data. In C we would use &lt;code&gt;ckb_load_cell_data&lt;/code&gt;, which is wrapped into a JS function &lt;code&gt;CKB.raw_load_cell_data&lt;/code&gt;. As indicated by the ArrayBuffer, we are only interested in the first 4 bytes of the cell data, since those 4 bytes will contain the amount of UDTs.&lt;/p&gt;
&lt;p&gt;Note that here we perform a simple add operation on &lt;code&gt;input_coins&lt;/code&gt;, this is very dangerous. We are doing it just for simplicity, in a production setting, you should check if the value will hold in a 32-bit integer value. Higher precision number types should be used if needed.&lt;/p&gt;
&lt;p&gt;Similarly, we can fetch the sum of output coins and do the comparision:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/udt.js b/udt.js
index 4a20bd0..e02b993 100644
--- a/udt.js
+++ b/udt.js
@@ -15,3 +15,23 @@ while (true) {
   input_coins += view.getUint32(0);
   input_index += 1;
 }
+
+var output_index = 0;
+var output_coins = 0;
+
+while (true) {
+  ret = CKB.raw_load_cell_data(buffer, 0, output_index, CKB.SOURCE.GROUP_OUTPUT);
+  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
+    break;
+  }
+  if (ret !== 4) {
+    throw &amp;quot;Invalid output cell!&amp;quot;;
+  }
+  var view = new DataView(buffer);
+  output_coins += view.getUint32(0, true);
+  output_index += 1;
+}
+
+if (input_coins !== output_coins) {
+  throw &amp;quot;Input coins do not equal output coins!&amp;quot;;
+}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is almost all we need to validate the first rule: the sum of UDTs in the output cells should equal the sum of UDTs in the input cells. In other words, with this type script now, no one will be able to forge new tokens. Isn&amp;rsquo;t that wonderful?&lt;/p&gt;
&lt;p&gt;But there&amp;rsquo;s one quirk: when we say &lt;code&gt;no one&lt;/code&gt; will be able to forge new tokens, we really mean &lt;code&gt;no one&lt;/code&gt;, including the token issuer! This is no good, we need to add an exception so the token issuer can create the tokens first, but no one will be able to do that after. Is there a way to do that?&lt;/p&gt;
&lt;p&gt;Yes there is! But the answer reads like a riddle, so please read this paragraph carefully if I lost you the first time: a type script consist of 2 parts: a code hash denoting the actual code, and args used by the type script. 2 type scripts with different args will be treated 2 different type scripts. The trick here, is to allow the token issuer to create a cell with a new type script, that no one will be able to create again, so if we put something in the args part that is not be able to included again, the problem will be solved.&lt;/p&gt;
&lt;p&gt;Now think about this problem: what cannot be included in a blockchain twice? An OutPoint in a transaction input! The first time we include an OutPoint as a transaction input, the referenced cell will be consumed, if someone later include it again, it will create a double-spending error, which is exactly what we use blockchain for.&lt;/p&gt;
&lt;p&gt;And we have the answer now! The full validation flow of a minimal UDT type script in CKB, is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;First gather the sum of all UDTs in the input cells and the sum of all UDTs in the output cells, if they are equaled, the type script exits with a success status.&lt;/li&gt;
&lt;li&gt;Check if the first argument of the type script matches the first OutPoint in current transaction, if they match, exit with a success status.&lt;/li&gt;
&lt;li&gt;Otherwise exit with a failure status&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you are still with me here, you will see that step 1 corresponds to a normal UDT transfer, while step 2 corresponds to the initial token creation process.&lt;/p&gt;
&lt;p&gt;This is what we mean by CKB&amp;rsquo;s unique design pattern: by using an input OutPoint as a script argument, we can create a unique script that cannot be forged again:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If an attacker tries to use the same argument, the script will validate that the first input OutPoint in the transaction does not match the argument, hence invalidates the transaction;&lt;/li&gt;
&lt;li&gt;If the attacker tries to use the same argument and fill in the argument as the first input OutPoint, it will create a double-spent error, also invalidates the transaction;&lt;/li&gt;
&lt;li&gt;If the attacker tries to use a different argument, CKB will recognize that the different argument leads to a different type script, hence generating a different UDT.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This simple yet powerful pattern thus ensures the UDTs stay safe while enjoying the benefits that they can be transferred freely among many different cells. To the best of our knowledge, this pattern is not possible yet in many other blockchains which claim to be &lt;code&gt;flexible&lt;/code&gt; or &lt;code&gt;programmable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we can finally complete the UDT script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/contract.js b/contract.js
deleted file mode 100644
index e69de29..0000000
diff --git a/udt.js b/udt.js
index e02b993..cd443bf 100644
--- a/udt.js
+++ b/udt.js
@@ -1,3 +1,7 @@
+if (CKB.ARGV.length !== 1) {
+  throw &amp;quot;Requires only one argument!&amp;quot;;
+}
+
 var input_index = 0;
 var input_coins = 0;
 var buffer = new ArrayBuffer(4);
@@ -33,5 +37,17 @@ while (true) {
 }
 
 if (input_coins !== output_coins) {
-  throw &amp;quot;Input coins do not equal output coins!&amp;quot;;
+  if (!((input_index === 0) &amp;amp;&amp;amp; (output_index === 1))) {
+    throw &amp;quot;Invalid token issuing mode!&amp;quot;;
+  }
+  var first_input = CKB.load_input(0, 0, CKB.SOURCE.INPUT);
+  if (typeof first_input === &amp;quot;number&amp;quot;) {
+    throw &amp;quot;Cannot fetch the first input&amp;quot;;
+  }
+  var hex_input = Array.prototype.map.call(
+    new Uint8Array(first_input),
+    function(x) { return (&#39;00&#39; + x.toString(16)).slice(-2); }).join(&#39;&#39;);
+  if (CKB.ARGV[0] != hex_input) {
+    throw &amp;quot;Invalid creation argument!&amp;quot;;
+  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And that&amp;rsquo;s it, with 53 lines of code or 1372 bytes, we&amp;rsquo;ve completed a minimal UDT type script in CKB. Notice I don&amp;rsquo;t even use a minimizer here, with any decent JS minimizer, we should be able to get a much more compact type script. Of course this is a production ready script, but it suffices to show a simple script is enough to handle important tasks in CKB.&lt;/p&gt;
&lt;h1 id=&#34;deploying-to-ckb&#34;&gt;Deploying to CKB&lt;/h1&gt;
&lt;p&gt;I&amp;rsquo;m not like &lt;a href=&#34;https://hacks.mozilla.org/2019/09/debugging-webassembly-outside-of-the-browser/&#34;&gt;some other organizations&lt;/a&gt; who prefer to only show you a video and a provocative post which hide how they did it and the accompanying problems. I believe no post is fun without actual code and steps to play with it. And here&amp;rsquo;s how you can use the above UDT script on CKB:&lt;/p&gt;
&lt;p&gt;In case you might need it, here&amp;rsquo;s the full UDT script without diff format:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat udt.js
if (CKB.ARGV.length !== 1) {
  throw &amp;quot;Requires only one argument!&amp;quot;;
}

var input_index = 0;
var input_coins = 0;
var buffer = new ArrayBuffer(4);
var ret = CKB.CODE.INDEX_OUT_OF_BOUND;

while (true) {
  ret = CKB.raw_load_cell_data(buffer, 0, input_index, CKB.SOURCE.GROUP_INPUT);
  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
    break;
  }
  if (ret !== 4) {
    throw &amp;quot;Invalid input cell!&amp;quot;;
  }
  var view = new DataView(buffer);
  input_coins += view.getUint32(0, true);
  input_index += 1;
}

var output_index = 0;
var output_coins = 0;

while (true) {
  ret = CKB.raw_load_cell_data(buffer, 0, output_index, CKB.SOURCE.GROUP_OUTPUT);
  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
    break;
  }
  if (ret !== 4) {
    throw &amp;quot;Invalid output cell!&amp;quot;;
  }
  var view = new DataView(buffer);
  output_coins += view.getUint32(0, true);
  output_index += 1;
}

if (input_coins !== output_coins) {
  if (!((input_index === 0) &amp;amp;&amp;amp; (output_index === 1))) {
    throw &amp;quot;Invalid token issuing mode!&amp;quot;;
  }
  var first_input = CKB.load_input(0, 0, CKB.SOURCE.INPUT);
  if (typeof first_input === &amp;quot;number&amp;quot;) {
    throw &amp;quot;Cannot fetch the first input&amp;quot;;
  }
  var hex_input = Array.prototype.map.call(
    new Uint8Array(first_input),
    function(x) { return (&#39;00&#39; + x.toString(16)).slice(-2); }).join(&#39;&#39;);
  if (CKB.ARGV[0] != hex_input) {
    throw &amp;quot;Invalid creation argument!&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to run JavaScript, let&amp;rsquo;s first deploy duktape on CKB:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; data = File.read(&amp;quot;../ckb-duktape/build/duktape&amp;quot;)
pry(main)&amp;gt; duktape_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(300000), CKB::Utils.bin_to_hex(duktape_data))
pry(main)&amp;gt; duktape_data_hash = CKB::Blake2b.hexdigest(duktape_data)
pry(main)&amp;gt; duktape_out_point = CKB::Types::CellDep.new(out_point: CKB::Types::OutPoint.new(tx_hash: duktape_tx_hash, index: 0))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;First, let&amp;rsquo;s create a UDT with 1000000 tokens&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet.address, CKB::Utils.byte_to_shannon(20000))
pry(main)&amp;gt; tx.cell_deps.push(duktape_out_point.dup)
pry(main)&amp;gt; arg = CKB::Utils.bin_to_hex(CKB::Serializers::InputSerializer.new(tx.inputs[0]).serialize)
pry(main)&amp;gt; duktape_udt_script = CKB::Types::Script.new(code_hash: duktape_data_hash, args: [CKB::Utils.bin_to_hex(File.read(&amp;quot;udt.js&amp;quot;)), arg])
pry(main)&amp;gt; tx.outputs[0].type = duktape_udt_script
pry(main)&amp;gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([1000000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; tx.witnesses[0] = &amp;quot;0x&amp;quot;
pry(main)&amp;gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; root_udt_tx_hash = api.send_transaction(signed_tx)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we tried to submit the same transaction again, double-spent error will prevent us from forging the same token:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; api.send_transaction(signed_tx)
CKB::RPCError: jsonrpc error: {:code=&amp;gt;-3, :message=&amp;gt;&amp;quot;UnresolvableTransaction(Dead(OutPoint(0x0b607e9599f23a8140d428bd24880e5079de1f0ee931618b2f84decf2600383601000000)))&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And no matter how we tried, we cannot create another cell which forges the same UDT token.&lt;/p&gt;
&lt;p&gt;Now we can try transfering UDTs to another account. First let&amp;rsquo;s try creating one with has more output UDTs than input UDTs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; udt_out_point = CKB::Types::OutPoint.new(tx_hash: root_udt_tx_hash, index: 0)
pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(20000))
pry(main)&amp;gt; tx.cell_deps.push(duktape_out_point.dup)
pry(main)&amp;gt; tx.witnesses[0] = &amp;quot;0x&amp;quot;
pry(main)&amp;gt; tx.witnesses.push(CKB::Types::Witness.new(data: []))
pry(main)&amp;gt; tx.outputs[0].type = duktape_udt_script
pry(main)&amp;gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([1000000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; tx.inputs.push(CKB::Types::Input.new(previous_output: udt_out_point, since: &amp;quot;0&amp;quot;))
pry(main)&amp;gt; tx.outputs.push(tx.outputs[1].dup)
pry(main)&amp;gt; tx.outputs[2].capacity = CKB::Utils::byte_to_shannon(20000)
pry(main)&amp;gt; tx.outputs[2].type = duktape_udt_script
pry(main)&amp;gt; tx.outputs_data.push(CKB::Utils.bin_to_hex([1000000].pack(&amp;quot;L&amp;lt;&amp;quot;)))
pry(main)&amp;gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(signed_tx)
CKB::RPCError: jsonrpc error: {:code=&amp;gt;-3, :message=&amp;gt;&amp;quot;InvalidTx(ScriptFailure(ValidationFailure(-2)))&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we tried to send another user 1000000 UDTs while also keeping 1000000 UDTs for the sender itself, of course this should trigger an error since we are trying to forge more tokens. But with slight modification, we can show that a UDT transferring transaction works if you respect the sum verification rule:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([900000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; tx.outputs_data[2] = CKB::Utils.bin_to_hex([100000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(signed_tx)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;flexible-rules&#34;&gt;Flexible Rules&lt;/h1&gt;
&lt;p&gt;The UDT script shown here serves just as an example, in reality, dapps might be more complicated and requires more functions. You are also free to include more features for your UDT scripts depending on your needs, some examples include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Here we strictly ensure that the sum of output UDTs equals the sum of input UDTs, but in some cases, it might be enough just to ensure the sum of output UDTs does not exceed the sum of input UDTs. In order words, when not needed, a user can choose to burn the UDTs for the capacities.&lt;/li&gt;
&lt;li&gt;The above UDT script doesn&amp;rsquo;t allow issuing more tokens after the initial creation process, but there might be another type of UDT that allows more issurance from the token issuer. This is also possible on CKB, the actual way to solve this task, is left as an exercise here :)&lt;/li&gt;
&lt;li&gt;Here we limit the script to only create one cell in the initial token creation process, it&amp;rsquo;s also possible to create multiple cells to spread the usage in the initial token creation process.&lt;/li&gt;
&lt;li&gt;While we only cover ERC20 here, ERC721 should also be totally possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice those are just some examples, the actual ways of using CKB script are limitless here. We are more than happy to see cases where CKB dapp developers amaze us with interesting usage of CKB scripts.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 2: Script Basics</title>
        <link>https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/</link>
        <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/</guid>
        <description>&lt;p&gt;Last post introduced current CKB&amp;rsquo;s validation model. This post will get more fun, since we will show how to deploy script codes to CKB for real. I&amp;rsquo;m hoping after this post, you should be able to explore the CKB world and work on new script codes as you wish.&lt;/p&gt;
&lt;p&gt;This post is written based on current CKB Lina mainnet version now.&lt;/p&gt;
&lt;p&gt;A warning here: this will be a long post, since I want to fill in enough for the more interesting topic next week. So you don&amp;rsquo;t have to finish it at once if you don&amp;rsquo;t have enough time. I&amp;rsquo;ve tried to split it into individual sections, so you can try each one at a time.&lt;/p&gt;
&lt;h1 id=&#34;wording&#34;&gt;Wording&lt;/h1&gt;
&lt;p&gt;Before we continue, let&amp;rsquo;s distinguish between 2 terms: script, and script code.&lt;/p&gt;
&lt;p&gt;In this post and hopefully the whole series, we will distinguish between script, and script code. Script code actually refers to the program you write and compile to use on CKB. Script, on the other hand, actually refers to the script data structure used in CKB, which is a little more than just the script code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Script&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; code_hash: &lt;span style=&#34;font-weight:bold&#34;&gt;H256&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; hash_type: &lt;span style=&#34;font-weight:bold&#34;&gt;ScriptHashType&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; args: &lt;span style=&#34;font-weight:bold&#34;&gt;JsonBytes&lt;/span&gt;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can ignore &lt;code&gt;hash_type&lt;/code&gt; for now, a future post will explain what it is and it&amp;rsquo;s interesting usage. Later in this post, we will show that &lt;code&gt;code_hash&lt;/code&gt; actually just identifies a script code, so for now we can just think of it as script code. What script also includes, is the &lt;code&gt;args&lt;/code&gt; part, which distinguishes script from script code. &lt;code&gt;args&lt;/code&gt; can be used here to provide additional arguments for a CKB script, for example, while people might all be using the same default lock script code, each of them might have their own pubkey hash, &lt;code&gt;args&lt;/code&gt; is exact the place to hold pubkey hash. This way each user of CKB can have different lock script, while sharing the same lock script code.&lt;/p&gt;
&lt;p&gt;Note that in most cases, script and script code can be used interchangably, but if you are confused at some places, it might be worthwhile to think of the difference between the 2.&lt;/p&gt;
&lt;h1 id=&#34;a-minimal-ckb-script-code&#34;&gt;A Minimal CKB Script Code&lt;/h1&gt;
&lt;p&gt;As you might have already heard, CKB is based on the open source RISC-V ISA. But what does that even mean? In my words, it means we are (sort of) embedding a real mini computer in CKB, instead of a virtual machine. The benefit of a real computer, is that you can write any logic you want in any language you want. The first few examples we show here will be written in C for simplicity(well I mean simplicity in the toolchain, not the &lt;a href=&#34;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&#34;&gt;language&lt;/a&gt;), but later we will switch to JavaScript based script code, and hopefully show more languages in the series. On CKB there&amp;rsquo;s endless possibilities.&lt;/p&gt;
&lt;p&gt;As we mentioned about, CKB VM is more like a real mini computer. CKB script code also looks like a normal Unix style executable program we run on a computer:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;&#34;&gt;char&lt;/span&gt;* argv[])
{
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When compiled via a C compiler, this will become a script code that is runnable on CKB. In other words, CKB just take plain old Unix style executables(but in RISC-V architecture instead of the popular x86 architecture), and run it in a virtual machine environment. If the program returns with 0 as the return code, we consider the script succeeds, all non-zero return codes will be considered script faliures.&lt;/p&gt;
&lt;p&gt;In the example above, we are showing a script code that always succeeds, since the return code will always be zero. Please don&amp;rsquo;t use this as your lock script code, otherwise your token can be taken away by anyone.&lt;/p&gt;
&lt;p&gt;But the example above won&amp;rsquo;t be interesting, here we will start with an interesting idea: personally I dislike carrot. I do know that carrot is great from a nutritional point of view, but I still want to avoid it due to the taste. Now what if I want to set a rule, that none of my cells on CKB has data that begin with &lt;code&gt;carrot&lt;/code&gt;? Let&amp;rsquo;s write a script code to ensure this.&lt;/p&gt;
&lt;p&gt;In order to ensure none of the cells can have &lt;code&gt;carrot&lt;/code&gt; in cell data, we need a way to first read cell data in the script. CKB provides &lt;code&gt;syscalls&lt;/code&gt; to help with this.&lt;/p&gt;
&lt;p&gt;To ensure the security of CKB script, each script has to run in an isolated environment that is totally separated from the main computer you are running CKB. This way it won&amp;rsquo;t be able to access data it doesn&amp;rsquo;t need, such as your private keys or passwords. However, for a script to be useful, there must be certain data it want to access, such as the cell a script guards, or a transaction a script validates. CKB provides &lt;code&gt;syscalls&lt;/code&gt; to ensure this, syscalls are defined in RISC-V standard, they provide a way to access certain resources provided by the environment. In a normal situation, the environment here means the operating system, but in the case of CKB VM, the environment refers to the actual CKB process. With syscalls, a CKB script can access the whole transaction containing itself, including inputs, outputs, witnesses, and deps.&lt;/p&gt;
&lt;p&gt;The good news, is that we have encapsulated syscalls in an easy to use &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/ckb_syscalls.h&#34;&gt;header file&lt;/a&gt;, you are very welcome to poke around this file to see how syscalls are implemented. The bottomline is you can just grab this header file and use the wrapped functions to make syscalls as you want.&lt;/p&gt;
&lt;p&gt;Now with the syscalls at hand, we can start with our carrot-forbidden script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;#34;ckb_syscalls.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;&#34;&gt;char&lt;/span&gt;* argv[]) {
  &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; ret;
  size_t index = 0;
  uint64_t len = 0; &lt;span style=&#34;font-style:italic&#34;&gt;/* (1) */&lt;/span&gt;
  &lt;span style=&#34;&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; buffer[6];

  &lt;span style=&#34;font-weight:bold&#34;&gt;while&lt;/span&gt; (1) {
    len = 6;
    memset(buffer, 0, 6);
    ret = ckb_load_cell_data(buffer, &amp;amp;len, 0, index, CKB_SOURCE_OUTPUT); &lt;span style=&#34;font-style:italic&#34;&gt;/* (2) */&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret == CKB_INDEX_OUT_OF_BOUND) {               &lt;span style=&#34;font-style:italic&#34;&gt;/* (3) */&lt;/span&gt;
      &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
    }

    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (memcmp(buffer, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;, 6) == 0) {
      &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }

    index++;
  }

  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Several points worth explaining here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We will use &lt;code&gt;len&lt;/code&gt; field both as an input and output parameter, hence it is passed as a pointer here.&lt;/li&gt;
&lt;li&gt;When making a syscall, we need to provide the following: a buffer to hold the data provided by the syscall; a &lt;code&gt;len&lt;/code&gt; field denoting both the buffer length, and available data length returned by the syscall; an offset into the input data buffer, and several parameters denoting the exact field we are fetching in the transaction. For more details, please refer to our &lt;a href=&#34;https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0009-vm-syscalls/0009-vm-syscalls.md&#34;&gt;RFC&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For maximum flexibility, CKB uses the return value of the syscall to represent data fetching status: 0(or &lt;code&gt;CKB_SUCCESS&lt;/code&gt;) means success, 1(or &lt;code&gt;CKB_INDEX_OUT_OF_BOUND&lt;/code&gt;) means you have finished fetching all indices in a kind, 2(or &lt;code&gt;CKB_ITEM_MISSING&lt;/code&gt;) means an entity is not present, such as fetching a type script from a cell that doesn&amp;rsquo;t have one.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So to recap, this script would loop through all output cells in the transaction, load the first 6 bytes of each cell data and test if those bytes match &lt;code&gt;carrot&lt;/code&gt;. If we found a match, the script would return &lt;code&gt;-1&lt;/code&gt;, denoting an error status, if no match is found, the script exits with &lt;code&gt;0&lt;/code&gt;, meaning execution success.&lt;/p&gt;
&lt;p&gt;To perform the loop, the script would keep an &lt;code&gt;index&lt;/code&gt; variable, in each loop iteration, it would tries to make the syscall to fetch the cell denoted by current &lt;code&gt;index&lt;/code&gt; value, if the syscall returns &lt;code&gt;CKB_INDEX_OUT_OF_BOUND&lt;/code&gt;, it means the script has iterated through all the cells, hence it just exits the loop, otherwise, the loop would continue, the cell data is tested, then &lt;code&gt;index&lt;/code&gt; variable is incremented for the next iteration.&lt;/p&gt;
&lt;p&gt;This concludes your first useful CKB script code! In the next section, we will see how we can deploy it to CKB and run it.&lt;/p&gt;
&lt;h1 id=&#34;deploying-a-script-to-ckb&#34;&gt;Deploying a Script to CKB&lt;/h1&gt;
&lt;p&gt;First, we need to compile the carrot source code written above. Since GCC already has upstream RISC-V support, you can of course use the official GCC to build your script code. Or you can use the &lt;a href=&#34;https://hub.docker.com/r/nervos/ckb-riscv-gnu-toolchain&#34;&gt;docker image&lt;/a&gt; we have prepared to save the trouble of compiling GCC:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ls
carrot.c  ckb_consts.h  ckb_syscalls.h
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
root@dc2c0c209dcd:/# cd /code
root@dc2c0c209dcd:/code# riscv64-unknown-elf-gcc -Os carrot.c -o carrot
root@dc2c0c209dcd:/code# exit
exit
$ ls
carrot*  carrot.c  ckb_consts.h  ckb_syscalls.h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And that&amp;rsquo;s it, CKB can use the compiled executable from GCC directly as scripts on chain, there&amp;rsquo;s no way for further processing. We can now deploy it on chain. Note that I will use CKB&amp;rsquo;s Ruby SDK since I used to be a Ruby programmer, and Ruby feels the most natural one(but not necessarily the best one) to me. Please refer to the official &lt;a href=&#34;https://github.com/nervosnetwork/ckb-sdk-ruby/blob/develop/README.md&#34;&gt;README&lt;/a&gt; for how to set it up.&lt;/p&gt;
&lt;p&gt;To deploy the script to CKB, we can just create a new cell, with the script code as cell data part:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; data.bytesize
=&amp;gt; 6864
pry(main)&amp;gt; carrot_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(8000), CKB::Utils.bin_to_hex(data))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here I simply create a new cell with enough capacity by sending tokens to myself. Now we can create the type script containing the carrot script code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; carrot_data_hash = CKB::Blake2b.hexdigest(data)
pry(main)&amp;gt; carrot_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: carrot_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Recall the Script data structure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Script&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; code_hash: &lt;span style=&#34;font-weight:bold&#34;&gt;H256&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; hash_type: &lt;span style=&#34;font-weight:bold&#34;&gt;ScriptHashType&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; args: &lt;span style=&#34;font-weight:bold&#34;&gt;JsonBytes&lt;/span&gt;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can see that instead of embedding the script code directly in the script data structure, we are only including the code hash, which is a Blake2b hash of the actual script binary code. Since carrot script doesn&amp;rsquo;t use an argument, we can use empty bytes for &lt;code&gt;args&lt;/code&gt; part.&lt;/p&gt;
&lt;p&gt;Note I&amp;rsquo;m still ignoring &lt;code&gt;hash_type&lt;/code&gt; here, we will leave to a future post to see a different way of specifying code hash. For now, let&amp;rsquo;s keep it simple here.&lt;/p&gt;
&lt;p&gt;To run the carrot script, we need to create a new transaction, and set carrot type script as the type script of one of the output cells:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(100), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 5000)
pry(main)&amp;gt; tx.outputs[0].type = carrot_type_script.dup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There&amp;rsquo;s one more step needed: in order for CKB to locate the carrot script, we need to reference the cell containing carrot script in one of transaction deps:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; carrot_cell_dep = CKB::Types::CellDep.new(&lt;span style=&#34;font-style:italic&#34;&gt;out_point&lt;/span&gt;: CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: carrot_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))
pry(main)&amp;gt; tx.cell_deps &amp;lt;&amp;lt; carrot_cell_dep.dup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we are ready to sign and send the transaction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;[46] pry(main)&amp;gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
[19] pry(main)&amp;gt; api.send_transaction(tx)
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0xd7b0fea7c1527cde27cc4e7a2e055e494690a384db14cc35cd2e51ec6f078163&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since this transaction does not have any cell containing &lt;code&gt;carrot&lt;/code&gt; in the cell data, the type script validates successfully. Now let&amp;rsquo;s try a different transaction that does have a cell that begins with &lt;code&gt;carrot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx2 = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(400), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 5000)
pry(main)&amp;gt; tx2.cell_deps.push(carrot_cell_dep.dup)
pry(main)&amp;gt; tx2.outputs[0].type = carrot_type_script.dup
pry(main)&amp;gt; tx2.outputs_data[0] = CKB::Utils.bin_to_hex(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot123&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; tx2 = tx2.sign(wallet.key)
pry(main)&amp;gt; api.send_transaction(tx2)
CKB::&lt;span style=&#34;font-style:italic&#34;&gt;RPCError&lt;/span&gt;: jsonrpc &lt;span style=&#34;font-style:italic&#34;&gt;error&lt;/span&gt;: {&lt;span style=&#34;font-style:italic&#34;&gt;:code&lt;/span&gt;=&amp;gt;-3, &lt;span style=&#34;font-style:italic&#34;&gt;:message&lt;/span&gt;=&amp;gt;&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;InvalidTx(ScriptFailure(ValidationFailure(-1)))&amp;#34;&lt;/span&gt;}
from &lt;span style=&#34;font-style:italic&#34;&gt;/home/u&lt;/span&gt;buntu/code/ckb-sdk-ruby/lib/ckb/rpc.rb:164&lt;span style=&#34;font-style:italic&#34;&gt;:in&lt;/span&gt; &lt;span style=&#34;font-style:italic&#34;&gt;`rpc_request&amp;#39;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can see our carrot script rejects a transaction that generates a cell with carrot. Now I can use this script to make sure all my cells are free from carrots!&lt;/p&gt;
&lt;p&gt;So to recap, to deploy and run a script as type script, what we need to do is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Compile the script to RISC-V executable binary&lt;/li&gt;
&lt;li&gt;Deploy the binary in a cell&amp;rsquo;s data part&lt;/li&gt;
&lt;li&gt;Create a type script data structure with the blake2b hash of the binary as &lt;code&gt;code hash&lt;/code&gt;, any required arguments of the script code in the &lt;code&gt;args&lt;/code&gt; part&lt;/li&gt;
&lt;li&gt;Create a new transaction with the type script set in one of the generated cells&lt;/li&gt;
&lt;li&gt;Include the outpoint to the cell containing the script code as one of the transaction deps&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That&amp;rsquo;s really all you need! If your script has run into problems, those are the points you need to check.&lt;/p&gt;
&lt;p&gt;Although we only talk about type scripts here, lock script works exactly the same way. The only quirk you need to keep in mind, is that when you create a cell with a specificed lock script, the lock script won&amp;rsquo;t run here. It only runs when you are consuming the cell. So while type script can be used to create the logic that runs when you create the cell, lock script is used to create the logic that runs when you consume the cell. Given this consideration, please make sure your lock script is correct, otherwise you might be losing the tokens in the following scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your lock script has a bug that someone else can unlock your cell.&lt;/li&gt;
&lt;li&gt;Your lock script has a bug that no one(including you) can unlock your cell.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One tip we can provide here, is always test your script as a type script attached to an output cell in your transaction, this way when error happens, you will know immediately, your tokens can stay safe.&lt;/p&gt;
&lt;h1 id=&#34;introducing-duktape&#34;&gt;Introducing Duktape&lt;/h1&gt;
&lt;p&gt;I&amp;rsquo;m sure you feel the same way as I do now: it&amp;rsquo;s good we can write contracts in C, but C always feels a bit tedious and, let&amp;rsquo;s face it, dangerous. Is there a better way?&lt;/p&gt;
&lt;p&gt;Yes of course! We mentioned above CKB VM is essentially a mini computer, and there are tons of solutions we can explore. One thing we have prepared here, is that we can write CKB script codes in JavaScript. Yes you got it right, plain ES5(yes I know, but this is just one example, and you can use a transpiler) JavaScript.&lt;/p&gt;
&lt;p&gt;How this is possible? Since we have C compiler available, all we did is just take a JavaScript implementation for the embeded system, in our case, &lt;a href=&#34;https://duktape.org/&#34;&gt;duktape&lt;/a&gt;, compile it from C to RISC-V binary, put it on chain, then boom, we can run JavaScript in CKB! Since we are working with a real mini computer here, there&amp;rsquo;s no stopping us from embeding another VM as CKB script to CKB VM, and exploring this VM on top of VM path.&lt;/p&gt;
&lt;p&gt;And we can actually expand from this path, we can have JavaScript on CKB via duktape, we can also have Ruby on CKB via &lt;a href=&#34;https://github.com/mruby/mruby&#34;&gt;mruby&lt;/a&gt;, we can even have Bitcoin Script or EVM on chain if we just compile their VM and put it on chain. This ensures CKB VM can both help us preserve legacy and build a diversified ecosystem. All languages should be and are treated equal on CKB, the freedom should be in the hands of blockchain contract developers.&lt;/p&gt;
&lt;p&gt;At this stage you might want to ask: yes this is possible, but won&amp;rsquo;t VM on top of VM be slow? I believe it really depends on your use case to say if this is gonna be slow. I&amp;rsquo;m a firm believer that benchmarks make no sense unless we put it in a real use case with standard hardware requirements. So wait to see if this is really gonna be an issue. In my opinion, higher languages are more likely to be used in type scripts to guard cell transformation, in this case, I doubt it&amp;rsquo;s gonna be slow. Besides, we are also working on this field to optimize both CKB VM and the VMs on top of CKB VM to make it faster and faster :P&lt;/p&gt;
&lt;p&gt;To use duktape on CKB, first you need to compile duktape itself into a RISC-V executable binary:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git clone https://github.com/xxuejie/ckb-duktape
$ cd ckb-duktape
$ git submodule init
$ git submodule update
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
root@0d31cad7a539:~# cd /code
root@0d31cad7a539:/code# make
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/entry.c -c -o build/entry.o
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror duktape/duktape.c -c -o build/duktape.o
riscv64-unknown-elf-gcc build/entry.o build/duktape.o -o build/duktape -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
root@0d31cad7a539:/code# exit
exit
$ ls build/duktape
build/duktape*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Like the carrot example, the first step here is to deploy duktape script code in a CKB cell:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; duktape_data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;../ckb-duktape/build/duktape&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; duktape_data.bytesize
=&amp;gt; 269064
pry(main)&amp;gt; duktape_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(280000), CKB::Utils.bin_to_hex(duktape_data))
pry(main)&amp;gt; duktape_data_hash = CKB::Blake2b.hexdigest(duktape_data)
pry(main)&amp;gt; duktape_cell_dep = CKB::Types::CellDep.new(&lt;span style=&#34;font-style:italic&#34;&gt;out_point&lt;/span&gt;: CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: duktape_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Unlike the carrot example, duktape script code now requires one argument: the JavaScript source you want to execute:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; duktape_hello_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: duktape_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: CKB::Utils.bin_to_hex(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;CKB.debug(&lt;/span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;I&amp;#39;m running in JS!&lt;/span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;)&amp;#34;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice that with a different argument, you can create a different duktape powered type script for different use case:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; duktape_hello_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: duktape_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: CKB::Utils.bin_to_hex(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;var a = 1;&lt;/span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;var b = a + 2;&amp;#34;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This echos the differences mentioned above on script code vs script: here duktape serves as a script code providing a JavaScript engine, while different script leveraging duktape script code serves different functionalities on chain.&lt;/p&gt;
&lt;p&gt;Now we can create a cell with the duktape type script attached:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(200), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 600)
pry(main)&amp;gt; tx.cell_deps.push(duktape_cell_dep.dup)
pry(main)&amp;gt; tx.outputs[0].type = duktape_hello_type_script.dup
pry(main)&amp;gt; tx = tx.sign(wallet.key)
pry(main)&amp;gt; api.send_transaction(tx)
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x2e4d3aab4284bc52fc6f07df66e7c8fc0e236916b8a8b8417abb2a2c60824028&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can see that the script executes successfully, and if you have &lt;code&gt;ckb-script&lt;/code&gt; module&amp;rsquo;s log level set to &lt;code&gt;debug&lt;/code&gt; in your &lt;code&gt;ckb.toml&lt;/code&gt; file, you can also notice the following log:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;2019-07-15 05:59:13.551 +00:00 http.worker8 DEBUG ckb-script  script group: c35b9fed5fc0dd6eaef5a918cd7a4e4b77ea93398bece4d4572b67a474874641 DEBUG OUTPUT: I&lt;span style=&#34;&#34;&gt;&amp;#39;&lt;/span&gt;m running in JS!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now you have successfully deploy a JavaScript engine on CKB, and run JavaScript based script on CKB! Feel free to try any JavaScript code you want here.&lt;/p&gt;
&lt;h1 id=&#34;a-thought-exercise&#34;&gt;A Thought Exercise&lt;/h1&gt;
&lt;p&gt;Now you are familiar with CKB script basics, here&amp;rsquo;s one thought exercise: in this post you&amp;rsquo;ve seen what an always-success script looks like, but what about an always-failure script? How small an always-faliure script(and script code) can be?&lt;/p&gt;
&lt;p&gt;A hint: this is NOT a gcc flag-tweaking optimization contest, this is merely a thought exercise.&lt;/p&gt;
&lt;h1 id=&#34;next&#34;&gt;Next&lt;/h1&gt;
&lt;p&gt;I know this is a long post, I hope you have tried this and successfully deployed a script to CKB. In the next post, we will introduce an important topic: how to issue your own user defined tokens(UDT) on CKB. The best part of UDTs on CKB, is that each user can store their UDTs in their own cells, which is different from ERC20 tokens on Ethereum, where everyone&amp;rsquo;s token will have to live in the token issuer&amp;rsquo;s single address. All of this can be achieved by using type scripts alone. If you are interested please stay tuned :)&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Introduction to CKB Script Programming 1: Validation Model</title>
        <link>https://xuejie.space/2019_07_05_introduction_to_ckb_script_programming_validation_model/</link>
        <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>https://xuejie.space/2019_07_05_introduction_to_ckb_script_programming_validation_model/</guid>
        <description>&lt;p&gt;As of now, the cell validation model in CKB has been more or less stablized, hence I&amp;rsquo;m starting a series of article introducing CKB script programming here. My goal here is to fill in all the missing implementation details one need to write CKB scripts after reading the whitepaper, so you can start exploring this beautiful wonderland CKB presents.&lt;/p&gt;
&lt;p&gt;You might noticed that I call the code running on CKB as &lt;code&gt;script&lt;/code&gt;, not &lt;code&gt;smart contract&lt;/code&gt;. This is because smart contract is quite a confusing term to me, and I want to use a different word here to indicate CKB&amp;rsquo;s unique programmability. A script in CKB&amp;rsquo;s sense need not be just a script we see in scripting languages such as Ruby, JS, it actually refers to the RISC-V format binary you run on CKB VM.&lt;/p&gt;
&lt;p&gt;This first post here, is dedicated to the brand &lt;a href=&#34;https://github.com/nervosnetwork/ckb/pull/913&#34;&gt;new verification model&lt;/a&gt; introduced in CKB v0.14.0. It might sound boring but I promise you this is the last post without actual examples to play with :P&lt;/p&gt;
&lt;p&gt;Note even though I believe CKB&amp;rsquo;s programming model is quite stable now, development is still happening so there might be changes. I will try my best to make sure this post is updated but if anything confuses you, this post is describing CKB&amp;rsquo;s Lina mainnet version now.&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Below illustrates a real transaction on CKB:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/tx.svg&#34; alt=&#34;Transaction Example&#34;&gt;&lt;/p&gt;
&lt;p&gt;There are a lot of things going on in this graph, and we will come back to this graph again in later posts. Today, we will just focus on 2 entities in the cell data structure: &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;CellOutput&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; capacity: &lt;span style=&#34;font-weight:bold&#34;&gt;Capacity&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; lock: &lt;span style=&#34;font-weight:bold&#34;&gt;Script&lt;/span&gt;,
    &lt;span style=&#34;&#34;&gt;#[serde(rename = &lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;)]&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; type_: Option&amp;lt;Script&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From the data structure we can see that &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; shared the same structure, later we can show that they are also executed in the same environment, the differences between them are just in a few tiny bits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lock&lt;/code&gt; is required, while &lt;code&gt;type&lt;/code&gt; is optional&lt;/li&gt;
&lt;li&gt;Mentally, they are used to capture different use cases.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will first start with &lt;code&gt;type&lt;/code&gt; script here.&lt;/p&gt;
&lt;h1 id=&#34;type-script&#34;&gt;Type Script&lt;/h1&gt;
&lt;p&gt;Note the name here is just a lucky accident, it is not related to the beloved &lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;programming language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you think about it, a transaction on CKB(or most UTXO-based blockchains) just transforms one set of cells(or UTXOs) to another set of cells. What&amp;rsquo;s interesting, is the actual transformation here. That&amp;rsquo;s where we start to design CKB&amp;rsquo;s verification model: how can we build a model to better validate the cell transformations?&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s where a &lt;code&gt;type&lt;/code&gt; script comes in play: a type script is used to validate certain rules in the cell transformation phase. Some examples here include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Validating UDT(user defined token) balances to ensure no new token is invalidly issued.&lt;/li&gt;
&lt;li&gt;Ensuring a unique name is assigned to a cell that might be mutated. Note this is a fun one, please expect a future article dedicated entirely to this topic.&lt;/li&gt;
&lt;li&gt;Implementing economic constructs. In fact NervosDAO is completely implemented as a &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/dao.c&#34;&gt;type script&lt;/a&gt; with minimal support from the consensus layer.&lt;/li&gt;
&lt;li&gt;A bitcoin VM can be compiled to RISC-V binary, which can transform CKB into an alternative bitcoin implementation :)&lt;/li&gt;
&lt;li&gt;Keep in mind that in addition to data, cell can be used to store code as well, hence a type script can also be used to run tests on the code in cell to ensure certain behavior.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In a nutshell, type script can be used to capture any validation logic you need in the cell transformation. Combined with CKB&amp;rsquo;s flexible virtual machine, I believe this will provide endless potentials.&lt;/p&gt;
&lt;h1 id=&#34;lock-script&#34;&gt;Lock Script&lt;/h1&gt;
&lt;p&gt;Type script captures the cell transformation logic, but there&amp;rsquo;s still one thing missing from the picture: how can I guard my own cell from someone else? In other words, how can I ensure my tokens stay mine in an ever-changing world?&lt;/p&gt;
&lt;p&gt;This is why we designed the always required lock script. A cell can only be consumed when the lock script can be executed sucessfully. This is different from type script, which might be totally optional. A lock script is always there to guard the security of a cell.&lt;/p&gt;
&lt;p&gt;Typically, you would expect that a lock script contains a signature verification phase, like all the other blockchains do, but there are also brand new use cases unlocked by CKB:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The actual signature algorithm is totally determined by the lock script, and you are free to use any lock script. That means you are free to incorporate any signature algorithms that suit your need. In the official CKB distribution we are including &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/secp256k1_blake160_sighash_all.c&#34;&gt;secp256k1 algorithm&lt;/a&gt; as the default lock script. But you don&amp;rsquo;t have to use this, if someone implements a lock script using schnorr signature, you are more than welcome to use that one.&lt;/li&gt;
&lt;li&gt;In addition to signature verification, a lock script can also include other rules to unlock the cell as well. For example, I can configure my lock script to pass if the transaction contains an output cell that uses my lock script, but has more capacity than my consumed cell. This way when someone sends me capacity, they can consume my existing cell and create a new cell for me. They don&amp;rsquo;t have to create a new cell for me like bitcoin requires.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In my personal opinion, the best part of CKB, is that a lock script created by the community is treated exactly the same way as the official default one. No priviledge is granted to the official scripts. Unlike some other blockchains, CKB provides the freedom to develop CKB scripts back to the whole community.&lt;/p&gt;
&lt;h1 id=&#34;execution-model&#34;&gt;Execution Model&lt;/h1&gt;
&lt;p&gt;Now let&amp;rsquo;s see when lock and type scripts are executed.&lt;/p&gt;
&lt;h2 id=&#34;back-to-the-example&#34;&gt;Back to the Example&lt;/h2&gt;
&lt;p&gt;Here&amp;rsquo;s the transaction we see earlier again:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/tx.svg&#34; alt=&#34;Transaction Example&#34;&gt;&lt;/p&gt;
&lt;p&gt;For this example, the execution flow is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Lock Script 1&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lock Script 2&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type Script 1&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type Script 2&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In later posts we can see both lock and type scripts are executed in the same environment, and both have access to the whole transaction. If any of the script fails, the whole transaction fails. Only when all the scripts succeed, the transaction is considered validated.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;re couple of points worth mentioning:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Even though there are 2 input cells with &lt;code&gt;Lock Script 1&lt;/code&gt;, it is only executed once, it&amp;rsquo;s up to the actual lock script to locate all the input cells with the same lock script and validate both signature.&lt;/li&gt;
&lt;li&gt;Only lock scripts in input cells are executed in this transaction, for example, &lt;code&gt;Lock Script 3&lt;/code&gt; is not executed here.&lt;/li&gt;
&lt;li&gt;Even though an input cell and an output cell both contain &lt;code&gt;Type Script 1&lt;/code&gt;, it is only executed once.&lt;/li&gt;
&lt;li&gt;Type scripts in both input and output cells are executed, which include &lt;code&gt;Type Script 1&lt;/code&gt; and &lt;code&gt;Type Script 2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Some cells do not have type scripts, in this case we just omit the execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rules&#34;&gt;Rules&lt;/h2&gt;
&lt;p&gt;Now to summary the rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lock scripts in input cells are collected and deduped, each unique lock script is executed and only executed once.&lt;/li&gt;
&lt;li&gt;Type scripts in input and output cells(if existed) are collected together and deduped, each unique type script is executed and only executed once.&lt;/li&gt;
&lt;li&gt;If any script fails, the whole transaction validation fails.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s Next&lt;/h1&gt;
&lt;p&gt;Now that cell model is covered, we will look at how to actual write a CKB VM script in the next post. The default secp256k1 lock script will be examined to show the life of a CKB VM script.&lt;/p&gt;
</description>
      </item>
      
    
      
    
  </channel>
</rss>
