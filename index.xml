<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Less is more</title>
    <link>https://xuejie.space/</link>
    <description>Recent content on Less is more</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 18 Oct 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://xuejie.space/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to CKB Script Programming 5: Debugging</title>
      <link>https://xuejie.space/2019_10_18_introduction_to_ckb_script_programming_debugging/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuejie.space/2019_10_18_introduction_to_ckb_script_programming_debugging/</guid>
      <description>

&lt;p&gt;Due to the fact that CKB script works at a much lower level than other smart contracts, the debugging story for CKB, has been quite a mysterious one. In this post, we will show how one can debug CKB scripts. As you will find out, debugging a CKB script is not so different from debugging your everyday program.&lt;/p&gt;

&lt;p&gt;This post works on the soon-to-be-released CKB v0.23.0. Specifically, I&amp;rsquo;m using the following commit in each project:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb&#34;&gt;ckb&lt;/a&gt;: 7e2ad2d9ed6718360587f3762163229eccd2cf10&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb-sdk-ruby&#34;&gt;ckb-sdk-ruby&lt;/a&gt;: 18a89d8c69e173ad59ce3e3b3bf79b5d11c5f8f8&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb-duktape&#34;&gt;ckb-duktape&lt;/a&gt;: 347bf730c08eb0aab7e56e0357945a4d6cee109a&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb-standalone-debugger&#34;&gt;ckb-standalone-debugger&lt;/a&gt;: 2379e89ae285e4e639b961756c22d8e4fde4d6ab&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;debugging-c-programs-with-gdb&#34;&gt;Debugging C programs with GDB&lt;/h1&gt;

&lt;p&gt;The first solution to CKB script debugging, works with compiled languages such as C, Rust, etc. Perhaps you are used to writing C programs, and GDB is your best friend. You are wondering if debugging C programs with GDB is possible, and the answer, of course, is: yes, you can definitely debug your CKB script written in C via GDB! Let me show you how.&lt;/p&gt;

&lt;p&gt;First we have the same carrot example from my old posts:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;#34;ckb_syscalls.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;&#34;&gt;char&lt;/span&gt;* argv[]) {
  &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; ret;
  size_t index = 0;
  uint64_t len = 0;
  &lt;span style=&#34;&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; buffer[6];

  &lt;span style=&#34;font-weight:bold&#34;&gt;while&lt;/span&gt; (1) {
    len = 6;
    memset(buffer, 0, 6);
    ret = ckb_load_cell_data(buffer, &amp;amp;len, 0, index, CKB_SOURCE_OUTPUT);
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret == CKB_INDEX_OUT_OF_BOUND) {
      &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
    }

    &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; cmp = memcmp(buffer, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;, 6);
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (cmp) {
      &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }

    index++;
  }

  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I&amp;rsquo;ve made 2 changes to it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ve updated the script to make it compatible with CKB v0.23.0. In this version, we should be using &lt;code&gt;ckb_load_cell_data&lt;/code&gt; to fetch cell data.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;ve also introduced a slight bug to the code, so we can later try the debugging workflow. You might noticed it if you are familiar with C, but no need to worry if you missed it, I will explain it later.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual, let&amp;rsquo;s use our official toolchain to compile it to RISC-V code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ls
carrot.c
$ git clone https://github.com/nervosnetwork/ckb-system-scripts
$ cp ckb-system-scripts/c/ckb_*.h ./
$ ls
carrot.c  ckb_consts.h  ckb_syscalls.h  ckb-system-scripts/
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191012 bash
root@3efa454be9af:/# cd /code
root@3efa454be9af:/code# riscv64-unknown-elf-gcc carrot.c -g -o carrot
root@3efa454be9af:/code# exit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice when I compile the script, I added &lt;code&gt;-g&lt;/code&gt; so as to generate debugging information which is quite useful in GDB. For a production script, you would almost always want to strip them out to save previous on-chain space.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s deploy the script to CKB. Have your CKB node running, and fire up to Ruby SDK:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; api = CKB::API.new
pry(main)&amp;gt; wallet = CKB::Wallet.from_hex(api, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;&amp;lt;your private key&amp;gt;&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; wallet2 = CKB::Wallet.from_hex(api, CKB::Key.random_private_key)
pry(main)&amp;gt; carrot_data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; carrot_data.bytesize
=&amp;gt; 19296
pry(main)&amp;gt; carrot_tx_hash = wallet.send_capacity(wallet2.address, CKB::Utils.byte_to_shannon(20000), CKB::Utils.bin_to_hex(carrot_data), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 21000)
pry(main)&amp;gt; carrot_data_hash = CKB::Blake2b.hexdigest(carrot_data)
pry(main)&amp;gt; carrot_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: carrot_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; carrot_cell_dep = CKB::Types::CellDep.new(&lt;span style=&#34;font-style:italic&#34;&gt;out_point&lt;/span&gt;: CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: carrot_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With carrot script on blockchain, we can create a transaction to test the carrot script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(100), &lt;span style=&#34;font-style:italic&#34;&gt;use_dep_group&lt;/span&gt;: &lt;span style=&#34;&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 5000)
pry(main)&amp;gt; tx.outputs[0].type = carrot_type_script
pry(main)&amp;gt; tx.cell_deps &amp;lt;&amp;lt; carrot_cell_dep
pry(main)&amp;gt; tx.witnesses[0] = &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;
pry(main)&amp;gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(tx)
CKB::&lt;span style=&#34;font-style:italic&#34;&gt;RPCError&lt;/span&gt;: jsonrpc &lt;span style=&#34;font-style:italic&#34;&gt;error&lt;/span&gt;: {&lt;span style=&#34;font-style:italic&#34;&gt;:code&lt;/span&gt;=&amp;gt;-3, &lt;span style=&#34;font-style:italic&#34;&gt;:message&lt;/span&gt;=&amp;gt;&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;Script(ValidationFailure(-1))&amp;#34;&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you checked the transaction carefully, you will noticed that none of the output cells has data starting with &lt;code&gt;carrot&lt;/code&gt;. However we still run into validation faliure, it means our script must have a bug. Previously, you would run out of options here, you might go back to check the code, hoping you can see where it goes wrong. But that is not necessary now, you can just dump the transaction here, and feed it into a standalone CKB debugger to debug it!&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s dump the transaction together with its surrounding environment, into a local file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; CKB::MockTransactionDumper.new(api, tx).write(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot.json&amp;#34;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What you also need here, is to keep track of the carrot type script hash:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; carrot_type_script.compute_hash
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x039c2fba64f389575cdecff8173882b97be5f8d3bdb2bb0770d8a7e265b91933&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice depending on your environment you might get a different hash from what I have here.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s try &lt;a href=&#34;https://github.com/nervosnetwork/ckb-standalone-debugger&#34;&gt;ckb-standalone-debugger&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git clone https://github.com/nervosnetwork/ckb-standalone-debugger
$ cd ckb-standalone-debugger/bins
$ cargo build --release
$ ./target/release/ckb-debugger -l 0.0.0.0:2000 -g type -h 0x039c2fba64f389575cdecff8173882b97be5f8d3bdb2bb0770d8a7e265b91933 -t carrot.json&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Keep in mind you might need to tweak the carrot type script hash, or the path to &lt;code&gt;carrot.json&lt;/code&gt; depending on your environment. Now we can try connecting to the debugger via GDB in a differnet terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191012 bash
root@66e3b39e0dfd:/# cd /code
root@66e3b39e0dfd:/code# riscv64-unknown-elf-gdb carrot
GNU gdb (GDB) 8.3.0.20190516-git
Copyright (C) 2019 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.

For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
Reading symbols from carrot...
(gdb) target remote 192.168.1.230:2000
Remote debugging using 192.168.1.230:2000
0x00000000000100c6 in _start ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice &lt;code&gt;192.168.1.230&lt;/code&gt;, is the IP address of my workstation in my local network. It&amp;rsquo;s very likely you need to adjust that, since your computer might have a different IP address. Now we can try a normal GDB debugging session:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b main
Breakpoint 1 at 0x106b0: file carrot.c, line 6.
(gdb) c
Continuing.

Breakpoint 1, main (argc=0, argv=0x400000) at carrot.c:6
6         size_t index = 0;
(gdb) n
7         uint64_t len = 0;
(gdb) n
11          len = 6;
(gdb) n
12          memset(buffer, 0, 6);
(gdb) n
13          ret = ckb_load_cell_data(buffer, &amp;amp;len, 0, index, CKB_SOURCE_OUTPUT);
(gdb) n
14          if (ret == CKB_INDEX_OUT_OF_BOUND) {
(gdb) n
18          int cmp = memcmp(buffer, &amp;quot;carrot&amp;quot;, 6);
(gdb) n
19          if (cmp) {
(gdb) p cmp
$1 = -99
(gdb) p buffer[0]
$2 = 0 &#39;\000&#39;
(gdb) n
20            return -1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see where it goes wrong: the first byte in &lt;code&gt;buffer&lt;/code&gt; has value &lt;code&gt;0&lt;/code&gt;, which is different from &lt;code&gt;c&lt;/code&gt;, hence our buffer is different from &lt;code&gt;carrot&lt;/code&gt;. But instead of jumping to next iteration, the condition &lt;code&gt;if (cmp) {&lt;/code&gt; jumps to the true case, where &lt;code&gt;-1&lt;/code&gt; is returned, indicating a match to &lt;code&gt;carrot&lt;/code&gt;! And the reason to this, is that &lt;code&gt;memcmp&lt;/code&gt; would return &lt;code&gt;0&lt;/code&gt; when the 2 buffers are equal, and non-zero value when they are not. But instead of testing the return value of &lt;code&gt;memcmp&lt;/code&gt; is 0, we directly use it in the &lt;code&gt;if&lt;/code&gt; condition, since C would treat any non-zero value as true, &lt;code&gt;-99&lt;/code&gt; in this case would be treated as true. This is a typical C mistake for beginners, I hope you will never run into it :)&lt;/p&gt;

&lt;p&gt;Now we know the reason, it will be a trivial task to fix the bug in the carrot script, but what you just see here, is that we manage to dump the runtime state of an errored transaction from CKB, then debug it via GDB, which is a common tool in the industry! And your existing workflows and tools on top of GDB can also work here, isn&amp;rsquo;t that beautiful?&lt;/p&gt;

&lt;h1 id=&#34;repl-based-development-debugging&#34;&gt;REPL based Development/Debugging&lt;/h1&gt;

&lt;p&gt;However, GDB is only one part of the story in modern software development. Dynamic languages have largely taken the landscape, and many programmers are used to REPL baesd development/debugging workflow. This is totally different from GDB in a compiled languages, basically what you get is a running environment, and you can type in any code you want to interact with the environment, getting different results. As we will show here, CKB also has support for this type of development/debugging workflow :P&lt;/p&gt;

&lt;p&gt;Here we will use the &lt;a href=&#34;https://github.com/nervosnetwork/ckb-duktape&#34;&gt;ckb-duktape&lt;/a&gt; showcasing a REPL in JavaScript. But keep in mind this is merely a demo showing the workflow, there&amp;rsquo;s nothing preventing you from porting your favorite dynamic languages(whether it&amp;rsquo;s Ruby, Python, Lisp, etc.) to CKB, and start a REPL for that language.&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s try compiling duktape:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git clone https://github.com/nervosnetwork/ckb-duktape
$ cd ckb-duktape
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:bionic-20191012 bash
root@982d1e906b76:/# cd /code
root@982d1e906b76:/code# make
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/entry.c -c -o build/entry.o
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror duktape/duktape.c -c -o build/duktape.o
riscv64-unknown-elf-gcc build/entry.o build/duktape.o -o build/duktape -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/repl.c -c -o build/repl.o
riscv64-unknown-elf-gcc build/repl.o build/duktape.o -o build/repl -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
root@982d1e906b76:/code# exit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You will need the &lt;code&gt;build/repl&lt;/code&gt; binary generated here. Similar to the carrot example, let&amp;rsquo;s first deploy duktape REPL binary on CKB:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; api = CKB::API.new
pry(main)&amp;gt; wallet = CKB::Wallet.from_hex(api, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;&amp;lt;your private key&amp;gt;&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; wallet2 = CKB::Wallet.from_hex(api, CKB::Key.random_private_key)
pry(main)&amp;gt; duktape_repl_data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;build/repl&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; duktape_repl_data.bytesize
=&amp;gt; 283048
pry(main)&amp;gt; duktape_repl_tx_hash = wallet.send_capacity(wallet2.address, CKB::Utils.byte_to_shannon(300000), CKB::Utils.bin_to_hex(duktape_repl_data), &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 310000)
pry(main)&amp;gt; duktape_repl_data_hash = CKB::Blake2b.hexdigest(duktape_repl_data)
pry(main)&amp;gt; duktape_repl_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: duktape_repl_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; duktape_repl_cell_dep = CKB::Types::CellDep.new(&lt;span style=&#34;font-style:italic&#34;&gt;out_point&lt;/span&gt;: CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: duktape_repl_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We will also need to create a transaction containing the duktape script, I&amp;rsquo;m building a simpler one, but you are free to include more data so you can play with CKB:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(100), &lt;span style=&#34;font-style:italic&#34;&gt;use_dep_group&lt;/span&gt;: &lt;span style=&#34;&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;font-style:italic&#34;&gt;fee&lt;/span&gt;: 5000)
pry(main)&amp;gt; tx.outputs[0].type = duktape_repl_type_script
pry(main)&amp;gt; tx.cell_deps &amp;lt;&amp;lt; duktape_repl_cell_dep
pry(main)&amp;gt; tx.witnesses[0] = &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;rsquo;s also dump it to file, and check out duktape type script hash:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; CKB::MockTransactionDumper.new(api, tx).write(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;duktape.json&amp;#34;&lt;/span&gt;)
=&amp;gt; 2765824
pry(main)&amp;gt; duktape_repl_type_script.compute_hash
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0xa8b79392c857e29cb283e452f2cd48a8e06c51af64be175e0fe0e2902c482837&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Different from last time, we don&amp;rsquo;t need to start GDB, we can start the program directly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ./target/release/ckb-debugger -g type -h 0xa8b79392c857e29cb283e452f2cd48a8e06c51af64be175e0fe0e2902c482837 -t duktape.json
duk&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You will see a &lt;code&gt;duk&amp;gt;&lt;/code&gt; prompt for you to enter JS code! Again if you run into errors, check if you need to change to a different type script hash, or use the correct path to &lt;code&gt;duktape.json&lt;/code&gt;. We can see normal JS code works here:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;duk&amp;gt; print(1 + 2)
3
= undefined
duk&amp;gt; &lt;span style=&#34;font-weight:bold&#34;&gt;function&lt;/span&gt; foo(a) { &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; a + 1; }
= undefined
duk&amp;gt; foo(123)
= 124&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There&amp;rsquo;re also CKB related functions you can use:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;duk&amp;gt; var hash = CKB.load_script_hash()
= undefined
duk&amp;gt; &lt;span style=&#34;font-weight:bold&#34;&gt;function&lt;/span&gt; buf2hex(buffer) { &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; Array.prototype.map.call(new Uint8Array(buffer), &lt;span style=&#34;font-weight:bold&#34;&gt;function&lt;/span&gt;(x) { &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;00&amp;#39;&lt;/span&gt; + x.toString(16)).slice(-2); }).join(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;); }
= undefined
duk&amp;gt; buf2hex(hash)
= a8b79392c857e29cb283e452f2cd48a8e06c51af64be175e0fe0e2902c482837&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice the script hash we get here is exactly the current executing type script hash! This verifies CKB syscalls do work here, we can also try more interesting stuff&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;duk&amp;gt; print(CKB.SOURCE.OUTPUT)
2
= undefined
duk&amp;gt; print(CKB.CELL.CAPACITY)
0
= undefined
duk&amp;gt; capacity_field = CKB.load_cell_by_field(0, 0, CKB.SOURCE.OUTPUT, CKB.CELL.CAPACITY)
= [object ArrayBuffer]
duk&amp;gt; buf2hex(capacity_field)
= 00e40b5402000000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This &lt;code&gt;00e40b5402000000&lt;/code&gt; might looks slightly mysterious to you at first, but notice that RISC-V uses little endian, so if we reverse the byte order here, we would get &lt;code&gt;00000002540be400&lt;/code&gt;, which is exactly &lt;code&gt;10000000000&lt;/code&gt; in decimal. Also keep in mind that in CKB capacity is stored in shannons, so &lt;code&gt;10000000000&lt;/code&gt; is exactly &lt;code&gt;100&lt;/code&gt; bytes, which is the same amount of coins we want to transfer when we generate the transaction above! Now you can see how you can play with CKB in this duktape environment :)&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Now we&amp;rsquo;ve introduced 2 types of debugging experience in CKB, feel free to play with either one you like(or actually both of them). I can&amp;rsquo;t wait to see all the amazing applications you can build with CKB :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to CKB Script Programming 4: WebAssembly on CKB</title>
      <link>https://xuejie.space/2019_10_09_introduction_to_ckb_script_programming_wasm_on_ckb/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuejie.space/2019_10_09_introduction_to_ckb_script_programming_wasm_on_ckb/</guid>
      <description>

&lt;p&gt;Since we made the choice to build CKB&amp;rsquo;s virtual machine with RISC-V, we&amp;rsquo;ve been getting a question almost everyday: why don&amp;rsquo;t you build your virtual machine on WebAssembly like everyone else does?&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;re many reasons behind this choice, making it a perfect choice for another article or even a conference talk. But fundamentally there lies one important reason: building software is all about finding the right abstraction, and we believe RISC-V is a better abstraction than WebAssembly for public permissionless blockchain.&lt;/p&gt;

&lt;p&gt;While WebAssembly is already a huge advancement over higher level programming langauges as well as the first generation blockchain virtual machines, RISC-V works at a much lower level than WebAssembly, making it a more suitable choice for public blockchains which are designed to run for decades to come.&lt;/p&gt;

&lt;p&gt;But that still leaves one question unanswered: a significant portion of the blockchain industry is betting on WebAssembly, contributing an (arguably) better ecosystem building on WebAssembly powered dapps. How can CKB compete with that? As mentioned above, RISC-V is actually a lower level of abstraction than WebAssembly, we can port existing WebAssembly programs, and run them on CKB VM directly. This way, we can enjoy the flexibility and stability provided by RISC-V, while also embracing the WebAssembly ecosystem.&lt;/p&gt;

&lt;p&gt;In this article, we will show how you can run WebAssembly programs in CKB VM, we will also show that it actually has more benefits running this way than directly using a WebAssembly VM.&lt;/p&gt;

&lt;p&gt;Personally, while I believe WebAssembly has some interesting features enabling different use cases, I don&amp;rsquo;t believe WebAssembly has a better ecosystem in the blockchain space. If you look around, there are probably just 2 mature choices for building dapps in a WebAssembly-based blockchain: Rust, and AssemblyScript. People keep bragging about WebAssembly&amp;rsquo;s ability to support arbitrary languages in a single abstract VM(I personally refuse to call WebAssembly low-level VM), but it really just comes down to one of the 2 choices here to build a real dapp. I think we probably have different definitions if we can call 2 supported languages a good VM ecosystem. There are some &lt;a href=&#34;https://github.com/tweag/asterius&#34;&gt;other languages&lt;/a&gt; playing catching up here, but they are not yet at stable phase to count as a richful ecosystem. While some &lt;a href=&#34;https://github.com/forest-lang/forest-compiler&#34;&gt;interesting langauges&lt;/a&gt; have potentials in a WebAssembly based environment, no one pays attention to support them. And if you look hard enough, it also remains a question if 2 different blockchains using WebAssembly can share contracts with each other. Of course one might say: &amp;ldquo;well it&amp;rsquo;s just a matter of time, given time more vibrant WebAssembly ecosystem will sprout&amp;rdquo;, but the same argument could apply anywhere: why given time, an ecosystem for RISC-V won&amp;rsquo;t be better?&lt;/p&gt;

&lt;p&gt;But enough for the rant, let&amp;rsquo;s just assume for now, WebAssembly does have a blockchain ecosystem, we can show that the 2 widely used choices, AssemblyScript and Rust, are all supported in a CKB VM environment.&lt;/p&gt;

&lt;h1 id=&#34;assemblyscript&#34;&gt;AssemblyScript&lt;/h1&gt;

&lt;p&gt;I believe no words speak better than a demo you can play with. So let&amp;rsquo;s try the official AssemblyScript and run the compiled program on CKB. We will just use the official example in AssemblyScript&amp;rsquo;s &lt;a href=&#34;https://github.com/forest-lang/forest-compiler&#34;&gt;introduction page&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat fib.ts
export function fib(n: i32): i32 {
  var a = 0, b = 1;
    for (let i = 0; i &amp;lt; n; i++) {
        let t = a + b; a = b; b = t;
  }
  return b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please refer to AssemblyScript&amp;rsquo;s documentation on how to install it. For convenience, I have some steps that you can just copy-paste here.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/AssemblyScript/assemblyscript.git
$ cd assemblyscript
$ npm install
$ bin/asc ../fib.ts -b ../fib.wasm -O3
$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have a compiled WebAssembly program to use here. What we can do then, is invoke a program named &lt;a href=&#34;https://github.com/WebAssembly/wabt/tree/master/wasm2c&#34;&gt;wasm2c&lt;/a&gt; to compile it to C source file, then compile it via a RISC-V compiler to a RISC-V program, and run it on CKB VM.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m sure you would ask: but this is a hack! It sort of does a decompilation of the WASM program then make it work, you are cheating here. The answer to this question, is yes and no:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On the one hand, yes I&amp;rsquo;m cheating here, but the question I&amp;rsquo;m gonna raise in response is: all we should care, is the end result, if the result is good enough, why should we care if this is cheating? In addition, modern compiler is already complicated enough like a total black box, how can we be sure this decompilation will achieve worse result?&lt;/li&gt;
&lt;li&gt;On the other hand, this is just one way of transforming WebAssembly into RISC-V. There&amp;rsquo;re numerous other ways in which you can achieve the same result. We will come back to this in the Recap section later.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s fire up &lt;code&gt;wasm2c&lt;/code&gt; and transform the WebAssembly program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/WebAssembly/wabt
$ cd wabt
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
$ cd ../..
$ wabt/bin/wasm2c fib.wasm -o fib.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will see a pair of &lt;code&gt;fib.c&lt;/code&gt; and &lt;code&gt;fib.h&lt;/code&gt; file in current directory, they contain the transformation result of the WebAssembly program, and when compiled and called correctly, they will achieve the same feature as the WebAssembly program.&lt;/p&gt;

&lt;p&gt;We can use a small wrapper C file to invoke the WebAssembly program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat main.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#include &amp;quot;fib.h&amp;quot;

int main(int argc, char** argv) {
  if (argc &amp;lt; 2) return 2;

  u8 x = atoi(argv[1]);

  init();

  u8 result = Z_fibZ_ii(x);

  return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This just reads an integer from a CLI argument, invokes the fibonacci function in the WebAssembly program, then return the result. Let&amp;rsquo;s try compile it first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
(docker) $ cd /code
(docker) $ riscv64-unknown-elf-gcc -o fib_riscv64 -O3 -g main.c fib.c /code/wabt/wasm2c/wasm-rt-impl.c -I /code/wabt/wasm2c
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `__retain&#39;:
/code/fib.c:1602: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `i32_load&#39;:
/code/fib.c:42: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `f17&#39;:
/code/fib.c:1564: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/fib.c:1564: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o: in function `f6&#39;:
/code/fib.c:1011: undefined reference to `Z_envZ_abortZ_viiii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccfUDYhE.o:/code/fib.c:1012: more undefined references to `Z_envZ_abortZ_viiii&#39; follow
collect2: error: ld returned 1 exit status
(docker) $ exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As shown above, there&amp;rsquo;s an error here. It tells us there&amp;rsquo;s an &lt;code&gt;Z_envZ_abortZ_viiii&lt;/code&gt; function not defined. Let&amp;rsquo;s dive into why this happened.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s transform the original WebAssembly file into a human readable form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wabt/bin/wasm2wat fib.wasm -o fib.wast
$ cat fib.wast | grep &amp;quot;(import&amp;quot;
(import &amp;quot;env&amp;quot; &amp;quot;abort&amp;quot; (func (;0;) (type 2)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the problem is that WebAssembly can import external functions, when invoking, provides additional functionalities. In fact, the famous &lt;a href=&#34;https://wasi.dev/&#34;&gt;WASI&lt;/a&gt; is implemented based on the &lt;code&gt;import&lt;/code&gt; feature. Later we shall see &lt;code&gt;import&lt;/code&gt; can be used to implement more interesting features that are not possible in WebAssembly based blockchain virtual machines.&lt;/p&gt;

&lt;p&gt;For now, let&amp;rsquo;s provide an abort implementation to fix the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat main.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#include &amp;quot;fib.h&amp;quot;

void (*Z_envZ_abortZ_viiii)(u32, u32, u32, u32);

void env_abort(u32 a, u32 b, u32 c, u32 d) {
  abort();
}

int main(int argc, char** argv) {
  if (argc &amp;lt; 2) return 2;

  u8 x = atoi(argv[1]);

  Z_envZ_abortZ_viiii = &amp;amp;env_abort;

  init();

  u8 result = Z_fibZ_ii(x);

  return result;
}
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
(docker) $ cd /code
(docker) $ riscv64-unknown-elf-gcc -o fib_riscv64 -O3 -g main.c fib.c /code/wabt/wasm2c/wasm-rt-impl.c -I /code/wabt/wasm2c
(docker) $ exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course you can test the compiled &lt;code&gt;fib_riscv64&lt;/code&gt; program on CKB. But as a trick, there&amp;rsquo;s a simple CKB VM &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm-test-suite/tree/master/binary/src&#34;&gt;binary&lt;/a&gt; in the &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm-test-suite&#34;&gt;test suite&lt;/a&gt; we can use the run this particular program. It&amp;rsquo;s worth mentioning that this CKB VM binary works slightly different from the VM in CKB. It suffices to test WebAssembly programs in current example. But for testing proper CKB script, you might want to use the newly built &lt;a href=&#34;https://github.com/nervosnetwork/ckb-standalone-debugger&#34;&gt;standalone debugger&lt;/a&gt;, which follows all CKB semantics. Later posts will explain how the debugger works.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try compile the binary in test suite and run the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/nervosnetwork/ckb-vm-test-suite
$ cd ckb-vm-test-suite
$ git clone https://github.com/nervosnetwork/ckb-vm
$ cd binary
$ cargo build --release
$ cd ../..
$ ckb-vm-test-suite/binary/target/release/asm64 fib_riscv64 5
Error result: Ok(8)
$ ckb-vm-test-suite/binary/target/release/asm64 fib_riscv64 10
Error result: Ok(89)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The error here is slightly misleading, the binary will treat any non-zero result from the program as errors. Since the program tested return the fibonacci calculation result as the return value, the binary will treat the return value(which is most likely non-zero) as error, but we can see that the actual error value contains the correct fibonacci value.&lt;/p&gt;

&lt;p&gt;Now we proves AssemblyScript program indeed works on CKB VM! I&amp;rsquo;m sure more complicated programs might run into errors which need separate tweaking, but you already get the workflow and know where to look for when error happens :)&lt;/p&gt;

&lt;h1 id=&#34;rust&#34;&gt;Rust&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ve already seen simpler examples in the AssemblyScript part. Let&amp;rsquo;s try something more interesting in the Rust part: can we do a whole signature verification in Rust code?&lt;/p&gt;

&lt;p&gt;Turns out yes we can! But this is signficantly more than what we can fit in a blog post. I&amp;rsquo;ve prepared a &lt;a href=&#34;https://github.com/nervosnetwork/wasm-secp256k1-test&#34;&gt;demo project&lt;/a&gt; showcasing this. It uses a pure Rust implemented &lt;a href=&#34;https://github.com/paritytech/libsecp256k1&#34;&gt;secp256k1 library&lt;/a&gt; to do signature verification. If you follow the instructions in the README, you can reproduce the exact steps of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compile a complicated Rust program into WebAssembly&lt;/li&gt;
&lt;li&gt;Transform the WebAssembly program into RISC-V&lt;/li&gt;
&lt;li&gt;Run the resulting RISC-V program on CKB VM&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;enhancements-to-webassembly&#34;&gt;Enhancements to WebAssembly&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s one additional thing we want to mention: if you check out the &lt;code&gt;bindgen&lt;/code&gt; branch of the &lt;a href=&#34;https://github.com/nervosnetwork/wasm-secp256k1-test/tree/bindgen&#34;&gt;Rust secp256k1 demo repository&lt;/a&gt;, and try the same steps, you will run into the following errors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `core::result::unwrap_failed&#39;:
/code/secp.c:342: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:344: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:344: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:347: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:350: undefined reference to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o:/code/secp.c:353: more undefined references to `Z___wbindgen_placeholder__Z___wbindgen_describeZ_vi&#39; follow
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_store&#39;:
/code/secp.c:56: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_load&#39;:
/code/secp.c:42: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_store&#39;:
/code/secp.c:56: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:56: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_set_nullZ_vi&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /tmp/ccYMiL3C.o: in function `i32_load&#39;:
/code/secp.c:42: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_growZ_ii&#39;
/riscv/lib/gcc/riscv64-unknown-elf/8.3.0/../../../../riscv64-unknown-elf/bin/ld: /code/secp.c:42: undefined reference to `Z___wbindgen_anyref_xform__Z___wbindgen_anyref_table_growZ_ii&#39;
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following the same steps in the AssemblyScript examples, we can certain &lt;code&gt;imports&lt;/code&gt; in the WebAssembly file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wabt/bin/wasm2wat wasm_secp256k1_test.wasm -o secp.wat
$ cat secp.wat | grep &amp;quot;(import&amp;quot;
(import &amp;quot;__wbindgen_placeholder__&amp;quot; &amp;quot;__wbindgen_describe&amp;quot; (func $__wbindgen_describe (type 3)))
(import &amp;quot;__wbindgen_anyref_xform__&amp;quot; &amp;quot;__wbindgen_anyref_table_grow&amp;quot; (func $__wbindgen_anyref_table_grow (type 4)))
(import &amp;quot;__wbindgen_anyref_xform__&amp;quot; &amp;quot;__wbindgen_anyref_table_set_null&amp;quot; (func $__wbindgen_anyref_table_set_null (type 3)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those are actually binding environment functions needed in the Rust &lt;a href=&#34;https://github.com/rustwasm/wasm-bindgen&#34;&gt;wasm-bindgen&lt;/a&gt;. We will continue to work to provide the bindings compatible with CKB environment. But let&amp;rsquo;s take a step back and think about this now: the environment functions needed here, are not part of WebAssembly standard. What&amp;rsquo;s required in the standard, is that when an import entry cannot be found, the WebAssembly VM is expected to halt execution with an errors. To achieve different features, different WebAssembly based blockchains might inject different imports here, making it hard to write a WebAssembly program that&amp;rsquo;s compatible across different blockchains.&lt;/p&gt;

&lt;p&gt;In the CKB environment, however, we can attach any environment functions as we like, hence supporting all WebAssembly programs which are targeting different blockchains. What&amp;rsquo;s more, we can use &lt;code&gt;imports&lt;/code&gt; as we like to introduce new features to an existing WebAssembly programs, since the import functions are shipped together with the WebAssembly program, CKB itself doesn&amp;rsquo;t have to do anything to support this, all the magic happens right within a single CKB script. For a WebAssembly powered blockchain, those environment functions are most likely to be fixed and part of the consensus rules, you cannot introduce new ones as you wish. Similarly, this tranformation based workflow on CKB will make it far easier to support new WebAssembly features, such as garbage collection, or threading, it really is just a matter of shipping the support features you need as part of your CKB script, there&amp;rsquo;s no need to wait another 6 months for the next hardfork when a WebAssembly virtual machine gets updated, if it&amp;rsquo;s updated.&lt;/p&gt;

&lt;h1 id=&#34;it-s-about-ease-of-implementation&#34;&gt;It&amp;rsquo;s About Ease of Implementation&lt;/h1&gt;

&lt;p&gt;You might have one question: &amp;ldquo;I get it, you have WebAssembly on RISC-V, but I could also have RISC-V on WebAssembly! WebAssembly is flexible!&amp;rdquo;. In a sense, this is true, once a language or a VM surpasses a certain level of flexibility, it can be used to build many (even crazy) things. The first version of &lt;a href=&#34;https://bellard.org/jslinux/tech.html&#34;&gt;jslinux&lt;/a&gt; which emulates full x86 was even written in pure JavaScript! But the other side of the problem, is ease of implementation. Building WebAssembly on RISC-V feels more natural, since WebAssembly abstracts at a higher level with many high level features, such as higher level contrl flows, garbage collection, etc. RISC-V, on the other hand, really emulates what a real CPU can do, it is a very thin layer on top of the actual CPU running inside of the computer. So while both directions are possible indeed, certain features are easier to implement in the WebAssembly on RISC-V direction, while roadblocks might sit in front of you in the RISC-V on WebAssembly direction.&lt;/p&gt;

&lt;p&gt;One alternative example is EVM, EVM has been advocating turing complete for years, but the sad truth is that it&amp;rsquo;s close to impossible to build arbitrary complicated algorithsm on EVM: either the coding part is too difficult or gas consumption will be unreasonable. People have to come up with all kinds of hacks so as to introduce latest algorithms on EVM, we can only have reasonable blake2b algorithms in EVM when Istanbul hardfork lands. What about many other algorithms?&lt;/p&gt;

&lt;p&gt;All of those reflect our rationale behind the RISC-V choice: we want to find the minimal layer on top of this generation&amp;rsquo;s CPU architecture, and RISC-V is the most transparent model we can expose to the blockchain world while ensuring security and performance. Any different models, such as WebAssembly, EVM, etc., should be one layer on top of the RISC-V model, and can be naturally implemented via the RISC-V model. The other direction, however, might not feel so smooth at all.&lt;/p&gt;

&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;

&lt;p&gt;Here we demonstrated that you can run non-trivial WebAssembly programs on CKB VM. But we do want to point out this workflow is not without its problems. One gotcha is performance, our preliminary testing shows that the WebAssembly based secp256k1 demo runs 30 times slower than a similar C based implementation compiled directly to CKB VM. After some investigation, we believe this is due to the following problems&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Due to how memory works in WebAssembly, wasm2c has to first put data segments in the code in plain C array, then when booting, allocate enough memory, then do memcpy to copy the data into the allocated memory. For the secp256k1 example, this means every boot of the program has to copy the 1MB pre-computed multiplication table. Combining with the fact that our RISC-V program now uses newlib, which contains a naive memcpy implementation optimized for code size over speed, this can significantly slow down the program.&lt;/li&gt;
&lt;li&gt;While wasm2c can deliver good performance for simpler programs, for a sophisticated and heavily optimized algorithm like secp256k1, the transformation layer could mean that many optimization chances are lost, hence making it slower than a direct implementation compiled directly to RISC-V&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Luckily, the problems here are totally solvable. The above mentioned workflow is one way we can translate WebAssembly programs to RISC-V programs, but it&amp;rsquo;s absolutely not the only way to achieve that. Like we mentioned above, the transformation layer hinders optimization opportunities, what if we bring in modern compilers to unleash all the possible optimizations here?&lt;/p&gt;

&lt;p&gt;There is already &lt;a href=&#34;https://github.com/wasmerio/wasmer/tree/master/lib/llvm-backend&#34;&gt;progress&lt;/a&gt; being done which translates a WebAssembly program via LLVM into native code. The performance obtained here, is really good. Since LLVM 9 &lt;a href=&#34;https://riscv.org/2019/09/llvm-9-releases-with-official-risc-v-target-support-asm-goto-clang-9-and-more-vincy-davis-packt-pub/&#34;&gt;officially supports&lt;/a&gt; RISC-V now, it&amp;rsquo;s perfectly possible to change the code so LLVM generates RISC-V assembly instead of x86_64 assembly. This way we can translate WebAssembly program via LLVM directly into a RISC-V program, enjoying all the advanced optimizations LLVM can performn on our code.&lt;/p&gt;

&lt;p&gt;As a result, our current solution documented in this post shows this path is totally possible while achieving good enough performance for many existing cases(e.g., many type scripts can be written in Rust for safety, while the performance is not a big problem), this new LLVM solution can provide far better performance for the same workflow in the future. It&amp;rsquo;s just a matter of time for us to find the time to work on this.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to CKB Script Programming 3: UDT</title>
      <link>https://xuejie.space/2019_09_06_introduction_to_ckb_script_programming_udt/</link>
      <pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuejie.space/2019_09_06_introduction_to_ckb_script_programming_udt/</guid>
      <description>

&lt;p&gt;CKB&amp;rsquo;s cell model and VM enables many new use cases. However that doesn&amp;rsquo;t mean we need to ditch existing ones. One common use in existing blockchains, is to issue new tokens with special purpose/meaning from the token issuer. In Ethereum, we call those ERC20 tokens, let&amp;rsquo;s see how we can build a similar concept in CKB. To distinguish from ERC20, we call the tokens issued in CKB &lt;code&gt;user defined token&lt;/code&gt;, or UDT for short.&lt;/p&gt;

&lt;p&gt;This post uses CKB v0.20.0 in the examples. Specifically, I&amp;rsquo;m using the following commit in each project:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb&#34;&gt;ckb&lt;/a&gt;: 472252ac5333b2b19ea3ec50d54e68b627bf6ac5&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb-duktape&#34;&gt;ckb-duktape&lt;/a&gt;: 55849c20b43a212120e0df7ad5d64b2c70ea51ac&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nervosnetwork/ckb-sdk-ruby&#34;&gt;ckb-sdk-ruby&lt;/a&gt;: 1c2a3c3f925e47e421f9e3c07164ececf3b6b9f6&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;data-model&#34;&gt;Data Model&lt;/h1&gt;

&lt;p&gt;While Ethereum has a unique storage space for each contract account, CKB spreads data among multiple cells. A cell&amp;rsquo;s lock &amp;amp; type script then tells which account the cell belongs to, as well as how you can interact with the cell. The consequence of this, is that unlike ERC20 which stores all token users&amp;rsquo; balances in the ERC20 contract&amp;rsquo;s storage space, in CKB we will need a new design to store the balances of UDT users.&lt;/p&gt;

&lt;p&gt;We could, of course, designate a special cell to keep the balances of all UDT users. This solution would look a lot like Ethereum&amp;rsquo;s ERC20 design. But several problems arise:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The token issuer would have to provide storage space for keeping all the users&amp;rsquo; balances. As the number of user grows, the storage space would also grow, in CKB&amp;rsquo;s economic model, this won&amp;rsquo;t be an effective design.&lt;/li&gt;
&lt;li&gt;Consider that updating a cell in CKB is essentially destroying the old cell and re-create a new one, having a single cell with all balances would create a bottleneck: every action which needs to update UDT balance would have to update the one and only cell. People will compete on using the cell.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While there are solutions which can mitigate or even solve the above problems, we started to question the basic design here: does it really make sense to keep all UDTs in a single place? Once transferred, the UDTs really should belong to the receiver, why should the balance still be kept in a central place?&lt;/p&gt;

&lt;p&gt;That leads to our proposed design here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A special type script denotes that the cell stores UDTs.&lt;/li&gt;
&lt;li&gt;The first 4 bytes of the cell data contains the amount of UDTs in current cell.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This design has several implications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The storage cost for a UDT cell is always constant, it is irrelevant to the amount of UDTs stored in the cell.&lt;/li&gt;
&lt;li&gt;A user can transfer either all or part of the UDTs in a cell to others&lt;/li&gt;
&lt;li&gt;In practice, there might be numerous cells containing the same UDTs.&lt;/li&gt;
&lt;li&gt;The lock script used to guard a UDT is decoupled from the UDT itself.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each token user then keeps their UDTs in their own cells. They are responsible for providing the storage space for the UDTs, and ensure their own tokens are secure. This way UDTs can truly belong to each individual UDT user.&lt;/p&gt;

&lt;p&gt;One question remains here: if tokens are stored in numerous cells belonging to each user instead of a single place, how can we ensure the tokens are indeed created by token issuer? What if someone forges tokens on their own? In Ethereum, this is probably a problem, but as we shall see in this post, a type script in CKB can prevent all those attacks, ensuring your token is safe.&lt;/p&gt;

&lt;h1 id=&#34;writing-the-udt-script&#34;&gt;Writing the UDT Script&lt;/h1&gt;

&lt;p&gt;Given the above design, a minimal UDT type script should guard the following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In a UDT transfer transaction, the sum of UDTs in the output cells should equal the sum of UDTs in the input cells.&lt;/li&gt;
&lt;li&gt;Only the token issuer can generate new tokens in the initial token creation process.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This might sound a little ambitious, but we will see that with a type script and some CKB&amp;rsquo;s unique design patterns, the eagle can be landed :P&lt;/p&gt;

&lt;p&gt;For simplicity, we will write the UDT script here in pure JavaScript, while a C version might help in saving cycles, the functionality will be the same.&lt;/p&gt;

&lt;p&gt;First, we will need to loop through all input cells and gather the sum of UDTs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/udt.js b/udt.js
index e69de29..4a20bd0 100644
--- a/udt.js
+++ b/udt.js
@@ -0,0 +1,17 @@
+var input_index = 0;
+var input_coins = 0;
+var buffer = new ArrayBuffer(4);
+var ret = CKB.CODE.INDEX_OUT_OF_BOUND;
+
+while (true) {
+  ret = CKB.raw_load_cell_data(buffer, 0, input_index, CKB.SOURCE.GROUP_INPUT);
+  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
+    break;
+  }
+  if (ret !== 4) {
+    throw &amp;quot;Invalid input cell!&amp;quot;;
+  }
+  var view = new DataView(buffer);
+  input_coins += view.getUint32(0, true);
+  input_index += 1;
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As explained in the previous post, CKB requires us to use a loop to iterate through all inputs in the same &lt;code&gt;group&lt;/code&gt; and fetch the data. In C we would use &lt;code&gt;ckb_load_cell_data&lt;/code&gt;, which is wrapped into a JS function &lt;code&gt;CKB.raw_load_cell_data&lt;/code&gt;. As indicated by the ArrayBuffer, we are only interested in the first 4 bytes of the cell data, since those 4 bytes will contain the amount of UDTs.&lt;/p&gt;

&lt;p&gt;Note that here we perform a simple add operation on &lt;code&gt;input_coins&lt;/code&gt;, this is very dangerous. We are doing it just for simplicity, in a production setting, you should check if the value will hold in a 32-bit integer value. Higher precision number types should be used if needed.&lt;/p&gt;

&lt;p&gt;Similarly, we can fetch the sum of output coins and do the comparision:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/udt.js b/udt.js
index 4a20bd0..e02b993 100644
--- a/udt.js
+++ b/udt.js
@@ -15,3 +15,23 @@ while (true) {
   input_coins += view.getUint32(0);
   input_index += 1;
 }
+
+var output_index = 0;
+var output_coins = 0;
+
+while (true) {
+  ret = CKB.raw_load_cell_data(buffer, 0, output_index, CKB.SOURCE.GROUP_OUTPUT);
+  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
+    break;
+  }
+  if (ret !== 4) {
+    throw &amp;quot;Invalid output cell!&amp;quot;;
+  }
+  var view = new DataView(buffer);
+  output_coins += view.getUint32(0, true);
+  output_index += 1;
+}
+
+if (input_coins !== output_coins) {
+  throw &amp;quot;Input coins do not equal output coins!&amp;quot;;
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is almost all we need to validate the first rule: the sum of UDTs in the output cells should equal the sum of UDTs in the input cells. In other words, with this type script now, no one will be able to forge new tokens. Isn&amp;rsquo;t that wonderful?&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s one quirk: when we say &lt;code&gt;no one&lt;/code&gt; will be able to forge new tokens, we really mean &lt;code&gt;no one&lt;/code&gt;, including the token issuer! This is no good, we need to add an exception so the token issuer can create the tokens first, but no one will be able to do that after. Is there a way to do that?&lt;/p&gt;

&lt;p&gt;Yes there is! But the answer reads like a riddle, so please read this paragraph carefully if I lost you the first time: a type script consist of 2 parts: a code hash denoting the actual code, and args used by the type script. 2 type scripts with different args will be treated 2 different type scripts. The trick here, is to allow the token issuer to create a cell with a new type script, that no one will be able to create again, so if we put something in the args part that is not be able to included again, the problem will be solved.&lt;/p&gt;

&lt;p&gt;Now think about this problem: what cannot be included in a blockchain twice? An OutPoint in a transaction input! The first time we include an OutPoint as a transaction input, the referenced cell will be consumed, if someone later include it again, it will create a double-spending error, which is exactly what we use blockchain for.&lt;/p&gt;

&lt;p&gt;And we have the answer now! The full validation flow of a minimal UDT type script in CKB, is as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First gather the sum of all UDTs in the input cells and the sum of all UDTs in the output cells, if they are equaled, the type script exits with a success status.&lt;/li&gt;
&lt;li&gt;Check if the first argument of the type script matches the first OutPoint in current transaction, if they match, exit with a success status.&lt;/li&gt;
&lt;li&gt;Otherwise exit with a failure status&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you are still with me here, you will see that step 1 corresponds to a normal UDT transfer, while step 2 corresponds to the initial token creation process.&lt;/p&gt;

&lt;p&gt;This is what we mean by CKB&amp;rsquo;s unique design pattern: by using an input OutPoint as a script argument, we can create a unique script that cannot be forged again:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If an attacker tries to use the same argument, the script will validate that the first input OutPoint in the transaction does not match the argument, hence invalidates the transaction;&lt;/li&gt;
&lt;li&gt;If the attacker tries to use the same argument and fill in the argument as the first input OutPoint, it will create a double-spent error, also invalidates the transaction;&lt;/li&gt;
&lt;li&gt;If the attacker tries to use a different argument, CKB will recognize that the different argument leads to a different type script, hence generating a different UDT.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This simple yet powerful pattern thus ensures the UDTs stay safe while enjoying the benefits that they can be transferred freely among many different cells. To the best of our knowledge, this pattern is not possible yet in many other blockchains which claim to be &lt;code&gt;flexible&lt;/code&gt; or &lt;code&gt;programmable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we can finally complete the UDT script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/contract.js b/contract.js
deleted file mode 100644
index e69de29..0000000
diff --git a/udt.js b/udt.js
index e02b993..cd443bf 100644
--- a/udt.js
+++ b/udt.js
@@ -1,3 +1,7 @@
+if (CKB.ARGV.length !== 1) {
+  throw &amp;quot;Requires only one argument!&amp;quot;;
+}
+
 var input_index = 0;
 var input_coins = 0;
 var buffer = new ArrayBuffer(4);
@@ -33,5 +37,17 @@ while (true) {
 }
 
 if (input_coins !== output_coins) {
-  throw &amp;quot;Input coins do not equal output coins!&amp;quot;;
+  if (!((input_index === 0) &amp;amp;&amp;amp; (output_index === 1))) {
+    throw &amp;quot;Invalid token issuing mode!&amp;quot;;
+  }
+  var first_input = CKB.load_input(0, 0, CKB.SOURCE.INPUT);
+  if (typeof first_input === &amp;quot;number&amp;quot;) {
+    throw &amp;quot;Cannot fetch the first input&amp;quot;;
+  }
+  var hex_input = Array.prototype.map.call(
+    new Uint8Array(first_input),
+    function(x) { return (&#39;00&#39; + x.toString(16)).slice(-2); }).join(&#39;&#39;);
+  if (CKB.ARGV[0] != hex_input) {
+    throw &amp;quot;Invalid creation argument!&amp;quot;;
+  }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it, with 53 lines of code or 1372 bytes, we&amp;rsquo;ve completed a minimal UDT type script in CKB. Notice I don&amp;rsquo;t even use a minimizer here, with any decent JS minimizer, we should be able to get a much more compact type script. Of course this is a production ready script, but it suffices to show a simple script is enough to handle important tasks in CKB.&lt;/p&gt;

&lt;h1 id=&#34;deploying-to-ckb&#34;&gt;Deploying to CKB&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m not like &lt;a href=&#34;https://hacks.mozilla.org/2019/09/debugging-webassembly-outside-of-the-browser/&#34;&gt;some other organizations&lt;/a&gt; who prefer to only show you a video and a provocative post which hide how they did it and the accompanying problems. I believe no post is fun without actual code and steps to play with it. And here&amp;rsquo;s how you can use the above UDT script on CKB:&lt;/p&gt;

&lt;p&gt;In case you might need it, here&amp;rsquo;s the full UDT script without diff format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat udt.js
if (CKB.ARGV.length !== 1) {
  throw &amp;quot;Requires only one argument!&amp;quot;;
}

var input_index = 0;
var input_coins = 0;
var buffer = new ArrayBuffer(4);
var ret = CKB.CODE.INDEX_OUT_OF_BOUND;

while (true) {
  ret = CKB.raw_load_cell_data(buffer, 0, input_index, CKB.SOURCE.GROUP_INPUT);
  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
    break;
  }
  if (ret !== 4) {
    throw &amp;quot;Invalid input cell!&amp;quot;;
  }
  var view = new DataView(buffer);
  input_coins += view.getUint32(0, true);
  input_index += 1;
}

var output_index = 0;
var output_coins = 0;

while (true) {
  ret = CKB.raw_load_cell_data(buffer, 0, output_index, CKB.SOURCE.GROUP_OUTPUT);
  if (ret === CKB.CODE.INDEX_OUT_OF_BOUND) {
    break;
  }
  if (ret !== 4) {
    throw &amp;quot;Invalid output cell!&amp;quot;;
  }
  var view = new DataView(buffer);
  output_coins += view.getUint32(0, true);
  output_index += 1;
}

if (input_coins !== output_coins) {
  if (!((input_index === 0) &amp;amp;&amp;amp; (output_index === 1))) {
    throw &amp;quot;Invalid token issuing mode!&amp;quot;;
  }
  var first_input = CKB.load_input(0, 0, CKB.SOURCE.INPUT);
  if (typeof first_input === &amp;quot;number&amp;quot;) {
    throw &amp;quot;Cannot fetch the first input&amp;quot;;
  }
  var hex_input = Array.prototype.map.call(
    new Uint8Array(first_input),
    function(x) { return (&#39;00&#39; + x.toString(16)).slice(-2); }).join(&#39;&#39;);
  if (CKB.ARGV[0] != hex_input) {
    throw &amp;quot;Invalid creation argument!&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to run JavaScript, let&amp;rsquo;s first deploy duktape on CKB:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; data = File.read(&amp;quot;../ckb-duktape/build/duktape&amp;quot;)
pry(main)&amp;gt; duktape_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(300000), CKB::Utils.bin_to_hex(duktape_data))
pry(main)&amp;gt; duktape_data_hash = CKB::Blake2b.hexdigest(duktape_data)
pry(main)&amp;gt; duktape_out_point = CKB::Types::CellDep.new(out_point: CKB::Types::OutPoint.new(tx_hash: duktape_tx_hash, index: 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, let&amp;rsquo;s create a UDT with 1000000 tokens&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet.address, CKB::Utils.byte_to_shannon(20000))
pry(main)&amp;gt; tx.cell_deps.push(duktape_out_point.dup)
pry(main)&amp;gt; arg = CKB::Utils.bin_to_hex(CKB::Serializers::InputSerializer.new(tx.inputs[0]).serialize)
pry(main)&amp;gt; duktape_udt_script = CKB::Types::Script.new(code_hash: duktape_data_hash, args: [CKB::Utils.bin_to_hex(File.read(&amp;quot;udt.js&amp;quot;)), arg])
pry(main)&amp;gt; tx.outputs[0].type = duktape_udt_script
pry(main)&amp;gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([1000000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; tx.witnesses[0].data.clear
pry(main)&amp;gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; root_udt_tx_hash = api.send_transaction(signed_tx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we tried to submit the same transaction again, double-spent error will prevent us from forging the same token:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; api.send_transaction(signed_tx)
CKB::RPCError: jsonrpc error: {:code=&amp;gt;-3, :message=&amp;gt;&amp;quot;UnresolvableTransaction(Dead(OutPoint(0x0b607e9599f23a8140d428bd24880e5079de1f0ee931618b2f84decf2600383601000000)))&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And no matter how we tried, we cannot create another cell which forges the same UDT token.&lt;/p&gt;

&lt;p&gt;Now we can try transfering UDTs to another account. First let&amp;rsquo;s try creating one with has more output UDTs than input UDTs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; udt_out_point = CKB::Types::OutPoint.new(tx_hash: root_udt_tx_hash, index: 0)
pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(20000))
pry(main)&amp;gt; tx.cell_deps.push(duktape_out_point.dup)
pry(main)&amp;gt; tx.witnesses[0].data.clear
pry(main)&amp;gt; tx.witnesses.push(CKB::Types::Witness.new(data: []))
pry(main)&amp;gt; tx.outputs[0].type = duktape_udt_script
pry(main)&amp;gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([1000000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; tx.inputs.push(CKB::Types::Input.new(previous_output: udt_out_point, since: &amp;quot;0&amp;quot;))
pry(main)&amp;gt; tx.outputs.push(tx.outputs[1].dup)
pry(main)&amp;gt; tx.outputs[2].capacity = CKB::Utils::byte_to_shannon(20000)
pry(main)&amp;gt; tx.outputs[2].type = duktape_udt_script
pry(main)&amp;gt; tx.outputs_data.push(CKB::Utils.bin_to_hex([1000000].pack(&amp;quot;L&amp;lt;&amp;quot;)))
pry(main)&amp;gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(signed_tx)
CKB::RPCError: jsonrpc error: {:code=&amp;gt;-3, :message=&amp;gt;&amp;quot;InvalidTx(ScriptFailure(ValidationFailure(-2)))&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we tried to send another user 1000000 UDTs while also keeping 1000000 UDTs for the sender itself, of course this should trigger an error since we are trying to forge more tokens. But with slight modification, we can show that a UDT transferring transaction works if you respect the sum verification rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pry(main)&amp;gt; tx.outputs_data[0] = CKB::Utils.bin_to_hex([900000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; tx.outputs_data[2] = CKB::Utils.bin_to_hex([100000].pack(&amp;quot;L&amp;lt;&amp;quot;))
pry(main)&amp;gt; signed_tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(signed_tx)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;flexible-rules&#34;&gt;Flexible Rules&lt;/h1&gt;

&lt;p&gt;The UDT script shown here serves just as an example, in reality, dapps might be more complicated and requires more functions. You are also free to include more features for your UDT scripts depending on your needs, some examples include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Here we strictly ensure that the sum of output UDTs equals the sum of input UDTs, but in some cases, it might be enough just to ensure the sum of output UDTs does not exceed the sum of input UDTs. In order words, when not needed, a user can choose to burn the UDTs for the capacities.&lt;/li&gt;
&lt;li&gt;The above UDT script doesn&amp;rsquo;t allow issuing more tokens after the initial creation process, but there might be another type of UDT that allows more issurance from the token issuer. This is also possible on CKB, the actual way to solve this task, is left as an exercise here :)&lt;/li&gt;
&lt;li&gt;Here we limit the script to only create one cell in the initial token creation process, it&amp;rsquo;s also possible to create multiple cells to spread the usage in the initial token creation process.&lt;/li&gt;
&lt;li&gt;While we only cover ERC20 here, ERC721 should also be totally possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Notice those are just some examples, the actual ways of using CKB script are limitless here. We are more than happy to see cases where CKB dapp developers amaze us with interesting usage of CKB scripts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to CKB Script Programming 2: Script Basics</title>
      <link>https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/</guid>
      <description>

&lt;p&gt;Last post introduced current CKB&amp;rsquo;s validation model. This post will get more fun, since we will show how to deploy script codes to CKB for real. I&amp;rsquo;m hoping after this post, you should be able to explore the CKB world and work on new script codes as you wish.&lt;/p&gt;

&lt;p&gt;Note even though I believe CKB&amp;rsquo;s programming model is quite stable now, development is still happening so there might be changes. I will try my best to make sure this post is updated but if anything confuses you, this post is describing CKB as of &lt;a href=&#34;https://github.com/nervosnetwork/ckb/commit/80b51a9851b5d535625c5d144e1accd38c32876b&#34;&gt;this commit&lt;/a&gt; now.&lt;/p&gt;

&lt;p&gt;A warning here: this will be a long post, since I want to fill in enough for the more interesting topic next week. So you don&amp;rsquo;t have to finish it at once if you don&amp;rsquo;t have enough time. I&amp;rsquo;ve tried to split it into individual sections, so you can try each one at a time.&lt;/p&gt;

&lt;h1 id=&#34;wording&#34;&gt;Wording&lt;/h1&gt;

&lt;p&gt;Before we continue, let&amp;rsquo;s distinguish between 2 terms: script, and script code.&lt;/p&gt;

&lt;p&gt;In this post and hopefully the whole series, we will distinguish between script, and script code. Script code actually refers to the program you write and compile to use on CKB. Script, on the other hand, actually refers to the script data structure used in CKB, which is a little more than just the script code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Script&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; args: Vec&amp;lt;Bytes&amp;gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; code_hash: &lt;span style=&#34;font-weight:bold&#34;&gt;H256&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; hash_type: &lt;span style=&#34;font-weight:bold&#34;&gt;ScriptHashType&lt;/span&gt;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can ignore &lt;code&gt;hash_type&lt;/code&gt; for now, a future post will explain what it is and it&amp;rsquo;s interesting usage. Later in this post, we will show that &lt;code&gt;code_hash&lt;/code&gt; actually just identifies a script code, so for now we can just think of it as script code. What script also includes, is the &lt;code&gt;args&lt;/code&gt; part, which distinguishes script from script code. &lt;code&gt;args&lt;/code&gt; can be used here to provide additional arguments for a CKB script, for example, while people might all be using the same default lock script code, each of them might have their own pubkey hash, &lt;code&gt;args&lt;/code&gt; is exact the place to hold pubkey hash. This way each user of CKB can have different lock script, while sharing the same lock script code.&lt;/p&gt;

&lt;p&gt;Note that in most cases, script and script code can be used interchangably, but if you are confused at some places, it might be worthwhile to think of the difference between the 2.&lt;/p&gt;

&lt;h1 id=&#34;a-minimal-ckb-script-code&#34;&gt;A Minimal CKB Script Code&lt;/h1&gt;

&lt;p&gt;As you might have already heard, CKB is based on the open source RISC-V ISA. But what does that even mean? In my words, it means we are (sort of) embedding a real mini computer in CKB, instead of a virtual machine. The benefit of a real computer, is that you can write any logic you want in any language you want. The first few examples we show here will be written in C for simplicity(well I mean simplicity in the toolchain, not the &lt;a href=&#34;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&#34;&gt;language&lt;/a&gt;), but later we will switch to JavaScript based script code, and hopefully show more languages in the series. On CKB there&amp;rsquo;s endless possibilities.&lt;/p&gt;

&lt;p&gt;As we mentioned about, CKB VM is more like a real mini computer. CKB script code also looks like a normal Unix style executable program we run on a computer:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;&#34;&gt;char&lt;/span&gt;* argv[])
{
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When compiled via a C compiler, this will become a script code that is runnable on CKB. In other words, CKB just take plain old Unix style executables(but in RISC-V architecture instead of the popular x86 architecture), and run it in a virtual machine environment. If the program returns with 0 as the return code, we consider the script succeeds, all non-zero return codes will be considered script faliures.&lt;/p&gt;

&lt;p&gt;In the example above, we are showing a script code that always succeeds, since the return code will always be zero. Please don&amp;rsquo;t use this as your lock script code, otherwise your token can be taken away by anyone.&lt;/p&gt;

&lt;p&gt;But the example above won&amp;rsquo;t be interesting, here we will start with an interesting idea: personally I dislike carrot. I do know that carrot is great from a nutritional point of view, but I still want to avoid it due to the taste. Now what if I want to set a rule, that none of my cells on CKB has data that begin with &lt;code&gt;carrot&lt;/code&gt;? Let&amp;rsquo;s write a script code to ensure this.&lt;/p&gt;

&lt;p&gt;In order to ensure none of the cells can have &lt;code&gt;carrot&lt;/code&gt; in cell data, we need a way to first read cell data in the script. CKB provides &lt;code&gt;syscalls&lt;/code&gt; to help with this.&lt;/p&gt;

&lt;p&gt;To ensure the security of CKB script, each script has to run in an isolated environment that is totally separated from the main computer you are running CKB. This way it won&amp;rsquo;t be able to access data it doesn&amp;rsquo;t need, such as your private keys or passwords. However, for a script to be useful, there must be certain data it want to access, such as the cell a script guards, or a transaction a script validates. CKB provides &lt;code&gt;syscalls&lt;/code&gt; to ensure this, syscalls are defined in RISC-V standard, they provide a way to access certain resources provided by the environment. In a normal situation, the environment here means the operating system, but in the case of CKB VM, the environment refers to the actual CKB process. With syscalls, a CKB script can access the whole transaction containing itself, including inputs, outputs, witnesses, and deps.&lt;/p&gt;

&lt;p&gt;The good news, is that we have encapsulated syscalls in an easy to use &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/ckb_syscalls.h&#34;&gt;header file&lt;/a&gt;, you are very welcome to poke around this file to see how syscalls are implemented. The bottomline is you can just grab this header file and use the wrapped functions to make syscalls as you want.&lt;/p&gt;

&lt;p&gt;Now with the syscalls at hand, we can start with our carrot-forbidden script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;&#34;&gt;&amp;#34;ckb_syscalls.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;&#34;&gt;char&lt;/span&gt;* argv[]) {
  &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; ret;
  size_t index = 0;
  &lt;span style=&#34;font-weight:bold&#34;&gt;volatile&lt;/span&gt; uint64_t len = 0; &lt;span style=&#34;font-style:italic&#34;&gt;/* (1) */&lt;/span&gt;
  &lt;span style=&#34;&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; buffer[6];

  &lt;span style=&#34;font-weight:bold&#34;&gt;while&lt;/span&gt; (1) {
    len = 6;
    memset(buffer, 0, 6);
    ret = ckb_load_cell_by_field(buffer, &amp;amp;len, 0, index, CKB_SOURCE_OUTPUT,
                                 CKB_CELL_FIELD_DATA); &lt;span style=&#34;font-style:italic&#34;&gt;/* (2) */&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret == CKB_INDEX_OUT_OF_BOUND) {               &lt;span style=&#34;font-style:italic&#34;&gt;/* (3) */&lt;/span&gt;
      &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
    }

    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (memcmp(buffer, &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;, 6) == 0) {
      &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }

    index++;
  }

  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Several points worth explaining here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Due to C quirks, the &lt;code&gt;len&lt;/code&gt; field needs to be marked as &lt;code&gt;volatile&lt;/code&gt;. We will use it both as an input and output parameter, and CKB VM only can set the output when it lives in memory. &lt;code&gt;volatile&lt;/code&gt; ensures a C compiler keeps it as a RISC-V memory based variable.&lt;/li&gt;
&lt;li&gt;When making a syscall, we need to provide the following: a buffer to hold the data provided by the syscall; a &lt;code&gt;len&lt;/code&gt; field denoting both the buffer length, and available data length returned by the syscall; an offset into the input data buffer, and several parameters denoting the exact field we are fetching in the transaction. For more details, please refer to our &lt;a href=&#34;https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0009-vm-syscalls/0009-vm-syscalls.md&#34;&gt;RFC&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For maximum flexibility, CKB uses the return value of the syscall to represent data fetching status: 0(or &lt;code&gt;CKB_SUCCESS&lt;/code&gt;) means success, 1(or &lt;code&gt;CKB_INDEX_OUT_OF_BOUND&lt;/code&gt;) means you have finished fetching all indices in a kind, 2(or &lt;code&gt;CKB_ITEM_MISSING&lt;/code&gt;) means an entity is not present, such as fetching a type script from a cell that doesn&amp;rsquo;t have one.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So to recap, this script would loop through all output cells in the transaction, load the first 6 bytes of each cell data and test if those bytes match &lt;code&gt;carrot&lt;/code&gt;. If we found a match, the script would return &lt;code&gt;-1&lt;/code&gt;, denoting an error status, if no match is found, the script exits with &lt;code&gt;0&lt;/code&gt;, meaning execution success.&lt;/p&gt;

&lt;p&gt;To perform the loop, the script would keep an &lt;code&gt;index&lt;/code&gt; variable, in each loop iteration, it would tries to make the syscall to fetch the cell denoted by current &lt;code&gt;index&lt;/code&gt; value, if the syscall returns &lt;code&gt;CKB_INDEX_OUT_OF_BOUND&lt;/code&gt;, it means the script has iterated through all the cells, hence it just exits the loop, otherwise, the loop would continue, the cell data is tested, then &lt;code&gt;index&lt;/code&gt; variable is incremented for the next iteration.&lt;/p&gt;

&lt;p&gt;This concludes your first useful CKB script code! In the next section, we will see how we can deploy it to CKB and run it.&lt;/p&gt;

&lt;h1 id=&#34;deploying-a-script-to-ckb&#34;&gt;Deploying a Script to CKB&lt;/h1&gt;

&lt;p&gt;First, we need to compile the carrot source code written above. Since GCC already has upstream RISC-V support, you can of course use the official GCC to build your script code. Or you can use the &lt;a href=&#34;https://hub.docker.com/r/nervos/ckb-riscv-gnu-toolchain&#34;&gt;docker image&lt;/a&gt; we have prepared to save the trouble of compiling GCC:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ls
carrot.c  ckb_consts.h  ckb_syscalls.h
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
root@dc2c0c209dcd:/# cd /code
root@dc2c0c209dcd:/code# riscv64-unknown-elf-gcc -Os carrot.c -o carrot
root@dc2c0c209dcd:/code# exit
exit
$ ls
carrot*  carrot.c  ckb_consts.h  ckb_syscalls.h&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that&amp;rsquo;s it, CKB can use the compiled executable from GCC directly as scripts on chain, there&amp;rsquo;s no way for further processing. We can now deploy it on chain. Note that I will use CKB&amp;rsquo;s Ruby SDK since I used to be a Ruby programmer, and Ruby feels the most natural one(but not necessarily the best one) to me. Please refer to the official &lt;a href=&#34;https://github.com/nervosnetwork/ckb-sdk-ruby/blob/develop/README.md&#34;&gt;README&lt;/a&gt; for how to set it up.&lt;/p&gt;

&lt;p&gt;To deploy the script to CKB, we can just create a new cell, with the script code as cell data part:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; data.bytesize
=&amp;gt; 6864
pry(main)&amp;gt; carrot_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(8000), CKB::Utils.bin_to_hex(data))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here I simply create a new cell with enough capacity by sending tokens to myself. Now we can create the type script containing the carrot script code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; carrot_data_hash = CKB::Blake2b.hexdigest(data)
pry(main)&amp;gt; carrot_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: carrot_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: [])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall the Script data structure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;Script&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; args: Vec&amp;lt;Bytes&amp;gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; code_hash: &lt;span style=&#34;font-weight:bold&#34;&gt;H256&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; hash_type: &lt;span style=&#34;font-weight:bold&#34;&gt;ScriptHashType&lt;/span&gt;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can see that instead of embedding the script code directly in the script data structure, we are only including the code hash, which is a Blake2b hash of the actual script binary code. Since carrot script doesn&amp;rsquo;t use an argument, we can use empty array for &lt;code&gt;args&lt;/code&gt; part.&lt;/p&gt;

&lt;p&gt;Note I&amp;rsquo;m still ignoring &lt;code&gt;hash_type&lt;/code&gt; here, we will leave to a future post to see a different way of specifying code hash. For now, let&amp;rsquo;s keep it simple here.&lt;/p&gt;

&lt;p&gt;To run the carrot script, we need to create a new transaction, and set carrot type script as the type script of one of the output cells:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(200))
pry(main)&amp;gt; tx.outputs[0].instance_variable_set(&lt;span style=&#34;font-style:italic&#34;&gt;:@type&lt;/span&gt;, carrot_type_script.dup)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There&amp;rsquo;s one more step needed: in order for CKB to locate the carrot script, we need to reference the cell containing carrot script in one of transaction deps:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; carrot_out_point = CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;cell&lt;/span&gt;: CKB::Types::CellOutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: carrot_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))
pry(main)&amp;gt; tx.deps.push(carrot_out_point.dup)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we are ready to sign and send the transaction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;[44] pry(main)&amp;gt; tx.witnesses[0].data.clear
[46] pry(main)&amp;gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
[19] pry(main)&amp;gt; api.send_transaction(tx)
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0xd7b0fea7c1527cde27cc4e7a2e055e494690a384db14cc35cd2e51ec6f078163&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since this transaction does not have any cell containing &lt;code&gt;carrot&lt;/code&gt; in the cell data, the type script validates successfully. Now let&amp;rsquo;s try a different transaction that does have a cell that begins with &lt;code&gt;carrot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx2 = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(200))
pry(main)&amp;gt; tx2.deps.push(carrot_out_point.dup)
pry(main)&amp;gt; tx2.outputs[0].instance_variable_set(&lt;span style=&#34;font-style:italic&#34;&gt;:@type&lt;/span&gt;, carrot_type_script.dup)
pry(main)&amp;gt; tx2.outputs[0].instance_variable_set(&lt;span style=&#34;font-style:italic&#34;&gt;:@data&lt;/span&gt;, CKB::Utils.bin_to_hex(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;carrot123&amp;#34;&lt;/span&gt;))
pry(main)&amp;gt; tx2.witnesses[0].data.clear
pry(main)&amp;gt; tx2 = tx2.sign(wallet.key, api.compute_transaction_hash(tx2))
pry(main)&amp;gt; api.send_transaction(tx2)
CKB::&lt;span style=&#34;font-style:italic&#34;&gt;RPCError&lt;/span&gt;: jsonrpc &lt;span style=&#34;font-style:italic&#34;&gt;error&lt;/span&gt;: {&lt;span style=&#34;font-style:italic&#34;&gt;:code&lt;/span&gt;=&amp;gt;-3, &lt;span style=&#34;font-style:italic&#34;&gt;:message&lt;/span&gt;=&amp;gt;&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;InvalidTx(ScriptFailure(ValidationFailure(-1)))&amp;#34;&lt;/span&gt;}
from &lt;span style=&#34;font-style:italic&#34;&gt;/home/u&lt;/span&gt;buntu/code/ckb-sdk-ruby/lib/ckb/rpc.rb:164&lt;span style=&#34;font-style:italic&#34;&gt;:in&lt;/span&gt; &lt;span style=&#34;font-style:italic&#34;&gt;`rpc_request&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can see our carrot script rejects a transaction that generates a cell with carrot. Now I can use this script to make sure all my cells are free from carrots!&lt;/p&gt;

&lt;p&gt;So to recap, to deploy and run a script as type script, what we need to do is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compile the script to RISC-V executable binary&lt;/li&gt;
&lt;li&gt;Deploy the binary in a cell&amp;rsquo;s data part&lt;/li&gt;
&lt;li&gt;Create a type script data structure with the blake2b hash of the binary as &lt;code&gt;code hash&lt;/code&gt;, any required arguments of the script code in the &lt;code&gt;args&lt;/code&gt; part&lt;/li&gt;
&lt;li&gt;Create a new transaction with the type script set in one of the generated cells&lt;/li&gt;
&lt;li&gt;Include the outpoint to the cell containing the script code as one of the transaction deps&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;rsquo;s really all you need! If your script has run into problems, those are the points you need to check.&lt;/p&gt;

&lt;p&gt;Although we only talk about type scripts here, lock script works exactly the same way. The only quirk you need to keep in mind, is that when you create a cell with a specificed lock script, the lock script won&amp;rsquo;t run here. It only runs when you are consuming the cell. So while type script can be used to create the logic that runs when you create the cell, lock script is used to create the logic that runs when you consume the cell. Given this consideration, please make sure your lock script is correct, otherwise you might be losing the tokens in the following scenarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Your lock script has a bug that someone else can unlock your cell.&lt;/li&gt;
&lt;li&gt;Your lock script has a bug that no one(including you) can unlock your cell.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One tip we can provide here, is always test your script as a type script attached to an output cell in your transaction, this way when error happens, you will know immediately, your tokens can stay safe.&lt;/p&gt;

&lt;h1 id=&#34;dissecting-the-default-lock-script-code&#34;&gt;Dissecting the Default Lock Script Code&lt;/h1&gt;

&lt;p&gt;With the knowledge we have, let&amp;rsquo;s look at the default lock script code included in CKB. To avoid confusion, we are looking at the lock script code as of &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66e2b3fc4fa3e80235e4b4f94a16e81352a812f7/c/secp256k1_blake160_sighash_all.c&#34;&gt;this commit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The default lock script code would loop through all input cells that have the same lock script as itself, and perform the following steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It grabs the current transaction hash via a provided syscall.&lt;/li&gt;
&lt;li&gt;It grabs the corresponding witness data for current input.&lt;/li&gt;
&lt;li&gt;For the default lock script, it is assumed that the first argument in witness contains the recoverable signature signed by cell owner, and the rest arguments are optional user provided arguments.&lt;/li&gt;
&lt;li&gt;Default lock script code runs a blake2b hash on the concatenated binary data of the transaction hash, and all the user provided arguments(if exists).&lt;/li&gt;
&lt;li&gt;The blake2b hash result is then used as the message part for the secp256k1 signature verification. Note the actual signature is provided in the first argument in witness data structure.&lt;/li&gt;
&lt;li&gt;If the signature verification fails, the script exits with a failure return code. Otherwise it continues with the next iteration.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note we talked about the difference between script and script code earlier. Each different pubkey hash would result in different lock script, hence if a transaction has input cells with the same default lock script code but different pubkey hash(hence different lock script), multiple instances of the default lock script code will be executed, each with its own set of cells sharing the same lock script.&lt;/p&gt;

&lt;p&gt;Now we can walk through different segments of the default lock script code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (argc != 2) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_WRONG_NUMBER_OF_ARGUMENTS;
}

secp256k1_context context;
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (secp256k1_context_initialize(&amp;amp;context, SECP256K1_CONTEXT_VERIFY) == 0) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SECP_INITIALIZE;
}

len = BLAKE2B_BLOCK_SIZE;
ret = ckb_load_tx_hash(tx_hash, &amp;amp;len, 0);
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SYSCALL;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When arguments are included in &lt;code&gt;args&lt;/code&gt; part of &lt;code&gt;Script&lt;/code&gt; data structure, they are presented to the actual running script program via the Unix conventional &lt;code&gt;arc&lt;/code&gt;/&lt;code&gt;argv&lt;/code&gt; way. To further preserve conventions, we insert a dummy argument at &lt;code&gt;argv[0]&lt;/code&gt;, so your first include argument starts at &lt;code&gt;argv[1]&lt;/code&gt;. In the case of default lock script code, it accepts one argument, which is the pubkey hash generated from the owner&amp;rsquo;s private key.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;ret = ckb_load_input_by_field(NULL, &amp;amp;len, 0, index, CKB_SOURCE_GROUP_INPUT,
                             CKB_INPUT_FIELD_SINCE);
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret == CKB_INDEX_OUT_OF_BOUND) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
}
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SYSCALL;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the same technique as shown in the carrot example, we check if there&amp;rsquo;s more input cells to test. There&amp;rsquo;re 2 differences from previous examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If we just want to know if a cell exists and don&amp;rsquo;t need any of the data, we can just pass in &lt;code&gt;NULL&lt;/code&gt; as the data buffer, and a &lt;code&gt;len&lt;/code&gt; variable with value 0. This way the syscall would skip data filling and just provided available data length and correct return code for processing.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the carrot example, we are looping through all inputs in the transaction, but here we just care about input cells of the same lock script. CKB named cells with the same lock(or type) script as cells with the same &lt;code&gt;group&lt;/code&gt;. And here, we can use &lt;code&gt;CKB_SOURCE_GROUP_INPUT&lt;/code&gt; instead of &lt;code&gt;CKB_SOURCE_INPUT&lt;/code&gt; denoting the syscalls to only count cells in the same group, i.e., cells who have the same lock script as the current cell.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;len = WITNESS_SIZE;
ret = ckb_load_witness(witness, &amp;amp;len, 0, index, CKB_SOURCE_GROUP_INPUT);
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
&lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SYSCALL;
}
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (len &amp;gt; WITNESS_SIZE) {
&lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_WITNESS_TOO_LONG;
}

&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!(witness_table = ns(Witness_as_root(witness)))) {
&lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_ENCODING;
}
args = ns(Witness_data(witness_table));
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ns(Bytes_vec_len(args)) &amp;lt; 1) {
&lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_WRONG_NUMBER_OF_ARGUMENTS;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Continue down the path, we are loading the witness for current input. Corresponding witnesses and inputs have the same index. Right now CKB uses flatbuffer as the serialization format in syscalls, so if this feels weird to you, &lt;a href=&#34;https://github.com/dvidelabs/flatcc&#34;&gt;flatcc&amp;rsquo;s documentation&lt;/a&gt; is your best friend.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;/* Load signature */&lt;/span&gt;
len = TEMP_SIZE;
ret = extract_bytes(ns(Bytes_vec_at(args, 0)), temp, &amp;amp;len);
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_ENCODING;
}

&lt;span style=&#34;font-style:italic&#34;&gt;/* The 65th byte is recid according to contract spec.*/&lt;/span&gt;
recid = temp[RECID_INDEX];
&lt;span style=&#34;font-style:italic&#34;&gt;/* Recover pubkey */&lt;/span&gt;
secp256k1_ecdsa_recoverable_signature signature;
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (secp256k1_ecdsa_recoverable_signature_parse_compact(&amp;amp;context, &amp;amp;signature, temp, recid) == 0) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SECP_PARSE_SIGNATURE;
}
blake2b_state blake2b_ctx;
blake2b_init(&amp;amp;blake2b_ctx, BLAKE2B_BLOCK_SIZE);
blake2b_update(&amp;amp;blake2b_ctx, tx_hash, BLAKE2B_BLOCK_SIZE);
&lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (size_t i = 1; i &amp;lt; ns(Bytes_vec_len(args)); i++) {
  len = TEMP_SIZE;
  ret = extract_bytes(ns(Bytes_vec_at(args, i)), temp, &amp;amp;len);
  &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (ret != CKB_SUCCESS) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_ENCODING;
  }
  blake2b_update(&amp;amp;blake2b_ctx, temp, len);
}
blake2b_final(&amp;amp;blake2b_ctx, temp, BLAKE2B_BLOCK_SIZE);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first argument in witness is the signature to load, while the rest arguments, if presented, are appened to transaction hash for a blake2b operation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;secp256k1_pubkey pubkey;

&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (secp256k1_ecdsa_recover(&amp;amp;context, &amp;amp;pubkey, &amp;amp;signature, temp) != 1) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SECP_RECOVER_PUBKEY;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the hashed blake2b result as message, we then do secp256 signature verification.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;size_t pubkey_size = PUBKEY_SIZE;
&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (secp256k1_ec_pubkey_serialize(&amp;amp;context, temp, &amp;amp;pubkey_size, &amp;amp;pubkey, SECP256K1_EC_COMPRESSED) != 1 ) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_SECP_SERIALIZE_PUBKEY;
}

len = PUBKEY_SIZE;
blake2b_init(&amp;amp;blake2b_ctx, BLAKE2B_BLOCK_SIZE);
blake2b_update(&amp;amp;blake2b_ctx, temp, len);
blake2b_final(&amp;amp;blake2b_ctx, temp, BLAKE2B_BLOCK_SIZE);

&lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (memcmp(argv[1], temp, BLAKE160_SIZE) != 0) {
  &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; ERROR_PUBKEY_BLAKE160_HASH;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Last but not least, we also need to check the pubkey contained from the recoverable signature is indeed the pubkey used to generated the pubkey hash included in the lock script arguments. Otherwise, someone might use a signature generated from a different pubkey to steal your token.&lt;/p&gt;

&lt;p&gt;In short, the scheme used in the default lock script resembles a lot like the solution used in &lt;a href=&#34;https://bitcoin.org/en/transactions-guide#p2pkh-script-validation&#34;&gt;bitcoin now&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;introducing-duktape&#34;&gt;Introducing Duktape&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m sure you feel the same way as I do now: it&amp;rsquo;s good we can write contracts in C, but C always feels a bit tedious and, let&amp;rsquo;s face it, dangerous. Is there a better way?&lt;/p&gt;

&lt;p&gt;Yes of course! We mentioned above CKB VM is essentially a mini computer, and there are tons of solutions we can explore. One thing we have prepared here, is that we can write CKB script codes in JavaScript. Yes you got it right, plain ES5(yes I know, but this is just one example, and you can use a transpiler) JavaScript.&lt;/p&gt;

&lt;p&gt;How this is possible? Since we have C compiler available, all we did is just take a JavaScript implementation for the embeded system, in our case, &lt;a href=&#34;https://duktape.org/&#34;&gt;duktape&lt;/a&gt;, compile it from C to RISC-V binary, put it on chain, then boom, we can run JavaScript in CKB! Since we are working with a real mini computer here, there&amp;rsquo;s no stopping us from embeding another VM as CKB script to CKB VM, and exploring this VM on top of VM path.&lt;/p&gt;

&lt;p&gt;And we can actually expand from this path, we can have JavaScript on CKB via duktape, we can also have Ruby on CKB via &lt;a href=&#34;https://github.com/mruby/mruby&#34;&gt;mruby&lt;/a&gt;, we can even have Bitcoin Script or EVM on chain if we just compile their VM and put it on chain. This ensures CKB VM can both help us preserve legacy and build a diversified ecosystem. All languages should be and are treated equal on CKB, the freedom should be in the hands of blockchain contract developers.&lt;/p&gt;

&lt;p&gt;At this stage you might want to ask: yes this is possible, but won&amp;rsquo;t VM on top of VM be slow? I believe it really depends on your use case to say if this is gonna be slow. I&amp;rsquo;m a firm believer that benchmarks make no sense unless we put it in a real use case with standard hardware requirements. So wait to see if this is really gonna be an issue. In my opinion, higher languages are more likely to be used in type scripts to guard cell transformation, in this case, I doubt it&amp;rsquo;s gonna be slow. Besides, we are also working on this field to optimize both CKB VM and the VMs on top of CKB VM to make it faster and faster :P&lt;/p&gt;

&lt;p&gt;To use duktape on CKB, first you need to compile duktape itself into a RISC-V executable binary:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git clone https://github.com/nervosnetwork/ckb-duktape
$ cd ckb-duktape
$ sudo docker run --rm -it -v &lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;pwd&lt;span style=&#34;font-style:italic&#34;&gt;`&lt;/span&gt;:/code nervos/ckb-riscv-gnu-toolchain:xenial bash
root@0d31cad7a539:~# cd /code
root@0d31cad7a539:/code# make
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror c/entry.c -c -o build/entry.o
riscv64-unknown-elf-gcc -Os -DCKB_NO_MMU -D__riscv_soft_float -D__riscv_float_abi_soft -Iduktape -Ic -Wall -Werror duktape/duktape.c -c -o build/duktape.o
riscv64-unknown-elf-gcc build/entry.o build/duktape.o -o build/duktape -lm -Wl,-static -fdata-sections -ffunction-sections -Wl,--gc-sections -Wl,-s
root@0d31cad7a539:/code# exit
exit
$ ls build/duktape
build/duktape*&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the carrot example, the first step here is to deploy duktape script code in a CKB cell:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; data = File.read(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;../ckb-duktape/build/duktape&amp;#34;&lt;/span&gt;)
pry(main)&amp;gt; duktape_data.bytesize
=&amp;gt; 269064
pry(main)&amp;gt; duktape_tx_hash = wallet.send_capacity(wallet.address, CKB::Utils.byte_to_shannon(280000), CKB::Utils.bin_to_hex(duktape_data))
pry(main)&amp;gt; duktape_data_hash = CKB::Blake2b.hexdigest(duktape_data)
pry(main)&amp;gt; duktape_out_point = CKB::Types::OutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;cell&lt;/span&gt;: CKB::Types::CellOutPoint.new(&lt;span style=&#34;font-style:italic&#34;&gt;tx_hash&lt;/span&gt;: duktape_tx_hash, &lt;span style=&#34;font-style:italic&#34;&gt;index&lt;/span&gt;: 0))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike the carrot example, duktape script code now requires one argument: the JavaScript source you want to execute:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; duktape_hello_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: duktape_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: [CKB::Utils.bin_to_hex(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;CKB.debug(&lt;/span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;I&amp;#39;m running in JS!&lt;/span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;)&amp;#34;&lt;/span&gt;)])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that with a different argument, you can create a different duktape powered type script for different use case:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; duktape_hello_type_script = CKB::Types::Script.new(&lt;span style=&#34;font-style:italic&#34;&gt;code_hash&lt;/span&gt;: duktape_data_hash, &lt;span style=&#34;font-style:italic&#34;&gt;args&lt;/span&gt;: [CKB::Utils.bin_to_hex(&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;var a = 1;&lt;/span&gt;&lt;span style=&#34;font-weight:bold;font-style:italic&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;var b = a + 2;&amp;#34;&lt;/span&gt;)])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This echos the differences mentioned above on script code vs script: here duktape serves as a script code providing a JavaScript engine, while different script leveraging duktape script code serves different functionalities on chain.&lt;/p&gt;

&lt;p&gt;Now we can create a cell with the duktape type script attached:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;pry(main)&amp;gt; tx = wallet.generate_tx(wallet2.address, CKB::Utils.byte_to_shannon(200))
pry(main)&amp;gt; tx.deps.push(duktape_out_point.dup)
pry(main)&amp;gt; tx.outputs[0].instance_variable_set(&lt;span style=&#34;font-style:italic&#34;&gt;:@type&lt;/span&gt;, duktape_hello_type_script.dup)
pry(main)&amp;gt; tx.witnesses[0].data.clear
pry(main)&amp;gt; tx = tx.sign(wallet.key, api.compute_transaction_hash(tx))
pry(main)&amp;gt; api.send_transaction(tx)
=&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;0x2e4d3aab4284bc52fc6f07df66e7c8fc0e236916b8a8b8417abb2a2c60824028&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can see that the script executes successfully, and if you have &lt;code&gt;ckb-script&lt;/code&gt; module&amp;rsquo;s log level set to &lt;code&gt;debug&lt;/code&gt; in your &lt;code&gt;ckb.toml&lt;/code&gt; file, you can also notice the following log:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;2019-07-15 05:59:13.551 +00:00 http.worker8 DEBUG ckb-script  script group: c35b9fed5fc0dd6eaef5a918cd7a4e4b77ea93398bece4d4572b67a474874641 DEBUG OUTPUT: I&lt;span style=&#34;&#34;&gt;&amp;#39;&lt;/span&gt;m running in JS!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you have successfully deploy a JavaScript engine on CKB, and run JavaScript based script on CKB! Feel free to try any JavaScript code you want here.&lt;/p&gt;

&lt;h1 id=&#34;a-thought-exercise&#34;&gt;A Thought Exercise&lt;/h1&gt;

&lt;p&gt;Now you are familiar with CKB script basics, here&amp;rsquo;s one thought exercise: in this post you&amp;rsquo;ve seen what an always-success script looks like, but what about an always-failure script? How small an always-faliure script(and script code) can be?&lt;/p&gt;

&lt;p&gt;A hint: this is NOT a gcc flag-tweaking optimization contest, this is merely a thought exercise.&lt;/p&gt;

&lt;h1 id=&#34;next&#34;&gt;Next&lt;/h1&gt;

&lt;p&gt;I know this is a long post, I hope you have tried this and successfully deployed a script to CKB. In the next post, we will introduce an important topic: how to issue your own user defined tokens(UDT) on CKB. The best part of UDTs on CKB, is that each user can store their UDTs in their own cells, which is different from ERC20 tokens on Ethereum, where everyone&amp;rsquo;s token will have to live in the token issuer&amp;rsquo;s single address. All of this can be achieved by using type scripts alone. If you are interested please stay tuned :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to CKB Script Programming 1: Validation Model</title>
      <link>https://xuejie.space/2019_07_05_introduction_to_ckb_script_programming_validation_model/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuejie.space/2019_07_05_introduction_to_ckb_script_programming_validation_model/</guid>
      <description>

&lt;p&gt;As of now, the cell validation model in CKB has been more or less stablized, hence I&amp;rsquo;m starting a series of article introducing CKB script programming here. My goal here is to fill in all the missing implementation details one need to write CKB scripts after reading the whitepaper, so you can start exploring this beautiful wonderland CKB presents.&lt;/p&gt;

&lt;p&gt;You might noticed that I call the code running on CKB as &lt;code&gt;script&lt;/code&gt;, not &lt;code&gt;smart contract&lt;/code&gt;. This is because smart contract is quite a confusing term to me, and I want to use a different word here to indicate CKB&amp;rsquo;s unique programmability. A script in CKB&amp;rsquo;s sense need not be just a script we see in scripting languages such as Ruby, JS, it actually refers to the RISC-V format binary you run on CKB VM.&lt;/p&gt;

&lt;p&gt;This first post here, is dedicated to the brand &lt;a href=&#34;https://github.com/nervosnetwork/ckb/pull/913&#34;&gt;new verification model&lt;/a&gt; introduced in CKB v0.14.0. It might sound boring but I promise you this is the last post without actual examples to play with :P&lt;/p&gt;

&lt;p&gt;Note even though I believe CKB&amp;rsquo;s programming model is quite stable now, development is still happening so there might be changes. I will try my best to make sure this post is updated but if anything confuses you, this post is describing CKB as of &lt;a href=&#34;https://github.com/nervosnetwork/ckb/commit/a02c675c50c5969a588fa7f6356f08861d8f5f92&#34;&gt;this commit&lt;/a&gt; now.&lt;/p&gt;

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;Below illustrates a real transaction on CKB:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/tx.svg&#34; alt=&#34;Transaction Example&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There are a lot of things going on in this graph, and we will come back to this graph again in later posts. Today, we will just focus on 2 entities in the cell data structure: &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;CellOutput&lt;/span&gt; {
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; capacity: &lt;span style=&#34;font-weight:bold&#34;&gt;Capacity&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; data: &lt;span style=&#34;font-weight:bold&#34;&gt;Bytes&lt;/span&gt;,
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; lock: &lt;span style=&#34;font-weight:bold&#34;&gt;Script&lt;/span&gt;,
    &lt;span style=&#34;&#34;&gt;#[serde(rename = &lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;)]&lt;/span&gt;
    &lt;span style=&#34;font-weight:bold&#34;&gt;pub&lt;/span&gt; type_: Option&amp;lt;Script&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From the data structure we can see that &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; shared the same structure, later we can show that they are also executed in the same environment, the differences between them are just in a few tiny bits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lock&lt;/code&gt; is required, while &lt;code&gt;type&lt;/code&gt; is optional&lt;/li&gt;
&lt;li&gt;Mentally, they are used to capture different use cases.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will first start with &lt;code&gt;type&lt;/code&gt; script here.&lt;/p&gt;

&lt;h1 id=&#34;type-script&#34;&gt;Type Script&lt;/h1&gt;

&lt;p&gt;Note the name here is just a lucky accident, it is not related to the beloved &lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;programming language&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you think about it, a transaction on CKB(or most UTXO-based blockchains) just transforms one set of cells(or UTXOs) to another set of cells. What&amp;rsquo;s interesting, is the actual transformation here. That&amp;rsquo;s where we start to design CKB&amp;rsquo;s verification model: how can we build a model to better validate the cell transformations?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s where a &lt;code&gt;type&lt;/code&gt; script comes in play: a type script is used to validate certain rules in the cell transformation phase. Some examples here include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Validating UDT(user defined token) balances to ensure no new token is invalidly issued.&lt;/li&gt;
&lt;li&gt;Ensuring a unique name is assigned to a cell that might be mutated. Note this is a fun one, please expect a future article dedicated entirely to this topic.&lt;/li&gt;
&lt;li&gt;Implementing economic constructs. In fact NervosDAO is completely implemented as a &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/dao.c&#34;&gt;type script&lt;/a&gt; with minimal support from the consensus layer.&lt;/li&gt;
&lt;li&gt;A bitcoin VM can be compiled to RISC-V binary, which can transform CKB into an alternative bitcoin implementation :)&lt;/li&gt;
&lt;li&gt;Keep in mind that in addition to data, cell can be used to store code as well, hence a type script can also be used to run tests on the code in cell to ensure certain behavior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In a nutshell, type script can be used to capture any validation logic you need in the cell transformation. Combined with CKB&amp;rsquo;s flexible virtual machine, I believe this will provide endless potentials.&lt;/p&gt;

&lt;h1 id=&#34;lock-script&#34;&gt;Lock Script&lt;/h1&gt;

&lt;p&gt;Type script captures the cell transformation logic, but there&amp;rsquo;s still one thing missing from the picture: how can I guard my own cell from someone else? In other words, how can I ensure my tokens stay mine in an ever-changing world?&lt;/p&gt;

&lt;p&gt;This is why we designed the always required lock script. A cell can only be consumed when the lock script can be executed sucessfully. This is different from type script, which might be totally optional. A lock script is always there to guard the security of a cell.&lt;/p&gt;

&lt;p&gt;Typically, you would expect that a lock script contains a signature verification phase, like all the other blockchains do, but there are also brand new use cases unlocked by CKB:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The actual signature algorithm is totally determined by the lock script, and you are free to use any lock script. That means you are free to incorporate any signature algorithms that suit your need. In the official CKB distribution we are including &lt;a href=&#34;https://github.com/nervosnetwork/ckb-system-scripts/blob/66d7da8ec72dffaa7e9c55904833951eca2422a9/c/secp256k1_blake160_sighash_all.c&#34;&gt;secp256k1 algorithm&lt;/a&gt; as the default lock script. But you don&amp;rsquo;t have to use this, if someone implements a lock script using schnorr signature, you are more than welcome to use that one.&lt;/li&gt;
&lt;li&gt;In addition to signature verification, a lock script can also include other rules to unlock the cell as well. For example, I can configure my lock script to pass if the transaction contains an output cell that uses my lock script, but has more capacity than my consumed cell. This way when someone sends me capacity, they can consume my existing cell and create a new cell for me. They don&amp;rsquo;t have to create a new cell for me like bitcoin requires.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In my personal opinion, the best part of CKB, is that a lock script created by the community is treated exactly the same way as the official default one. No priviledge is granted to the official scripts. Unlike some other blockchains, CKB provides the freedom to develop CKB scripts back to the whole community.&lt;/p&gt;

&lt;h1 id=&#34;execution-model&#34;&gt;Execution Model&lt;/h1&gt;

&lt;p&gt;Now let&amp;rsquo;s see when lock and type scripts are executed.&lt;/p&gt;

&lt;h2 id=&#34;back-to-the-example&#34;&gt;Back to the Example&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s the transaction we see earlier again:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://xuejie.space/images/tx.svg&#34; alt=&#34;Transaction Example&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For this example, the execution flow is as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Lock Script 1&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lock Script 2&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type Script 1&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type Script 2&lt;/code&gt; is executed once.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In later posts we can see both lock and type scripts are executed in the same environment, and both have access to the whole transaction. If any of the script fails, the whole transaction fails. Only when all the scripts succeed, the transaction is considered validated.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;re couple of points worth mentioning:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Even though there are 2 input cells with &lt;code&gt;Lock Script 1&lt;/code&gt;, it is only executed once, it&amp;rsquo;s up to the actual lock script to locate all the input cells with the same lock script and validate both signature.&lt;/li&gt;
&lt;li&gt;Only lock scripts in input cells are executed in this transaction, for example, &lt;code&gt;Lock Script 3&lt;/code&gt; is not executed here.&lt;/li&gt;
&lt;li&gt;Even though an input cell and an output cell both contain &lt;code&gt;Type Script 1&lt;/code&gt;, it is only executed once.&lt;/li&gt;
&lt;li&gt;Type scripts in both input and output cells are executed, which include &lt;code&gt;Type Script 1&lt;/code&gt; and &lt;code&gt;Type Script 2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Some cells do not have type scripts, in this case we just omit the execution.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rules&#34;&gt;Rules&lt;/h2&gt;

&lt;p&gt;Now to summary the rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lock scripts in input cells are collected and deduped, each unique lock script is executed and only executed once.&lt;/li&gt;
&lt;li&gt;Type scripts in input and output cells(if existed) are collected together and deduped, each unique type script is executed and only executed once.&lt;/li&gt;
&lt;li&gt;If any script fails, the whole transaction validation fails.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s Next&lt;/h1&gt;

&lt;p&gt;Now that cell model is covered, we will look at how to actual write a CKB VM script in the next post. The default secp256k1 lock script will be examined to show the life of a CKB VM script.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://xuejie.space/about/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xuejie.space/about/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m Xuejie Xiao, this is my new site for writing.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m currently a blockchain engineer at &lt;a href=&#34;https://www.cryptape.com/&#34;&gt;Cryptape&lt;/a&gt; working on &lt;a href=&#34;https://www.nervos.org/&#34;&gt;Nervos CKB&lt;/a&gt;. I&amp;rsquo;m the main developer on &lt;a href=&#34;https://github.com/nervosnetwork/ckb-vm&#34;&gt;CKB VM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even though I&amp;rsquo;ve heard about Bitcoin for quite some time, I didn&amp;rsquo;t really have enough time to fully dive into the blockchain world till 2017. I&amp;rsquo;ve worked on wallets and mining pool, then found out my true interest lies in blockchain VM. I&amp;rsquo;ve been doing research on virtual machine technologies for blockchain for quite some time, and CKB VM is my latest contribution.&lt;/p&gt;

&lt;p&gt;I also believe the power of simplicity. The only way to make reliable software for the future, should be designing software that are so simple that any bug is obvious. This world is already full of leaky abstraction, let&amp;rsquo;s try hard not to add another one.&lt;/p&gt;

&lt;p&gt;Before that, I worked for &lt;a href=&#34;https://citrusbyte.com/&#34;&gt;Citrusbyte&lt;/a&gt; where we did software consulting services for large enterprise organizations and startups, such as Apple, AT&amp;amp;T, Cast &amp;amp; Crew, etc. I was also once a PhD candidate at &lt;a href=&#34;https://www.syracuse.edu/&#34;&gt;Syracuse University&lt;/a&gt; focusing on high performance computing and cloud computing. Some of my work back then could be found at &lt;a href=&#34;https://ieeexplore.ieee.org/document/7004222/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I also spent years working with latest web technologies, such as &lt;a href=&#34;https://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt; and &lt;a href=&#34;https://github.com/emscripten-core/emscripten&#34;&gt;emscripten&lt;/a&gt;. I created &lt;a href=&#34;https://github.com/xxuejie/webruby&#34;&gt;webruby&lt;/a&gt;, an introduction on webruby could be found at &lt;a href=&#34;http://rubykaigi.org/2013/talk/S07/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
