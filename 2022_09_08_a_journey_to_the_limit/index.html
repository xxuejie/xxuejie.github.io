<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    

    
      <link href='https://fonts.googleapis.com/css?family=Open+Sans:400|Old+Standard+TT:400&display=swap' rel='stylesheet' type='text/css'>
    

    <link rel="icon" type="image/png" href="https://xuejie.space/favicon_16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="https://xuejie.space/favicon_32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://xuejie.space/favicon_128x128.png" sizes="128x128">

    <title>
      
      
         A Journey to the Absolute Limit: CKB-VM&#39;s LLVM AOT engine 
      
    </title>
    <link rel="canonical" href="https://xuejie.space/2022_09_08_a_journey_to_the_limit/">

    <style>
  * {
    border:0;
    font:inherit;
    font-size:100%;
    vertical-align:baseline;
    margin:0;
    padding:0;
    color: black;
    text-decoration-skip: ink;
  }

  body {
    font-family:'Open Sans', 'Myriad Pro', Myriad, sans-serif;
    font-size:17px;
    line-height:160%;
    color:#1d1313;
    max-width:700px;
    margin:auto;
  }

  p {
    margin: 20px 0;
  }

  a img {
    border:none;
  }

  img {
    margin: 10px auto 10px auto;
    max-width: 100%;
    display: block;
  }

  .left-justify {
    float: left;
  }

  .right-justify {
    float:right;
  }

  pre, code {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    background-color: #f7f7f7;
  }

  code {
    font-size: 12px;
    padding: 4px;
  }

  pre {
    margin-top: 0;
    margin-bottom: 16px;
    word-wrap: normal;
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
  }

  pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
  }

  pre code {
    display: inline;
    max-width: auto;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
  }

  pre code::before,
  pre code::after {
    content: normal;
  }

  em,q,em,dfn {
    font-style:italic;
  }

  .sans,html .gist .gist-file .gist-meta {
    font-family:"Open Sans","Myriad Pro",Myriad,sans-serif;
  }

  .mono,pre,code,tt,p code,li code {
    font-family:Menlo,Monaco,"Andale Mono","lucida console","Courier New",monospace;
  }

  .heading,.serif,h1,h2,h3 {
    font-family:"Old Standard TT",serif;
  }

  strong {
    font-weight:600;
  }

  q:before {
    content:"\201C";
  }

  q:after {
    content:"\201D";
  }

  del,s {
    text-decoration:line-through;
  }

  blockquote {
    font-family:"Old Standard TT",serif;
    text-align:center;
    padding:50px;
  }

  blockquote p {
    display:inline-block;
    font-style:italic;
  }

  blockquote:before,blockquote:after {
    font-family:"Old Standard TT",serif;
    content:'\201C';
    font-size:35px;
    color:#403c3b;
  }

  blockquote:after {
    content:'\201D';
  }

  hr {
    width:40%;
    height: 1px;
    background:#403c3b;
    margin: 25px auto;
  }

  h1 {
    font-size:35px;
  }

  h2 {
    font-size:28px;
  }

  h3 {
    font-size:22px;
    margin-top:18px;
  }

  h1 a,h2 a,h3 a {
    text-decoration:none;
  }

  h1,h2 {
    margin-top:28px;
  }

  #sub-header, time {
    color:#403c3b;
    font-size:13px;
  }

  #sub-header {
    margin: 0 4px;
  }

  #nav h1 a {
    font-size:35px;
    color:#1d1313;
    line-height:120%;
  }

  .posts_listing a,#nav a {
    text-decoration: none;
  }

  li {
    margin-left: 20px;
  }

  ul li {
    margin-left: 5px;
  }

  ul li {
    list-style-type: none;
  }
  ul li:before {
    content:"\00BB \0020";
  }

  #nav ul li:before, .posts_listing li:before {
    content:'';
    margin-right:0;
  }

  #content {
    text-align:left;
    width:100%;
    font-size:15px;
    padding:60px 0 80px;
  }

  #content h1,#content h2 {
    margin-bottom:5px;
  }

  #content h2 {
    font-size:25px;
  }

  #content .entry-content {
    margin-top:15px;
  }

  #content time {
    margin-left:3px;
  }

  #content h1 {
    font-size:30px;
  }

  .highlight {
    margin: 10px 0;
  }

  .posts_listing {
    margin:0 0 50px;
  }

  .posts_listing li {
    margin:0 0 25px 15px;
  }

  .posts_listing li a:hover,#nav a:hover {
    text-decoration: underline;
  }

  #nav {
    text-align:center;
    position:static;
    margin-top:60px;
  }

  #nav ul {
    display: table;
    margin: 8px auto 0 auto;
  }

  #nav li {
    list-style-type:none;
    display:table-cell;
    font-size:15px;
    padding: 0 20px;
  }

  #links {
    margin: 50px 0 0 0;
  }

  #links :nth-child(2) {
    float:right;
  }

  #not-found {
    text-align: center;
  }

  #not-found a {
    font-family:"Old Standard TT",serif;
    font-size: 200px;
    text-decoration: none;
    display: inline-block;
    padding-top: 225px;
  }

  @media (max-width: 750px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:28px;
    }

    #nav li {
      font-size:13px;
      padding: 0 15px;
    }

    #content {
      margin-top:0;
      padding-top:50px;
      font-size:14px;
    }

    #content h1 {
      font-size:25px;
    }

    #content h2 {
      font-size:22px;
    }

    .posts_listing li div {
      font-size:12px;
    }
  }

  @media (max-width: 400px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:22px;
    }

    #nav li {
      font-size:12px;
      padding: 0 10px;
    }

    #content {
      margin-top:0;
      padding-top:20px;
      font-size:12px;
    }

    #content h1 {
      font-size:20px;
    }

    #content h2 {
      font-size:18px;
    }

    .posts_listing li div{
      font-size:12px;
    }
  }
</style>


    
  </head>

  <body>
    <section id=nav>
      <h1><a href="https://xuejie.space/">Less is More</a></h1>
      <ul>
        
          <li><a href="https://xuejie.space/about">About</a></li>
        
          <li><a href="https://github.com/xxuejie">GitHub</a></li>
        
          <li><a href="https://xuejie.space/index.xml">RSS</a></li>
        
          <li><a href="https://twitter.com/xxuejie">Twitter</a></li>
        
      </ul>
    </section>


<section id=content>
  <h1> A Journey to the Absolute Limit: CKB-VM&#39;s LLVM AOT engine </h1>

  
    <div id=sub-header>
      September 2022 · 26 minute read
    </div>
  

  <div class="entry-content">
    <p>It&rsquo;s long been a fascinating journey optimizing <a href="https://github.com/nervosnetwork/ckb-vm">CKB-VM</a>. For example, here&rsquo;s the runtime gathered when running <a href="https://github.com/xxuejie/ckb-vm-bench-scripts/blob/1a3d3c7141ba96674d655269bb61e76100508a4d/c/secp256k1_bench.c">secp256k1</a> verification on CKB-VM:</p>
<pre><code>|                               | µs    | Ratio  |
|-------------------------------|-------|--------|
| CKB-VM (Rust interpreter)     | 12034 | 316.68 |
| CKB-VM (Assembly interpreter) |  2417 | 63.61  |
| CKB-VM (Old AOT)              |  1741 | 45.82  |
| Wasmtime 0.40.1               |   228 | 6.0    |
| WAVM nightly/2022-05-14       |   185 | 4.87   |
| Native                        |    38 | 1.0    |
</code></pre><p>For wasm tests, we compile the same secp256k1 test program above using <a href="https://github.com/WebAssembly/wasi-sdk">WASI_SDK</a> 16.</p>
<p>CKB now uses the assembly interpreter in production, which takes roughly 63 times the runtime of the native version to run the same code.</p>
<p>While the number above is good enough for its initial use case, the optimization work does not stop here. In an <a href="https://github.com/xxuejie/ckb-vm/tree/rvv-crypto">experimental</a> <a href="https://github.com/xxuejie/rvv-prototype/tree/rvv-crypto/bn128-example/src/rvv_crypto">branch</a>, CKB-VM, with <a href="https://github.com/riscv/riscv-v-spec">RISC-V V extension</a> enabled, can achieve the following benchmark results performing <a href="https://eips.ethereum.org/EIPS/eip-197">alt_bn128 pairing check</a> used in <a href="https://github.com/ethereum/go-ethereum/blob/8363f79f8fd735d6264e7549e7f861467fbf6c78/core/vm/contracts_test.go#L262">ethereum</a>.</p>
<pre><code>| test              | CKB-VM (ns)  | Native (ns) | Slowdown Ratio |
|-------------------|--------------|-------------|----------------|
| jeff1             |     22849143 |     2201627 |    10.37829887 |
| jeff2             |     22821825 |     2370538 |    9.627276593 |
| jeff3             |     22908230 |     2099845 |    10.90948618 |
| jeff4             |     29457042 |     2936476 |     10.0314261 |
| jeff5             |     29446342 |     2854710 |    10.31500292 |
| jeff6             |     22965152 |     2231241 |    10.29254661 |
| empty_data        |      9380158 |      750076 |     12.5056101 |
| one_point         |     16386542 |     1491860 |    10.98396766 |
| two_point_match_2 |     22520464 |     2077081 |    10.84236195 |
| two_point_match_3 |     22933197 |     2109833 |    10.86967405 |
| two_point_match_4 |     22907839 |     2095003 |     10.9345137 |
| ten_point_match_1 |     74829613 |     8210023 |    9.114421848 |
| ten_point_match_2 |     75258830 |     8331438 |    9.033114091 |
| ten_point_match_3 |     23011676 |     2155727 |    10.67467077 |
</code></pre><p>Note that the 2 tables shown above uses different time metric: the previous one is measured in microseconds, while the latter one is in nanoseconds.</p>
<p>This means with the help of V extension, CKB-VM can run the same algorithm within an order of magnitude compared to native code. And let&rsquo;s not forget that CKB-VM tested here is still a simple interpreter design, which personally I think is already quite a decent result.</p>
<p>And we can go even further than this:</p>
<pre><code>$ git clone https://github.com/xxuejie/ckb-vm-bench-scripts
$ cd ckb-vm-bench-scripts
$ git checkout 1a3d3c7141ba96674d655269bb61e76100508a4d
$ git submodule update --init --recursive
$ sudo docker run --rm -it -v `pwd`:/code nervos/ckb-riscv-gnu-toolchain:bionic-20211214 bash
root@27cec412ae10:/# cd /code
root@27cec412ae10:/code# make
root@27cec412ae10:/code# exit
$ cargo install --example ckb-vm-llvm-aoter \
  --features llvm-aot ckb-vm-contrib@0.2.0
$ ckb-vm-llvm-aoter -i ./build/secp256k1_bench_10000 --generate run-result -t run 033f8cf9c4d51a33206a6c1c6b27d2cc5129daa19dbd1fc148d395284f6b26411f 304402203679d909f43f073c7c1dcf8468a485090589079ee834e6eed92fea9b09b06a2402201e46f1075afa18f306715e7db87493e7b7e779569aa13c64ab3d09980b3560a3 foo bar
Time to generate object: 1.686690072s
Time to run program: 886.551225ms
</code></pre><p>In the above section, we do the following things:</p>
<ul>
<li>Build the same code to do secp256k1 verification as used in the first benchmark, but tweak the code to run 10000 times</li>
<li>Install a binary to run RISC-V programs via CKB-VM&rsquo;s new <a href="https://github.com/xxuejie/ckb-vm-contrib/tree/main/src/llvm_aot">LLVM based AOT engine</a></li>
<li>Use the LLVM AOT engine to run the secp256k1 verification code</li>
</ul>
<p>Log shows that it takes about 886.55 milliseconds to do 10000 secp256k1 verifications. If we do the math, this means the new LLVM AOT engine can do 1 secp256k1 verification in 88.655 microseconds, Which is merely <strong>2.34x</strong> of native speed! Now we can complete the benchmark:</p>
<pre><code>|                               | µs    | Ratio  |
|-------------------------------|-------|--------|
| CKB-VM (Rust interpreter)     | 12034 | 316.68 |
| CKB-VM (Assembly interpreter) |  2417 | 63.61  |
| CKB-VM (Old AOT)              |  1741 | 45.82  |
| Wasmtime 0.40.1               |   228 | 6.0    |
| WAVM nightly/2022-05-14       |   185 | 4.87   |
| CKB-VM (LLVM AOT engine)      |    89 | 2.34   |
| Native                        |    38 | 1.0    |
</code></pre><p>This is even more interesting when we focus on all the variations of CKB-VM:</p>
<ul>
<li>Assembly interpreter runs plain RV64IMC code in 63x the runtime of native x64 programs compiled from the same code.</li>
<li>Old AOT(to distinguish between the two, I will refer the <a href="https://github.com/nervosnetwork/ckb-vm/tree/4575b0b423b726f3e98b8093481d1d0bfc9efbe7/src/machine/aot">previous AOT engine</a> powered by dynasm as <code>old AOT</code>, and the new AOT engine powered by LLVM as <code>LLVM AOT</code>) engine runs plain RV64IMC code in 45x the runtime of native x64 programs compiled from the same code.</li>
<li>By vectorizing code using RISC-V V extension, CKB-VM runs V enabled code in 10x the runtime of native x64 programs for the same algorithm.</li>
<li>New LLVM AOT engine runs plain RV64IMC code in 2.34x the runtime of native x64 programs compiled from the same code.</li>
</ul>
<p>I&rsquo;m sure you will wonder how this is achieved, this post will talk in more details about the new LLVM AOT engine, including its design and unfinished work for the future.</p>
<p>Warning: this is gonna be a loooooooooong article. I do want to keep everything together as a reference(a good excuse for being lazy :P), but feel free to jump to individual sections as you like:</p>
<ul>
<li><a href="#design">Design</a></li>
<li><a href="#unfinished-work">Unfinished Work</a></li>
</ul>
<h2 id="design">Design</h2>
<p>The design for the LLVM AOT engine, keeps coming back to one question: what are the differences between code executed via CKB-VM, and code executed natively on a x64 machine? Like all virtual machines, CKB-VM will naturally incur many overheads on the program running inside, but what overheads can be removed, and where is the absolute upper limit we can aim?</p>
<h3 id="jitaot">JIT/AOT</h3>
<p>First thing here is the interpreter overhead of course. All interpreters, no matter how fast they are, will contain decoding &amp; cleanup work, which are useless to the actual computation but still consumes time. I touched this on a previous <a href="https://docs.google.com/presentation/d/163YaHngpbm9aaYxu2jhPHU0OefHLf-7d537BCQFmLdE/edit?usp=sharing">presentation</a>, note please do ignore the benchmark numbers included in the slides, they are done in a defected way, while the numbers include in this post are more recent, and are to the best of my knowledge, performed in a more precise way.</p>
<p>To aim at the absolute limit, we will have to <em>compile</em> RISC-V assemblies to native assemblies for the host platform somehow. The old AOT engine uses <a href="https://luajit.org/dynasm.html">dynasm</a> for this task. Looking back now, I wouldn&rsquo;t really say that the old AOT engine is <em>compiling</em> the code, it&rsquo;s more like <em>transpiling</em> each RISC-V instruction one by one into a few assemblies for the native platform. This actually makes sense, since dynasm really stands for <code>dynamic assembler</code>. Even in LuaJIT, the original use case for dynasm, it&rsquo;s only the interpreter that is built via dynasm, the underlying JIT uses a different code emitting solution with a whole lot of optimizations sitting on top. In a nutshell, the old AOT engine is merely <em>assembling</em> code, not <em>compiling</em> code.</p>
<p>I don&rsquo;t have the time to build a full compiler with a lot of moving parts, nor do I think I can compete with some of the best minds in our industry. That brings me to a common solution: LLVM will be leveraged here as the workhorse to <em>compile</em> RISC-V assemblies to native code. Here&rsquo;s one funny story to support the above argument: while working on the LLVM AOT engine, I used <a href="https://github.com/nervosnetwork/ckb-vm/blob/4575b0b423b726f3e98b8093481d1d0bfc9efbe7/tests/programs/mop_adc.S">this program</a> as a simple test to build the LLVM glue part, and LLVM took the liberty of optimizing this whole program to the following native code:</p>
<pre><code>0000000000000000 &lt;function_10078&gt;:
   0:    49 c7 44 24 38 01 00     movq   $0x1,0x38(%r12)
   7:    00 00 
   9:    41 c6 84 24 21 01 00     movb   $0x2,0x121(%r12)
  10:    00 02 
  12:    bb 9c 01 01 00           mov    $0x1019c,%ebx
  17:    ba 01 00 00 00           mov    $0x1,%edx
  1c:    b9 01 00 00 00           mov    $0x1,%ecx
  21:    41 ba 5d 00 00 00        mov    $0x5d,%r10d
  27:    31 f6                    xor    %esi,%esi
  29:    e8 00 00 00 00           call   2e &lt;function_10078+0x2e&gt;
</code></pre><p>(Please ignore the final <code>call</code> here, the call here really uses FFI to call into Rust code denoting CKB-VM to exit execution)</p>
<p>All the tests, branches in the original RISC-V program are optimized away, LLVM has <em>executed</em> those branches internally in the optimization passes, leaving only a few x64 instructions to set the RISC-V registers to final values when exiting the program.</p>
<p>This serves as an illustration as the distinction between <em>compiling</em> and <em>transpiling/assembling</em> mentioned above. The old AOT engine won&rsquo;t perform optimizations like this. Nor am I saying all programs running on the LLVM AOT engine will be optimized away, but it&rsquo;s one step closer to the upper limit.</p>
<p>You might also notice that I keep using the phrase <em>AOT</em> instead of <em>JIT</em>. I personally consider a JIT would have the following workflow:</p>
<ul>
<li>An interpreter powers initial execution, and profiles either function calls(method JIT) or control flows(tracing JIT) at runtime.</li>
<li>Only when a piece of code becomes too hot, does the JIT optimizes the code, resulting in native code to be executed later.</li>
</ul>
<p>Both AOT engines implemented for CKB-VM would compile the whole program ahead of time without running it first, resulting a whole pile of native code somewhere, only at this point does the VM boot with the native code installed. No profiling work is performed by CKB-VM in both AOT engines. Hence we are calling it <em>AOT</em>, not <em>JIT</em>.</p>
<p>That being said, there is still difference between the 2 AOT engines: the old AOT engine generates a bulk of binary data, all one needs to do, is marking the binary data as executable in memory, and the old AOT engine is good for execution. One can even save the binary data locally to a plain file, then load it back to memory later for execution. The LLVM AOT engine, on the other hand, would generate object file, one either statically links the object file with his/her program, or further build a dynamic linking library from the object file, then loads it dynamcally via <code>dlopen</code> at runtime. Either way, the LLVM AOT engine is more leaning into the build process, than a runtime component.</p>
<h3 id="ast-preprocessor">AST Preprocessor</h3>
<p>Luckily, the <a href="https://github.com/nervosnetwork/ckb-vm/blob/4575b0b423b726f3e98b8093481d1d0bfc9efbe7/src/instructions/ast.rs#L46">AST data structure</a> used in the old AOT engine is still usable. While a direct documentation on the AST is not available, an <a href="https://github.com/xxuejie/ckb-vm-contrib/blob/65582d7d609180fd7ce923a8260e671d643aa9e6/src/ast_interpreter.rs#L10">AST interpreter function</a> combined with trait implementations on <a href="https://github.com/nervosnetwork/ckb-vm/blob/4575b0b423b726f3e98b8093481d1d0bfc9efbe7/src/instructions/register.rs#L413">u64 type</a> provides a reference implementation on AST semantics. Like the old AOT module, an <a href="https://github.com/xxuejie/ckb-vm-contrib/blob/65582d7d609180fd7ce923a8260e671d643aa9e6/src/llvm_aot/ast.rs#L146">AstMachine</a> is built so we can <em>execute</em> RISC-V instructions on the AstMachine, reducing RISC-V instruction semantics to simplified register &amp; memory writes using simple AST values, much like the example below:</p>
<pre><code>  Basic block (insts: 9) 0x101bc-0x101d6:
  Possible targets after block: 0x1a4d4, 0x101d6
    Write batch 0
      Register[ a5 ] = 0x20
    Write batch 1
      Memory[ (Reg(sp) + 0x178) ]@4 = Reg(a5)
    Write batch 2
      Register[ a5 ] = 0x11
    Write batch 3
      Register[ a5 ] = (Reg(a5) &lt;&lt; 0x23)
    Write batch 4
      Register[ a2 ] = 0x20
    Write batch 5
      Register[ a1 ] = (Reg(sp) + 0x8)
    Write batch 6
      Register[ a0 ] = (Reg(sp) + 0xa8)
    Write batch 7
      Memory[ (Reg(sp) + 0x170) ]@8 = Reg(a5)
    Call to 0x1a4d4 (with writes) (sha3_update)
      Register[ ra ] = 0x101d6
</code></pre><p>Which corresponds to the following original RISC-V instructions:</p>
<pre><code>   101bc:	02000793          	li	a5,32
   101c0:	16f12c23          	sw	a5,376(sp)
   101c4:	47c5                	li	a5,17
   101c6:	178e                	slli	a5,a5,0x23
   101c8:	02000613          	li	a2,32
   101cc:	002c                	addi	a1,sp,8
   101ce:	1128                	addi	a0,sp,168
   101d0:	fabe                	sd	a5,368(sp)
   101d2:	3020a0ef          	jal	ra,1a4d4 &lt;sha3_update&gt;
   101d6:	112c                	addi	a1,sp,168
</code></pre><p>From there, we can focus only on the AST semantics when we build the LLVM based code generation engine, no RISC-V semantics are required here.</p>
<p>The <a href="https://github.com/xxuejie/ckb-vm-contrib/blob/65582d7d609180fd7ce923a8260e671d643aa9e6/src/llvm_aot/preprocessor.rs">preprocessor</a> wraps this process with a few more things to work on:</p>
<ol>
<li>Use symbol table(if present) &amp; inferred information(e.g: <code>jal</code> would mark the start of a function) to deduce all functions within an ELF object.</li>
<li>For each function, locate all basic blocks(a sequence of instructions that ends with a branch instruction) within the function.</li>
<li>For each basic block, run the instructions included on the AstMachine, gather generated <a href="https://github.com/xxuejie/ckb-vm-contrib/blob/65582d7d609180fd7ce923a8260e671d643aa9e6/src/llvm_aot/ast.rs#L14">writes</a> for each target(could be register or memory), the value in each write, will be in an AST value format. Notice a RISC-V instruction might generate more than one writes, they will need to be committed atomically.</li>
<li>Each basic block, depending on the last instruction, could also generate a <a href="https://github.com/xxuejie/ckb-vm-contrib/blob/65582d7d609180fd7ce923a8260e671d643aa9e6/src/llvm_aot/ast.rs#L63">control change</a>, based on RISC-V&rsquo;s convention, some branching instructions will be interpreted specially, such as calls, returns, etc.</li>
<li>The preprocessor also does limited AST <a href="https://github.com/xxuejie/ckb-vm-contrib/blob/65582d7d609180fd7ce923a8260e671d643aa9e6/src/llvm_aot/ast.rs#L416-L479">simplification</a> so as to simplify control changes.</li>
</ol>
<p>After the <code>preprocess</code> function, we will have a set of functions consisting of basic blocks, each basic block will also contain a series of <code>writes</code> and <code>control</code> changes. Those shall be directly fed into the LLVM engine for actual code generation.</p>
<p>If you have followed the previous steps to run the LLVM AOT engine, you can use the following command to take a peek at the output from the <code>preprocess</code> function:</p>
<pre><code>$ ckb-vm-llvm-aoter -i ./build/secp256k1_bench --generate writes
</code></pre><h3 id="register-allocation">Register Allocation</h3>
<p>Aiming at the upper limit, register allocation will be a huge topic. RISC-V has 32 general purpose registers with one additional PC register, while x64 only grants us 16 general purpose registers, one of them (<code>rsp</code>) has to keep the native stack. In the interpreter design of CKB-VM, all RISC-V registers are kept in memory. Even though the old AOT engine tries to tackle this problem, only <code>ra</code>, <code>sp</code> and <code>a0</code> are kept in x64 registers. Others will be used for bookkeeping reasons, including 5 temporary registers due to a lack of register allocator! While I do believe the memory used to keep RISC-V registers will most likely be in CPU cache, still it prevents the CPU from doing renaming for better performance, unless running on <a href="https://www.agner.org/forum/viewtopic.php?t=41">very recent CPU</a>. Even so, there are quirks we might run into, chances are the performance is still not on par.</p>
<p>Drawing <a href="https://home.in.tum.de/~engelke/pubs/2104-vee-slides.pdf">inspirations</a> from the acedemia, <a href="https://reviews.llvm.org/D12681">HHVM calling convention</a> can be used for this problem. First used by <a href="https://github.com/facebook/hhvm/blob/master/hphp/doc/hackers-guide/jit-core.md">HHVM JIT</a>, this special calling convention allows a function to have 15 arguments all put in registers, and also return 14 arguments in registers. In LLVM AOT engine, we design the code so each RISC-V function is generated into one native x64 function. Except for one argument used to keep a pointer to the <code>LlvmAotMachineData</code> struct, 14 x64 registers can be used to keep 14 hot RISC-V registers, and when the function returns, the updated values for those 14 RISC-V registers can also be returned as function arguments, to the caller function. This way we can keep as many RISC-V registers in x64 registers as possible. When temporary registers are needed(e.g: the unfortunate restriction that shift operands can only live in <code>rcx</code>, or that <code>mul</code>/<code>div</code> only affects <code>rax</code>/<code>rdx</code>), we can trust LLVM to help us perform correct register spills. This results in the following workflow:</p>
<ul>
<li>When booting the AOT engine, a function in x86_64 calling convention will load 14 RISC-V registers from the <code>LlvmAotMachineData</code> struct, it then invokes the RISC-V entry function in HHVM calling convention using all 14 RISC-V registers together with a pointer to the <code>LlvmAotMachineData</code> struct.</li>
<li>When the RISC-V entry function is calling another RISC-V function in HHVM calling convention, it also passes the exact 14 RISC-V registers with a pointer to <code>LlvmAotMachineData</code> struct.* A RISC-V function might choose to do certain operations among its RISC-V registers, for the 14 hot registers, they can simply alter the corresponding x64 registers, for the other RISC-V registers, memory load/store will be required with the help of pointer to <code>LlvmAotMachineData</code> struct.</li>
<li>When a RISC-V function returns, it would return the updated values for the 14 hot RISC-V registers.</li>
<li>This process might continue for a bit.</li>
<li>When we are finally ready to return to the x86_64 calling convention world from RISC-V functions, we use the latest values in the 14 x64 registers to update corresponding locations in <code>LlvmAotMachineData</code> struct, writing back updated values.</li>
</ul>
<p>Fundamentally, we are still storing all RISC-V registers in <code>LlvmAotMachineData</code> struct resided in memory, for a majority of computation, only the x64 registers are required. What&rsquo;s left is just keeping the code within RISC-V functions using HHVM calling convention long enough.</p>
<p>There is still one quirk: due to some reasons, the order of registers used in function arguments, are different from arguments used in return values. For example, the 3rd argument is kept in <code>rbp</code>, while the 3rd return value is returned in <code>rdi</code>. If we simply denote the 3rd argument and the 3rd return value for one RISC-V register, for example, <code>a0</code>, there will still be operations moving values from <code>rbp</code> to <code>rdi</code> when a RISC-V function returns. While a simple register move is quite small, it is still work and could accumulate to be quite some running time. To avoid this situation, LLVM AOT engine is designed to use the following mapping:</p>
<p><img src="https://xuejie.space/images/hhvm-regs.png" alt="HHVM Based Register Flow"></p>
<p>Here we can see the RISC-V register <code>a0</code> is passed as the 5th argument, and returned as the 3rd return value. The x64 register <code>rdi</code>, happens to be used both as the 5th argument and the 3rd return value in this design. As a result of this, no additional work will be needed to move registers around when returning from a RISC-V function.</p>
<p>Of all the 33 RISC-V registers, we can only keep 14 registers in x64 registers. This means we will have to prioritize hot registers. So while the actual RISC-V registers used in the above mapping might change in the future, the general mapping structure stays the same: for each hot RISC-V register, the same x64 register will be used to pass it both as function argument, and as return value.</p>
<p>HHVM set aside one callee saved register <code>R12</code> for thread-local area, which can perfectly be used for us to pass the pointer to <code>LlvmAotMachineData</code> struct around. This pointer is only needed as an argument, all RISC-V function has it, so there&rsquo;s no need to pass it as a return value.</p>
<p>With this design, I think we&rsquo;ve achieved all we can in terms of register allocation, given the x86_64 architecture.</p>
<h3 id="mmap-based-memory">Mmap based memory</h3>
<p>In all previous CKB-VM engines, memory boundary &amp; permission checkings are manual performed in code. This solution, while being secure, completely ignores modern <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>s. The <a href="https://en.wikipedia.org/wiki/W%5EX">W^X</a> policy used by CKB-VM now can perfectly be implemented via operating system <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">constructs</a>. Since the OS will check for this anyway, why bother performing the same checking in CKB-VM? The LLVM AOT engine runner is thus directly using <code>mmap</code> and similar constructs on non-POSIX OSes to initialize memory for CKB-VM, and thus relying OS to do memory permission checking. This new design does come with a few tradeoffs:</p>
<ul>
<li>Boundary checking becomes tricker since an attacker might try to trick the code on certain parts in current process, but do not belong to CKB-VM. This can be mitigate with several strategies:
<ul>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>, or address space layout randomization is a widely used technique in modern OSes, meaning at each execution, our program can land on different addresses, hopefully rendering this technique to be less effective.</li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/34913.pdf">Native Client</a> also gives us an idea here: we can statically cap each address used for memory operations. For example, CKB-VM, in its conventional configuration, uses 4MB memory. This means for each address <code>addr</code>, <code>addr &amp; 0x3fffff</code> will give the capped address well within valid address range. While this certain adds slightly more code to run, it shall be an acceptable compromise judging by the results from the Native Client paper.</li>
</ul>
</li>
<li>We will also need to consider error handling now: certain errors, such as memory violations, are not Rust errors anymore, they now become OS level signals. This means one might want to wrap the LLVM AOT engine in its own process for best security, and ease of handling.</li>
<li>While the answer is not necessarily yes, there might be implications when we mark memory pages containing RISC-V instructions as <em>executable</em> on x64 machine. It requires more study to say if this will bring harm to the host machine.</li>
</ul>
<p>There is also one thing that comes free: <code>MAP_ANONYMOUS</code> provides free, OS level zero-filled page, which means we don&rsquo;t need to do manual memory initialization as well.</p>
<h3 id="calls">Calls</h3>
<p>To best aid modern CPU&rsquo;s branch predictors, LLVM AOT engine compiles each RISC-V function into each x86 host function. Each RISC-V function call is also transformed into an x86 host function call. This choice has implications on both sides:</p>
<p>On the good side, it simplifies the handling of returns. Take the following RISC-V function for example:</p>
<pre><code>000000000001209c &lt;secp256k1_pubkey_load&gt;:
   1209c:	711d                	addi	sp,sp,-96
   1209e:	87b2                	mv	a5,a2
   120a0:	e8a2                	sd	s0,80(sp)
   120a2:	e4a6                	sd	s1,72(sp)
   120a4:	842e                	mv	s0,a1
   120a6:	04000613          	li	a2,64
   120aa:	85be                	mv	a1,a5
   120ac:	84aa                	mv	s1,a0
   120ae:	850a                	mv	a0,sp
   120b0:	e0ca                	sd	s2,64(sp)
   120b2:	ec86                	sd	ra,88(sp)
   120b4:	12c090ef          	jal	ra,1b1e0 &lt;memcpy&gt;
   120b8:	6722                	ld	a4,8(sp)
   120ba:	66e2                	ld	a3,24(sp)
   120bc:	6602                	ld	a2,0(sp)
...
</code></pre><p>There is a function call to <code>memcpy</code> at <code>0x120b4</code>, calling into <code>memcpy</code> is a piece of cake, but what about returning from memcpy? There are 2 addresses involved:</p>
<ul>
<li>The RISC-V side return address <code>0x120b8</code></li>
<li>The native x64 side address for executing <code>ld	a4,8(sp)</code></li>
</ul>
<p>Both the interpreter and the old AOT engine pay no attention to function calls at all, they all just treat calls as plain jumps, and only maintain the call stack at RISC-V side. Another way of seeing this, is that the old AOT engine treat an entire RISC-V program as a single function. Internally it&rsquo;s jumps all the way down. While this certainly simplify things a bit, it confuses CPU&rsquo;s branch predictor, which is one of the major bottleneck in current CKB-VM. To eliminate this overhead as much as possible, the LLVM AOT engine would maintain both stacks, and generate x64 native calls directly when RISC-V function calls are encountered.</p>
<p>Which brings us to the bad side of this design:</p>
<p>When the RISC-V call, emitted as a native x64 call is executed, 2 return values are generated:</p>
<ul>
<li>The native x64 return address is kept in x64&rsquo;s stack</li>
<li>The RISC-V return address is kept in RISC-V&rsquo;s <code>RA</code> register, whether it&rsquo;s kept in a x64 register or in memory</li>
</ul>
<p>Here&rsquo;s the return part from <code>memcpy</code>:</p>
<pre><code>   1b22c:	9be1                	andi	a5,a5,-8
   1b22e:	07a1                	addi	a5,a5,8
   1b230:	973e                	add	a4,a4,a5
   1b232:	95be                	add	a1,a1,a5
   1b234:	01176663          	bltu	a4,a7,1b240 &lt;memcpy+0x60&gt;
   1b238:	8082                	ret
</code></pre><p>At address <code>0x1b238</code>, this function returns, different from x64 conventions, RISC-V expects the return address to be in <code>RA</code> register. A <code>ret</code> instruction is essentially just <code>jalr zero, ra, 0</code>.</p>
<p>Now there are 2 cases:</p>
<ul>
<li>For a program respecting RISC-V calling convention, when <code>secp256k1_pubkey_load</code> calls <code>memcpy</code>, by the time <code>memcpy</code> return, <code>RA</code> register will contain the address in <code>secp256k1_pubkey_load</code> following the <code>memcpy</code> call, in the above example, <code>0x120b8</code></li>
<li>For a sophisticated(not necessarily evil) program that might be trying to be clever, it might modify <code>RA</code> to be something else. At this stage, executing <code>ret</code> will not return us to <code>secp256k1_pubkey_load</code>, but might take us to a different location in a different function. This means RISC-V calling stack does not always align with x64 calling stack. RISC-V specification allows such behavior to happen.</li>
</ul>
<p>To cope with this situation, the LLVM AOT engine would generate code to save the value of <code>RA</code> register when executing a RISC-V call, and when later return happens, the generated code would check the value in <code>RA</code> register then, with the saved <code>RA</code> value. If they do match, the RISC-V calling stack does match the x64 calling stack, and we can use x64&rsquo;s <code>ret</code> instruction to return to previous function. If not, maybe the program is trying to be clever, we will terminate the generated code from AOT engine, and resume executing via a CKB-VM interpreter mode.</p>
<p>This also introduce&rsquo;s one design principle of the LLVM AOT engine:</p>
<p><strong>CKB-VM&rsquo;s LLVM AOT engine should be able to execute all programs permitted by RISC-V specification without errors. For certain programs that are predictable, the LLVM AOT engine should make them as fast as possible, closing to native speed.</strong></p>
<p><code>ckb-vm-llvm-aoter</code> is equipped with a <code>fast</code> mode switch. When turned on, it would only execute those programs that it can run fast, for programs that are valid but try to be clever, it might terminate with an error. When the fast mode is off, the LLVM AOT engine would perfectly run all RISC-V programs, it would switch to an embedded interpreter if AOT engine fails with certain code path.</p>
<h3 id="hurdling-special-code-path">Hurdling Special Code Path</h3>
<p>Modern compilers are sophisticated enough that they would build all kinds of tricks to make program run fast. This means some program, while adhering the RISC-V specification as well as calling convention, might come as a surprise for us. We do want to make as many programs as possible to run <em>fast</em> on the LLVM AOT engine, this means sometimes we will have to cope with such successes. Here&rsquo;s a story making unrolled <code>memset</code> to run <em>fast</em>.</p>
<p>The memset talked about lives at <a href="https://github.com/nervosnetwork/riscv-newlib/blob/04f240198c1451b853d8f84b6df99ecf510e3a0c/newlib/libc/string/memset.c#L38">here</a>, when compiled with GCC, the following code would be generated:</p>
<pre><code>000000000001b2c8 &lt;memset&gt;:
   ...
   1b2ee:	40c306b3          	sub	a3,t1,a2
   1b2f2:	068a                	slli	a3,a3,0x2
   1b2f4:	00000297          	auipc	t0,0x0
   1b2f8:	9696                	add	a3,a3,t0
   1b2fa:	00a68067          	jr	10(a3)
   ...
   1b2fe:	00b70723          	sb	a1,14(a4)
   1b302:	00b706a3          	sb	a1,13(a4)
   // All sb operations here 
   1b332:	00b700a3          	sb	a1,1(a4)
   1b336:	00b70023          	sb	a1,0(a4)
   1b33a:	8082                	ret
   ...
   1b358:	00000297          	auipc	t0,0x0
   1b35c:	9696                	add	a3,a3,t0
   1b35e:	8286                	mv	t0,ra
   1b360:	fa2680e7          	jalr	-94(a3)
   ...
</code></pre><p>For the length of this already-super-long post, I&rsquo;ve eliminated irrelavant part. Leaving 3 interesting pieces:</p>
<ul>
<li><code>0x1b2ee</code> - <code>1b2fa</code> would build a target PC value between <code>0x1b2fe</code> and <code>0x1b33a</code>, and jump to it.</li>
<li><code>0x1b2fe</code> - <code>0x1b33a</code> all contains plain <code>sb</code> instruction storing values at memory location <code>0(a4)</code> - <code>14(a4)</code>.</li>
<li><code>0x1b358</code> - <code>0x1b360</code> would build a target PC value between <code>0x1b2fe</code> and <code>0x1b33a</code>, treat it as a function entry point, and call to it.</li>
</ul>
<p>If you look at the original C code, there&rsquo;s no constructs like the above, this is actually due to <a href="https://en.wikipedia.org/wiki/Loop_unrolling">loop unrolling</a>, there is also a designated name for such a construct: <a href="https://en.wikipedia.org/wiki/Duff%27s_device">Duff&rsquo;s device</a>. It helps remove the conditional branching needed to do at the expense of code size. I do want to warn you that Duff&rsquo;s Device is not always a panacea, it can <a href="https://lkml.indiana.edu/hypermail/linux/kernel/0008.2/0171.html">cause problems</a>.</p>
<p>Basically, what we are dealing here, is 2 cases that are not previously handled by the LLVM AOT engine:</p>
<ul>
<li>The code jumps to a place that is not known as the start of a basic block.</li>
<li>The code calls into a place that is not known as the start of a function, nor the start of a basic block.</li>
</ul>
<p>Luckily, the 2 code pieces are not too long, and we can set some rules to handling them:</p>
<ul>
<li>When the code jumps to unknown place, <em>call</em> the interpreter to execute till the end of current basic block, then use current PC to find the next basic block. If we can find a basic block that starts with the same address as current PC, we navigate to this basic block and continue AOT mode execution. If not, we <em>unwind</em> to interpreter from now on.
<ul>
<li>For each such function, we actually would generate a special code piece, that does binary searching on all basic block starts, finding the target basic block.</li>
</ul>
</li>
<li>When the code calls to unknown place, <em>call</em> the interpreter to execute till the end of function, then use current PC to find the next basic block. If we can find a basic block that starts with the same address as current PC, we navigate to this basic block and continue AOT mode execution. If not, we <em>unwind</em> to interpreter from now on.
<ul>
<li>For now, we only handle the case that the inner function called is within current function. Internal calling into external function might be added later.</li>
</ul>
</li>
</ul>
<p>This means the actual <a href="https://en.wikipedia.org/wiki/Control-flow_graph">control flow graph</a> for a generated function, might look at the following: on the left there are block 1, 2, 3, 4 generated from the same constructs in the corresponding RISC-V function, on the right there is also an attached <code>Indirect Dispatch Block</code>, which does binary search and dispatch PC advanced by interpreter to either of the 4 blocks.</p>
<p><img src="https://xuejie.space/images/cfg.png" alt="Control Flow Graph"></p>
<p>Some of you might have a question now: &ldquo;previously you were saying that terminating AOT engine due to different calling stacks result in slow executiong in interpreter, but here you were also using the interpreter to get fast execution?&rdquo;</p>
<p>The answer here, lies in the different terminologies:</p>
<ul>
<li><em>call</em> the interpreter</li>
<li><em>unwind</em> the interpreter, or as in previous case, terminates the AOT engine</li>
</ul>
<h3 id="call-to-interpret-vs-unwind-to-interpret">Call to interpret vs. Unwind to interpret</h3>
<p>In the LLVM AOT engine, there are 2 ways to use the interpreter:</p>
<p><img src="https://xuejie.space/images/call-unwind.png" alt="Call to interpret vs unwind to interpret"></p>
<ul>
<li>A RISC-V function can <em>call</em> into the interpreter, asking the interpreter to interpret some code, the control is thus turned back into the RISC-V function, both calling stacks are not altered. This is shown as the graph on the left.</li>
<li>The graph on the right, however, shows a different path: at some cases, such as a mismatched stack, the AOT engine cannot proceed further, as a result, we need to <em>unwind</em> the full x64 calling stack. In the above example, this means the x64 calling stack for <code>foo</code>, <code>bar</code> and <code>baz</code> are all destroying, reverting back to x64 entry function, which then calls into the interpreter to execute some code. Even later we decide that we might re-enter <code>bar</code>, there is only RISC-V calling stack for <code>bar</code> preserved, the x64 calling stack for <code>bar</code> is completely discarded. This means when bar returns, there will not be matching x64 stack for <code>foo</code>, once again the control will be unwinded to x64 entry function. This is the slow path we definitely want to avoid.</li>
</ul>
<h3 id="recap">Recap</h3>
<p>There might be more overheads hidden, we are still revising the design. But those changes already push CKB-VM way forward towards the absolute limit. We might never reach native speed due to the extra work such as setting extra PC, maintaining dual calling stack, return &amp; indirect checkings, but we will be sure to aim at high as we can get.</p>
<h2 id="unfinished-work">Unfinished Work</h2>
<p>There are also certain known work that can be done now.</p>
<h3 id="more-host-architectures-more-guest-configurations">More Host Architectures, More Guest Configurations</h3>
<p>Right now the LLVM AOT engine is tied on running RV64IMCB code on x86_64 machine. But there are certainly other directions we can push forward:</p>
<ul>
<li>Run the LLVM AOT engine on aarch64 host machine.</li>
<li>With <a href="https://www.kickstarter.com/projects/starfive/visionfive-2">VisionFive 2</a> coming, will it make sense to run CKB-VM on a true RISC-V CPU? And what are the challenges?</li>
<li>Running other RISC-V configurations is also an interesteing choice, such as RV32IM or RV32IMF</li>
</ul>
<h3 id="llvm-related-work">LLVM Related Work</h3>
<p>There are indeed more LLVM related work done the pipeline. The most imminent one IMHO, is debugger support. Embracing LLVM has one huge advantage here, in that a lot of tooling is already there provided by the awesome community, including <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> support. We shall be able to attach the original RISC-V assembly code to the generated x64 code, hoping to find bugs easier as well as more points to optimize. As a further thinking exercise, what if we can attach the original Rust/C code before the RISC-V assembly, to the final generated x64 code?</p>
<p>Another thing we shall be looking at, is <a href="https://llvm.org/docs/Passes.html">LLVM&rsquo;s optimization passes</a>, right now we got there by applying a few simple passes as recommended in the <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.html#id3">Kaleidoscope tutorial</a>. But building a native code translator definitely employs different tradeoffs from building a high-level language compiler. It&rsquo;s worthwhile going through LLVM passes to see if we can further squeeze some performance.</p>
<p>Lastly, there is also one exciting topic: LLVM has introduced <a href="https://llvm.org/devmtg/2016-11/Slides/Emerson-ScalableVectorizationinLLVMIR.pdf">ScalableVector</a> in preparation for RISC-V V extension as well as <a href="https://developer.arm.com/Architectures/Scalable%20Vector%20Extensions">ARM SVE</a>. While one path is tapping LLVM AOT engine with the V extension interpreter, what if we can leverage LLVM ScalableVector to build RISC-V V extension support? Will that bring something totally different to the table? I gotta admit I wasn&rsquo;t so familiar with LLVM ScalableVector, and I&rsquo;m only dreaming here.</p>
<h3 id="inferring-on-memset-constructs">Inferring on memset constructs</h3>
<p>As mentioned above, while all RISC-V programs run on the LLVM AOT engine, some are powered by interpreter. We do want to minimize those programs that require <em>unwinding</em> to the interpreter. I will definitely keep looking at different programs, trying to make as many of them runnable in the fast mode of LLVM AOT engine. A good starting point, is those programs generated by GCC/LLVM.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I still have some other topics I want to talk about but this is already a super long one. It probably is better to save for another day. In the meantime, the introduction on the LLVM AOT engine is rather complete. Let&rsquo;s hope we can put it to good use :)</p>

  </div>

  <div id=links>
    
      <a class="basic-alignment left" href="https://xuejie.space/2022_08_17_is_upstream_ready_for_riscv/">&laquo; Is Upstream Ready for RISC-V?</a>
    
    
  </div>
</section>

  
</body>
</html>



